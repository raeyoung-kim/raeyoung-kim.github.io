[ { "title": "Docker", "url": "/posts/Docker/", "categories": "Docker Study", "tags": "docker란, 도커란, 가상머신 vs 도커 컨테이너", "date": "2023-01-15 00:00:00 +0900", "snippet": "도커란?도커는 컨테이너를 생성하고 관리하기 위한 도구입니다. 리눅스 컨테이너에 여러 기능을 추가하여 애플리케이션을 컨테이너로 조금 더 쉽게 사용할 수 있도록 만들어진 오픈소스 프로젝트로 go 언어로 작성되어 있습니다. 기존에 쓰이던 가상화 방법인 가상 머신과 달리 도커 컨테이너는 성능의 손실이 거의 없어 클라우드 인프라 솔루션으로 주목받고 있습니다. 도커에 관련된 프로젝트로 도커 컴포즈, 레지스트리, 도커 허브 등 여러가지가 있지만 일반적으로 도커는 도커 엔진 or 도커에 관련된 모든 프로젝트를 의미합니다. 도커 엔진은 컨테이너를 생성하고 관리하는 주체로 컨테이너를 제어할 수 있고 다양항 기능을 제공합니다. 도커의 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하기 때문에 핵심이 되는 것은 도커 엔진입니다.컨테이너란?소프트웨어에서 컨테이너란 표준화된 소프트웨어 단위입니다.기본적으로 코드 패키지로 해당 코드를 실행하는데 필요한 종속성과 도구가 포함되어 있습니다.왜 컨테이너를 사용해아할까? 독립된 개발환경을 보장받을 수 있습니다. 서버를 부팅할 때 실행되는 운영체제를 일반적으로 호스트 OS라고 부르는데 도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간입니다. 따라서 컨테이너 내부에 수많은 소프트웨어를 설치하고 설정 파일을 수정해도 호스트 OS 에는 영향을 끼치지 않는 독립된 개발환경을 보장받을 수 있습니다. 도커가 실행되는 모든 곳에서 동일한 애플리케이션을 실행할 수 있습니다. 애플리케이션의 코드를 실행하는데 필요한 종속성과 도구가 포함되어 보관할 수 있으며 도커가 실행되는 모든 곳에서 이를 가져올 수 있기 때문에 어디서든 정확히 동일한 애플리케이션을 실행할 수 있게 됩니다. 모든 것이 컨테이너에 있기 때문에 애플리케이션을 실행하려는 위치에 추가 도구를 설치하는 것에 대해 걱정할 필요가 없습니다. 가상 머신 VS Docker 컨테이너가상머신장점 분리된 환경을 생성할 수 있습니다. 그 안에 환경별 구성을 가질 수 있습니다. 모든 것을 안정적으로 공유하고 재생산이 가능합니다.단점 중복 복제로 낭비되는 공간이 발생하게 됩니다. 호스트 시스템 위에 추가 시스템이 실행되고 있기 때문에 성능이 나빠질 수 있으며 특히 이러한 시스템이 여러 개 있는 경우 실제로 그 성능은 저하될 것입니다. 개발에서 생산한 제품을 배포하려면 가상 머신과 동일한 방식으로 프로덕션 머신을 구성해야 합니다. 재상산 및 공유가 가능하더라도 원하는 모든 시스템이 해당 버츄얼 머신을 설정해야 하고 정확히 동일한 방식으로 구성해야 하기 때문에 까다로울 수 있습니다.Docker 컨테이너도커 컨테이너는 가상 머신의 단점을 해결할 수 있습니다.장점 컨테이너를 사용하면 호스트 운영체제(윈도우, 맥 OS, 리눅스)가 존재하지만 하나의 머신에 몇 대의 머신을 설치하지는 않습니다. 대신 컨테이너 애뮬레이트를 지원하는 내장 컨테이너를 활용합니다. 구성파일을 사용하여 컨테이너를 구성하고 설명할 수 있습니다. 그 파일을 다른 사람들과 공유하여 다른 사람들이 컨테이너를 다시 만들 수 있도록 하거나 컨테이너 이지미라 불리는 것을 빌드할 수 있습니다. 또 그 이미지를 다른 사람과 공유하여 모든 사람이 자신의 시스템에서 동일한 컨테이너를 시작할 수 있도록 할 수 있습니다.예를 들어, 도커 컨테이너는 아래와 같은 문제점을 해결해 줄 수 있습니다. 로컬 환경인 개발 환경에만 애플리케이션이 동작되는 버전이 설치되고 실제 프로덕트 환경에서는 버전이 일치하지 않아 동작하지 있을 수 있습니다. 팀이나 회사 내의 각각의 개발 환경의 버전이 다를 수 있습니다.(관리하고 설치해야 하는 복잡한 종속성이 있는 복잡한 프로젝트가 있을 수도 있다.) 같은 코드 기반에서 함께 작업할 수 없다면 항상 작동될 것이라는 보장이 없습니다. 혼자서 작업하는 프로젝트가 여러 개인 경우 충돌하는 버전이 있을 수 있습니다.도커 컨테이너는 특정 환경을 도커 컨테이너에 고정하여 제공하여 컨테이너에서 실행되기 때문에 코드가 항상 정확한 버전에서 실행되도록 할 수 있습니다. 따라서 동일한 환경을 것을 가지고 있다는 점에서 항상 동일한 동작과 결과를 제공한다는 이점이 있습니다.이와 같은 장점이 도커와 컨테이너를 사용하는 이유입니다." }, { "title": "Class 클래스", "url": "/posts/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/", "categories": "Javascript", "tags": "javascript class, 자바스크립트 클래스", "date": "2022-12-04 00:00:00 +0900", "snippet": "Class 자바스크팁트는 프로토타입 기반의 객체지향 언어입니다.static method or static properties 프로터타입에 할당되지 않고 생성자 함수 객체에 직접 할당되어있는 프로퍼티와 메소드를static method, static properties라고 합니다. 생성자 함수를 new 연산자 없이 함수로써 호출할 때 사용됩니다. 인스턴스가 직접적으로 접근할 수 없습니다.prototype method 생성자 함수 프로토타입 내부에 할당된 메소드들을 prototype method라고 합니다. 인스턴스가 직접적으로 접근할 수 있습니다.상속 상속을 사용하여 코드의 재사용성을 높일 수 있습니다.ES5 생성자 함수와 프로토타입, 클로저를 사용하여 객체 지향 프로그래밍을 구현할 수 있습니다./** * super class */function Animal(type, name, gender) { this.type = type; this.name = name; this.gender = gender;}/** * static method */Animal.getInfo = function (instance) { return { type: instance.type, name: instance.name, gender: instance.gender, };};/** * prototype method */Animal.prototype.getType = function () { return this.type;};Animal.prototype.getName = function () { return this.name;};Animal.prototype.getGender = function () { return this.gender;};/** * sub class */function Dog(name, gender) { this.type = &quot;dog&quot;; this.name = name; this.gender = gender;}/** * 상속 */Dog.prototype = new Animal(); // 기존에 있던 prototype 객체를 새로운 객체를 할당하는 것과 같기 때문에 Dog의 constructor는 Animal을 가리킨다.Dog.prototype.constructor = Dog; // 다시 기존의 constructor를 다시 할당합니다.Dog.prototype.bark = function () { // Dog의 프로토타입은 새로운 프로토타입을 덮어 씌운 다음 정의해야 합니다. console.log(&quot;wang wang&quot;);};/** * Animal의 static properties(type, name, gender)가 존재하지 않는 prototype을 상속 받고 싶다면 아래와 같이 상속합니다. */function Bridge() {}Bridge.prototype = Animal.prototype;Dog.prototype = new Bridge();Dog.constructor = Dog;Dog.prototype.bark = function () { // Dog의 프로토타입은 새로운 프로토타입을 덮어 씌운 다음 정의해야 합니다. console.log(&quot;wang wang&quot;);};/** * instance */var dog = new Animal(&quot;dog&quot;, &quot;tom&quot;, &quot;male&quot;);dog.getName(); // tomAnimal.getInfo(dog); // {type: &#39;dog&#39;, name: &#39;tom&#39;, gender: &#39;male&#39;}var kong = new Dog(&quot;kong&quot;, &quot;female&quot;);console.dir(kong);ES6 class 키워드를 사용하여 생성자 함수를 클래스로 정의할 수 있습니다./** * super class */class Animal { constructor(type, name, gender) { this.type = type; this.name = name; this.gender = gender; } /** * static method */ static getInfo(instance) { return { type: instance.type, name: instance.name, gender: instance.gender, }; } /** * prototype method */ getType() { return this.type; } getName() { return this.name; } getGender() { return this.gender; }}/** * sub class */class Dog extends Animal { constructor(name, gender) { super(&quot;dog&quot;, name, gender); // 부모 클래스 생성자 호출합니다. } bark() { console.log(&quot;wang wang&quot;); }}/** * instance */var dog = new Animal(&quot;dog&quot;, &quot;tom&quot;, &quot;male&quot;);dog.getName(); // tomAnimal.getInfo(dog); // {type: &#39;dog&#39;, name: &#39;tom&#39;, gender: &#39;male&#39;}var kong = new Dog(&quot;kong&quot;, &quot;female&quot;);console.dir(kong);" }, { "title": "객체 지향 Prototype", "url": "/posts/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-Prototype/", "categories": "Javascript", "tags": "javascript prototype, 자바스크립트 프로토타입, 프로토타입", "date": "2022-12-04 00:00:00 +0900", "snippet": "객체지향 프로그래밍 OOP(Object Oriented Programming) 이란? 서로 관련 있는 데이터와 함수를 객체(하나의 역할을 수행하는 메소드와 변수의 묶음)로 정의해서 서로 상호작용할 수 있도록 프로그래밍해나가는 것을 의미합니다. 각 객체는 메시지를 받을 수 있고, 데이터를 처리할 수도 있으며, 또 다른 객체에게 메시지를 전달할 수도 있습니다. 자바스크립트는 prototype을 기반으로 객체지향 프로그래밍을 해나갈 수 있습니다. 객체지향을 사용하면 중복되는 관련 객체를 재사용할 수 있어 중복을 어느 정도 줄일 수 있고, 관련 있는 객체들의 역할 분담을 좀 더 확실하게 할 수 있어 가독성이 높아지고 생산성과 유지보수 및 확장성이 높아집니다.생성자 함수와 인스턴스 생성 자바스크립트는 new 연산자를 통해 인스턴스를 생성하면 생성자 함수라고 합니다.생성자 함수는 클래스이자 생성자의 역할을 합니다. 생성자 함수와 porototype 기능을 모두 빌려 쓸 수 있는 객체입니다. 일반 함수와 생성자 함수를 구분해서 작성하기 위해 생성자 함수는 첫 글자를 대문자로 표기해줍니다. this를 사용합니다.function Person(name, age) { // 생성자 함수 this.name = name; this.age = age;}const jennie = new Person(&#39;jennie&#39;, 20); // 인스턴스const lisa = new Person(&#39;lisa&#39;, 20); // 인스턴스Prototype &amp;amp; [[Prototype]] 일반 함수와 생성자 함수와 상관없이 모든 함수(모든 함수는 객체)에는 prototype, constructor이라는 속성을 가지고 있습니다.(javascript에서 Object.prototype은 최상위 객체입니다.) 생성자 함수가 있을 때 new 연산자로 인스턴스를 생성하면 그 인스턴스에는 constuctor의 porototype의 프로퍼티 내용이 [[Prototype]]라고 하는 프로퍼티로 참조를 전달하게 됩니다. constructor.prototype과 instance[[Prototype]]은 같은 객체를 바라봅니다. [[Prototype]]은 접근이 가능한 것이 아니라 정보를 보여주기만 합니다.아래 화면과 같이 생성자 함수 Array를 개발자 도구에서 출력하면 porototype을 확인할 수 있습니다.이 porototype은 인스턴스 배열 arr의 [[Prototype]]과 연결됩니다. Array.prototype.constructor 와 arr.constructor 는 같은 배열의 생성자 함수를 가리킵니다. 생성자 함수의 prototype 프로퍼티에 있는 것을 [[Prototype]]을 통해 메소드를 사용할 수 있습니다. 인스턴스가 생성장 함수의 prototype에 접근하려면?Object.getPrototypeOf(instance)메소드 상속 아래 소스와 같이 프로토타입으로 메소드를 만들면 인스턴스들을 계속 만들어도 한번 만들어 놓은 프로토타입 메소드를 참조하면서 메모리 사용 효율을 끌어올릴 수 있는 장점이 있습니다.function Person(name, age) { this.name = name; this.age = age;}Person.prototype.setAge = function () { this.age += 1;};Person.prototype.getAge = function () { return this.age;};const jennie = new Person(&quot;jennie&quot;, 20);const lisa = new Person(&quot;lisa&quot;, 20);jennie.setAge(); // 21lisa.setAge(); // 21Prototype Chaning javascript에서 Object.prototype은 최상위 객체입니다. 배열이든 함수이든 Object.prototype과 프로토타입 체인으로 연결되어있습니다. Array도 Object의 상속을 받은 객체입니다. 때문에 Array도 Object의 prototype을 자신의 것처럼 사용할 수 있습니다.예를 들어,  [1, 2, 3]. method() 어떠한 메소드를 호출한다고 했을 때 먼저 인스턴스 자기 자신에서 먼저 찾고, 없다면 프로토타입을 체이닝을 타고 올라가 Array.prototype에서 메소드를 찾습니다. 해당 메소드가 있다면 메소드를 호출하고 끝내지만 만약 없다면, 한 단계 더 타고 올라가 Object.prototype에서 메소드를 찾고 해당 메소드가 있다면 메소드를 호출하고 없다면 Object는 최상위 객체이기 때문에 더 이상 올라갈 수 있는 체인이 없어 에러를 던지게 됩니다. 이렇게 타고 타고 올라가는 것을 프로토타입 체이닝이라고 합니다." }, { "title": "Javascript This", "url": "/posts/Javascript-This/", "categories": "Javascript", "tags": "javascript this", "date": "2022-11-21 00:00:00 +0900", "snippet": "자바스크립트에서 this는 실행 컨텍스트가 생성될 때 바인딩됩니다.즉, 함수가 호출될 때 this가 결정된다는 것입니다.아래 소스를 보면 어떻게 호출했느냐에 따라 this가 달라집니다.var student = { name: &quot;jennie&quot;, myName: function () { console.log(this.name); },};var myName = student.myName;myName(); // undefinedstudent.myName(); // jennie결과가 다른 이유는 myName()은 함수로 호출을 했고 student.myName()는 메소드로 호출했기 때문입니다.함수 호출 시모든 객체는 전역 객체의 프로퍼티입니다 전역 컨텍스트를 실행하는 주체는 전역 객체입니다. 모든 전역변수와 함수는 window 객체의 프로퍼티입니다. a와 window.a는 같고, foo();와 window.foo();와 같습니다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주됩니다.var a = &quot;Hello?&quot;;function foo() { console.log(&quot;world&quot;);}console.log(a); // Hello?console.log(window.a); // Hello?foo(); // worldwindow.foo(); // world일반 함수로 호출 시 this는 전역 객체를 가리킵니다아래 소스와 같이 일반 함수로 호출 시 this는 전역 객체를 가리킵니다.(브라우저에서는 window, 노드에서는 global)function foo() { function a() { console.log(this); // window } a(); // 일반 함수 호출}foo();var obj = { foo: function () { function f() { console.log(this); //window } f(); // 일반 함수 호출 },};obj.foo();use strict 모드일 때 오류를 보안해 주기 위해 엄격한 코드 실행을 해주는 환경&quot;use strict&quot;;var a = &quot;hello&quot;;function foo() { console.log(this.a); // this === undefined}foo(); 위 소스와 같이 use strict 모드가 적용되면 this === undefined로 설정됩니다. 만약 window를 가리키고 싶다면 아래와 같이 window를 명시합니다.&quot;use strict&quot;;var a = &quot;hello&quot;;function foo() { console.log(window.a); // hello}foo();Method 호출 시 메소드는 객체(인스턴스)와 관련된 동작을 의미합니다. 객체의 소속인 메소드의 this는 그 객체를 가리킵니다.var a = &quot;hello&quot;;var obj = { a: &quot;world&quot;, foo: function foo() { console.log(this.a); // world },};obj.foo(); // this는 obj를 가리킵니다.var a = { name: &quot;a&quot;, b: { name: &quot;b&quot;, foo: function () { console.log(this.name); // b }, },};a.b.foo(); // this는 a.b를 가리킵니다.메소드 내부 함수에서의 this 우회법var name = &quot;lisa&quot;;var obj = { name: &quot;jennie&quot;, getName: function () { console.log(this.name); // jennie (this === obj) function getThisName() { console.log(this.name); // lisa (this === window) } getThisName(); },};obj.getName();위 소스에서 getThisName의 this를 obj를 가리키도록(this === obj) 하려면 어떻게 해야 할까?변수에 this를 담는 방법 변수에 this를 담아 obj를 가리킬 수 있습니다.var name = &quot;lisa&quot;;var obj = { name: &quot;jennie&quot;, getName: function () { var newThis = this; function getThisName() { console.log(newThis.name); // jennie } getThisName(); },};obj.getName();화살표 함수 사용하기 화살표 함수에는 this가 없습니다. 스코프 체이닝 상의 this에 접근하여 obj를 가리킵니다.var name = &quot;lisa&quot;;var obj = { name: &quot;jennie&quot;, getName: function () { console.log(this.name); // jennie var getThisName = () =&amp;gt; { console.log(this.name); // jennie }; getThisName(); },};obj.getName();콜백 호출 시 - 명시적 this 바인딩callfunc.call(thisArg[, arg1[, arg2[, ...]]])var callback = function () { console.log(this); // window};var obj = { foo: function (cb) { cb(); },};obj.foo(callback);this를 obj를 가리키려고 한다면 아래와 같이 call을 사용하여 this를 명시적으로 지정할 수 있습니다.var callback = function () { console.log(this); // obj};var obj = { foo: function (cb) { cb.call(this); },};obj.foo(callback);call의 경우 arg 인자의 수가 정해져 있지 않습니다.var string = &quot;hello&quot;;function foo(a, b, c, d, e) { console.log(this.str); console.log(arguments);}var obj = { str: &quot;world&quot;,};foo.call(obj, 1, 2, 3, 4, 5);applyfunc.apply(thisArg, [argsArray])var string = &quot;hello&quot;;function foo(a, b, c, d, e) { console.log(this.str); console.log(arguments);}var obj = { str: &quot;world&quot;,};foo.apply(obj, [1, 2, 3, 4, 5]); 인자를 2개만 받습니다. 첫 번째는 this값을 넣어주고, 두 번째는 인자는 배열로 들어갑니다.bindthis값을 설정해 놓은 함수를 실행하지 않고 함수 자체를 반환해줍니다.func.bind(thisArg[, arg1[, arg2[, ...]]])var callback = function () { console.log(this); // obj};var obj = { foo: function (cb) { cb.call(this); },};setTimeout(callback, 1000);위와 같이 setTimeout에 콜백을 담아 넘기면 this는 전역 객체를 가리킵니다.this를 obj를 가리키려고 한다면 아래와 같이 bind를 사용하여 this를 명시적으로 지정할 수 있습니다.var callback = function () { console.log(this); // obj};var obj = { foo: function (cb) { cb.call(this); },};setTimeout(callback.bind(obj), 1000);생성자 함수 호출 시new 연산자를 썼을 때 생성자 함수의 내용을 바탕으로 인스턴트 객체를 만드는 명령으로 새로 만들 인스턴스 객체 자체가 this가 됩니다. 생성자(varructor)는 객체를 만드는 역할을 하는 함수(class)입니다.. 생성자 함수는 첫 글자를 대문자로 표기합니다. 함수 앞에 new를 붙이면 리턴 값은 객체(instance)가 된다.function Foo() { console.log(this); // {}}new Foo(); // 객체 instancenew 키워드를 사용하여 함수를 호출하면 함수 안의 this의 값은 빈 객체가 할당되어서 함수가 실행됩니다.function Foo() { this.name = &quot;sara&quot;;}var a = new Foo();위 소스는 아래와 같이 this를 return 해주는 것과 같습니다.function Foo() { this.name = &quot;sara&quot;; /* { name: &#39;sara&#39;; } return this; */}var a = new Foo();let name = &quot;sara&quot;;let age = 30;function Person(name, age) { this.name = name; this.age = age;}var lisa = Person(&quot;lisa&quot;, 20);console.log(window.name, window.age); // lisa, 20위 소스처럼 new 연산자를 사용하지 않고 호출하게 되면 this는 전역 객체를 가리키게 되고 전역 객체의 name, age의 값은 재할당 하게 됩니다.let name = &quot;sara&quot;;let age = 30;function Person(name, age) { this.name = name; this.age = age;}var lisa = new Person(&quot;lisa&quot;, 20);console.log(window.name, window.age); // sara, 30console.log(lisa); new 연산자를 사용할 경우 객체가 새로 만들어지면서 그 객체 안에 name, age 프로퍼티가 생성되면서 lisa라는 변수에 담기게 됩니다." }, { "title": "실행 컨텍스트", "url": "/posts/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/", "categories": "Javascript", "tags": "실행컨텍스트, 자바스크립트 실행컨텍스트, javascript 실행컨텍스트", "date": "2022-11-13 00:00:00 +0900", "snippet": "실행 컨텍스트란? 자바스크립트가 실행되는 환경으로 함수를 실행할 때 필요한 조건, 환경정보를 제공하는 객체입니다.실행 컨텍스트를 이해하면 Scope, hoisting, closure, this와 같은 중요한 동작을 이해할 수 있습니다.실행 컨텍스트의 내부var a = 1;function outer() { console.log(a); // 실행 순서(1): 1출력 function inner() { // var a; --&amp;gt; undefined (호이스팅) console.log(a); // 실행 순서(2): 1출력 var a = 3; } inner(); console.log(a); // 실행 순서(3): 1출력}outer();console.log(a); // 실행 순서(4): 1출력아래는 위 코드를 실행 컨텍스트 내부로 추상화한 것입니다. Variable Environment와 Lexical Environment는 모두 식별자 정보를 수집합니다.차이점은 Varable Environment는 변수들 값의 변화가 생기면 실시간으로 반영되지 않고Lexical Environment는 식별자의 바인딩된 값을 기록하고 추적합니다실행 컨텍스트의 구성 중 Lexcal Environment에 살펴보면 아래와 같습니다.Lexical EnvironmentEnvironment Record (환경 레코드)실행 컨텍스트를 구성하는 환경 정보들을 모아 사전처럼 구성한 객체로 변수의 값들이 변화가 생기면 실시간으로 반영됩니다.생성 단계 선언문만 실행해서 환경 레코드에 기록합니다. 실행 컨텍스트가 생성되는 순간 가장 먼저 하는 일입니다.실행 단계 선언문 외 나머지 코드를 순차적으로 실행하여 환경 레코드에 기록된 식별자를 참조하거나 업데이트합니다. 전체 코드를 스캔하면서 선언할 게 있다면 먼저 선언해 두는 과정에서 실행 콘텍스트 안에 있는 환경 레코드에 기록해둡니다.이렇게 스캔하고 준비하는 단계를 생성 단계라고 하고 코드를 순차적으로 실행하면서환경 레코드에 기록된 정보를 참조하거나 업데이트하는 과정을 실행단계라고 합니다.Hoisting(호이스팅) 이해하기 선언문이 최상단으로 끌어올려진 듯한 현상입니다.(함수 표현식 동일하게 동작) let 또는 const로 선언했을 때, 선언 이전에 식별자를 참조할 수 없습니다. (Reference Error 일시적 사각지대) 아래 소스에서 함수 b와 같이 함수 선언문 방식으로 함수를 선언하는 경우에는 선언과 동시에 함수가 생성되어 끌어올려지기 때문에 선언 전에도 함수를 사용할 수 있습니다.// var a; --&amp;gt; undefinedconsole.log(a); // undefined/*function b() { console.log(&quot;b 함수 호출&quot;);}*/console.log(b()); // b 함수 호출// var c; --&amp;gt; undefinedconsole.log(c()); // Reference Error(undefined를 함수 처럼 호출한 것)var a = 3; // a = 3;console.log(a); // 3function b() { console.log(&quot;b 함수 호출&quot;);}var c = function () { console.log(&quot;c 함수 호출&quot;);};/*c = function () { console.log(&quot;c 함수 호출&quot;);};*/Outer Environment (Scope Chain) 외부 환경을 참조합니다. 바깥 Lexical Environment를 가리킵니다.var a = 1;function outer() { console.log(a); // 실행 순서(1): 1출력 function inner() { // var a; --&amp;gt; undefined (호이스팅) console.log(a); // 실행 순서(2): 1출력 var a = 3; } inner(); console.log(a); // 실행 순서(3): 1출력}outer();console.log(a); // 실행 순서(4): 1출력위 소스에서 console.log(a) 출력 과정을 콜스택과 함께 실행 컨텍스트를 설명하면 아래와 같습니다. 전역 컨텍스트가 생성되고 전역 공간을 한 줄 한 줄 실행합니다. 변수a와 함수 ourter를 선언하여 환경 레코드에 식별자를 바인딩합니다. (생성 단계) 함수 outer()를 호출하면 outer 함수의 실행 콘텍스트가 생성되어 콜스택에 쌓입니다. outer 함수에 inner 함수를 선언하여 환경 레코드에 식별자를 바인딩합니다. (생성 단계) outer 함수에 첫 줄에 console.log(a)가 실행되고 console.log 컨텍스트가 생성되어 콜스택에 쌓입니다. a를 찾아 찾아 올라가게(scope chain) 되고 1을 출력하고 console.log(a)컨텍스트는 사라지고 콜스택에서 빠져나옵니다. inner 함수가 호출되면 inner함수의 콘텍스트가 생성됩니다. inner 함수의 변수 a를 선언하여 식별자를 바인딩합니다. (생성 단계) inner 함수 내의 console.log(a)를 실행하면 console.log 실행 컨텍스트가 생성되어 콜스택에 쌓입니다. a는 hoisting 되어 undefined를 출력하고 console.log 실행 컨텍스트가 사라지고 콜스택에서 빠져나옵니다. inner 실행 컨텍스트가 사라지고 콜스택을 빠져나옵니다. outer함수의 마지막 줄인 console.log(a)가 실행되면 실행 컨텍스트가 생성되고 콜스택에 쌓입니다. a를 찾아 찾아 올라가(scope chain) 1을 출력한 후 console.log실행 컨텍스트가 사라지고 콜스택을 빠져나옵니다. outer 실행 컨텍스트가 사라지고 콜스택을 빠져나옵니다. 전역 컨텍스트의 마지막 줄인 console.log(a)가 실행되고 console.log 실행 컨텍스트가 생성되어 콜스택에 쌓입니다. console.log(a)의 1을 출력하면 console.log 실행 컨텍스트가 사라지고 콜스택을 빠져나옵니다. 컨텍스트도 종료가 됩니다. " }, { "title": "JS 데이터 타입(원시형 vs 참조형)", "url": "/posts/JS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-%EC%B0%B8%EC%A1%B0%ED%98%95-vs-%EC%9B%90%EC%8B%9C%ED%98%95/", "categories": "Javascript", "tags": "jsavascript 데이터 타입, 원시형, 참조형", "date": "2022-11-01 00:00:00 +0900", "snippet": " 자바스크립트에서 데이터 타입에는 아래와 같이 원시형과 참조형으로 나뉩니다. 자바스크립트 메모리 구조는 스택 메모리(정적 할당, 변수, 원시형 데이터 저장)와 힙 메모리(동적 할당, 참조형 데이터, 저장) 영역으로 나뉘어 있습니다.원시형(Primitive Type)객체를 제외한 모든 타입은 원시 값(불변 값)으로 값을 그대로 할당합니다. boolen null undefined number string symbol (ES6)아래와 같이 newName에 name을 할당하고 다시 &quot;jennie&quot;로 값을 재할당 한 후 name과 newName을 확인해 보면 데이터의 불변성(newName의 값을 재할당 해도 name의 값이 변하지 않음)을 확인할 수 있습니다.let name = &quot;sara&quot;;let newName = name;newName = &quot;jennie&quot;;console.log(name, newName); // sara, jennie이렇게 값이 변하지 않는 것 이 당연해 보이지만 그 이유는 아래와 같습니다.1. 메모리(1002)에 식별자 name을 저장합니다. … 1002 …   이름: name 값:    2. &quot;sara&quot;를 비어있는 다른 메모리(5003) 공간에 저장합니다. … 1002 …   이름: name 값:    … 5003 ..   “sara”   3. name과 newName 은 같은 string 타입의 &quot;sara&quot;를 저장한 메모리(5003) 주소를 참조하게 됩니다. … 1002 1003   이름: name 값: @5003 이름: newName 값: @5003 … 5003 ..   “sara”   4. newName에 &quot;jennie&quot;를 재할당 하면 string 타입의 &quot;jennie&quot;를 메모리(5004)에 저장하고 newName은 해당 주소(5004)를 참조합니다. … 1002 1003   이름: name 값: @5003 이름: newName 값: @5004 … 5003 5004   “sara” “jennie” 이와 같이 원시형에서는 데이터를 변경할 때 가리키는 주소를 직접 바꿔놓게 되기 때문에 불변성을 유지할 수 있습니다.참조형(Reference Type)객체 타입의 데이터로 값이 저장된 주소 값을 참조합니다. Object Array Function RegExp(정규 표현식) Set (ES6) Map (ES6)같은 주소 값을 참조한다는 것은 얕은 복사(shallow copy)를 확인하면 이해할 수 있습니다.아래와 같이 obj2.b 값을 재할당했을 때 obj.b의 값도 변경된 경우를 얕은 복사라고 합니다.const obj = { a: 1, b: 2,};const obj2 = obj;obj2.b = 3;console.log(obj, obj2); // {a: 1, b: 3}, {a: 1, b: 3}이렇게 obj의 값이 같이 변경된 이유는 아래와 같습니다.1. obj를 메모리(1002)에 선언합니다. … 1002 1003   이름: obj 값: @5002 이름: obj2 값: @1002 2. 메모리 구조 공간 하나에는 값이 하나씩밖에 못 들어가기 때문에 메모리(7103~) 공간을 확보합니다. 5002  5003 5004 5005 @7103~ 1 2 3 확보한 공간 메모리(7103 ~)에 프로퍼티(5003, 5004)를 하나씩 할당합니다. 7103 7104 … 이름: a 값: @5003 이름: b 값: @5004 -&amp;gt; @5005(3으로 재할당)   3. obj2에 obj를 할당했으므로 obj는 1002를 참조합니다.4. obj2.b 에 3으로 재할당(5005) 하는 경우 obj와 obj2는 같은 메모리(5002) 주소 값을 참조합니다.이와 같이 얕은 복사는 obj2는 새로운 객체를 만든 것이 아니라 obj와 같은 주소 값을 참조하므로 obj2.b를 변경했지만 obj도 같이 변하는 것을 확인할 수 있습니다.참고 - 코어 자바스크립트" }, { "title": "바벨(Babel) 설정하기", "url": "/posts/%EB%B0%94%EB%B2%A8-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "바벨, babel", "date": "2022-10-31 00:00:00 +0900", "snippet": "바벨(Babel)을 왜 사용할까? 바벨은  트랜스파일러로 최신 자바스크립트(타입스크립트, JSX 포함)가 모든 브라우저에서 동작하도록 변환해 줍니다. 실행이 안되는 구버전 웹브라우저를 대응하기 위해 배포할 때에 예전 방식의 자바스크립트로 변환해서 배포하려고 사용합니다.바벨 빌드 과정 파싱(Parsing): 코드를 분해하는 과정 변환(Transforming): ES6 -&amp;gt; ES5 변환하는 과정 출력(Printing): 변경된 결과물을 출력하는 과정플러그인바벨 플러그인은 바벨이 어떤 코드를 어떻게 변환할 지에 대한 규칙을 나타냅니다. 필요한 경우 플러그인을 직접 만든 커스텀 플러그인을 사용하거나 잘 만들어진 플러그인을 가져다 사용합니다.ex) .babelrc{ &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;, &quot;transform-class-properties&quot;]}프리셋필요한 플러그인을 일일이 설정하기 번거로운데 여러 가지 플러그인을 세트로 모아 놓은 것을 프리셋이라고 합니다.바벨이 제공하는 대표적인 프리셋  @babel/preset-env preset-env는 ES5를 변환할 때 사용합니다.  @babel/preset-react @babel/preset-typescript @babel/preset-flow preset-flow, preset-react, preset-typescript는 flow, 리액트, 타입스크립트를 변환하기 위한 프리셋입니다. 아래 소스와 같이 타깃 브라우저를 설정할 수 있습니다.ex) .babelrc{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;chrome&quot;: &quot;72&quot; } } ] ]}폴리필폴리필은 구형 브라우저에서는 지원하지 않는 기능(Promise 같은 객체들은 ES5에 존재하지 않는 기능)을 제공합니다. 런타임에 등록되지 않은 메서드나 기능을 폴리필을 추가해서 해결해야 합니다.예를 들어 Object.FromEntries를 caniuse에서 확인해 보면 chrome 72 버전에서는 지원이 되지 않습니다.chrome 73 버전 이상부터는 문제가 되지 않지만 chrome 72 버전에서는 Object.FromEnties는 function이 아니라는 에러 문구와 함께 애플리케이션은 제대로 작동하지 않을 것입니다. 이와 같은 경우 폴리필을 추가하여 이슈를 해결할 수 있습니다.useBuiltIns 옵션 usage 실제 필요한 폴리필을 자동으로 추가해 줍니다. entry 타깃 환경에 필요한 특정 모듈만 가져오기로 바꿉니다. 참고ex) .babelrc{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;chrome&quot;: &quot;72&quot; // 모바일웹 안드로이드 디바이스 지원(갤럭시 S8(v.8)) }, &quot;useBuiltIns&quot;: &quot;usage&quot;, // 폴리필 사용 방식 (entry) &quot;corejs&quot;: 3, // 폴리필 버전 &quot;shippedProposals&quot;: true } ] ]}import &#39;core-js/stable&#39;;import &#39;regenerator-runtime/runtime&#39;;참고" }, { "title": "React Query", "url": "/posts/React-Query/", "categories": "Frontend", "tags": "react query", "date": "2022-10-11 00:00:00 +0900", "snippet": "React-Query란?React 애플리케이션에서 데이터를 가져오기 위한 라이브러리입니다.데이터 Fetching, 캐싱, 동기화, 서버 쪽 데이터 업데이트 비동기 과정에서 데이터를 관리하기 편하게 할 수 있습니다.사용하는 이유아래와 같이 React는 데이터를 가져올 때 useEffect를 사용하고 useState를 사용하여 상태를 유지합니다.import React, { useEffect, useState } from &quot;react&quot;;import axios from &quot;axios&quot;;const App = function () { const [sate, setState] = useState([]); const load = async () =&amp;gt; { const { data } = await axios.get(&quot;http://localhost:4000/api&quot;); setState(data); }; useEffect(() =&amp;gt; { load(); }, []); return &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;;};만약 앱 전체에 데이터가 필요한 경우 상태 관리 라이브러리(Redux, Recoil 등)를 사용하게 됩니다.기존에 다양한 상태 관리 라이브러리 들은 비동기적 작업보다는 동기적인 클라이언트 데이터를 관리하기에 더 적합하기 때문에react-query를 사용함으로 서버와 클라이언트 데이터를 분리합니다.  client state: 앱 메모리에 유지되고 액세스 하거나 업데이트하는 것 (동기적) server state: 업데이트에 필요한 API(비동기)장점 캐싱 처리가 더 간단해집니다. 프로젝트 구조가 기존보다 단순해집니다. 때문에 유지 보수하고 새로운 기능을 추가하기 쉽습니다. 직접 만들어서 사용했던 기타 기능들을 옵션으로 지원합니다. 같은 데이터를 여러 번 요청할 경우 한 번만 요청하고 옵션에 따라 중복 호출 허용 시간 조절 가능합니다. 백그라운드에서 stale 한 상태 데이터를 refetch 합니다. 서버 쪽 데이터를 가비지 컬렉션을 이용하여 자동으로 메모리 관리를 해줍니다. get을 한 데이터에 대해 update를 하면 자동으로 get을 다시 수행합니다.예를 들어, 게시판의 글의 목록을 가져오고 게시판의 글을 생성하면 게시판 글을 get 하는 api를 자동으로 실행합니다.React-Query 사용하기Installnpm i react-queryreact-query를 사용할 수 있도록 세팅합니다.import { BrowserRouter as Router, Route, Routes } from &quot;react-router-dom&quot;;import { HomePage } from &quot;./components/Home.page&quot;;import { QueryClient, QueryClientProvider } from &quot;react-query&quot;;import { ReactQueryDevtools } from &quot;react-query/devtools&quot;;const queryClient = new QueryClient();function App() { return ( &amp;lt;QueryClientProvider client={queryClient}&amp;gt; &amp;lt;Router&amp;gt; &amp;lt;Routes&amp;gt; &amp;lt;Route path=&quot;/&quot; element={&amp;lt;HomePage /&amp;gt;} /&amp;gt; &amp;lt;/Routes&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/Router&amp;gt; &amp;lt;ReactQueryDevtools initialIsOpen={false} position={&#39;bottom-right&#39;}/&amp;gt; &amp;lt;/QueryClientProvider&amp;gt; );}export default App;import { useQuery } from &quot;react-query&quot;;import axios from &quot;axios&quot;;const Page = () =&amp;gt; { const fetch = () =&amp;gt; { return axios.get(&quot;http://localhost:4000/api&quot;); }; const { isLoading, data, isError, error } = useQuery( &quot;key&quot;, fetch, ); if (isLoading) { return &amp;lt;h2&amp;gt;Loading...&amp;lt;/h2&amp;gt;; } if (isError) { return &amp;lt;h2&amp;gt;{error.message}&amp;lt;/h2&amp;gt;; } return ( &amp;lt;&amp;gt; &amp;lt;h2&amp;gt;Hello world&amp;lt;/h2&amp;gt; {data?.data.map((el) =&amp;gt; { return &amp;lt;div key={el.id}&amp;gt;{el.name}&amp;lt;/div&amp;gt;; })} &amp;lt;/&amp;gt; );}; 첫 번째 파라미터로 쿼리에 사용할 유니크한 키값을 넣어줍니다. 두 번째 파라미터로 쿼리가 데이터를 요청하는 데 사용할 비동기 함수(api)를 인자로 넣습니다. 데이터 또는 오류를 반환해야하고 데이터는 undefined가 될 수 없습니다.변화가 있을 때 refetchimport React, { useState } from &quot;react&quot;;import { useQuery } from &quot;react-query&quot;;import axios from &quot;axios&quot;;const App = function () { const [id, setId] = useState(1); const load = async () =&amp;gt; { const resp = await axios.get(`http://localhost:4000/${id}`); return resp; }; const { data, status } = useQuery([&quot;key&quot;, id], load); ...}; 첫 번째 파라미터를 배열을 넣습니다. 0번째 인덱스에 유니크한 키값을 넣고, 1번째 인덱스부터 변화가 생길 때마다 refetch 되어야 하는 구성 요소들을 나열합니다.옵션 설정세 번째 인자로 옵션을 설정할 수 있습니다.const { data, status, isLoading, isFetching } = useQuery( [&quot;key&quot;, currentPage], load, { refetchOnWindowFocus: false, statleTime: 10000, cashTime: 20000, }); refetchOnwindowFocus (default: true) boolean ‘always’ ((query: Query) =&amp;gt; boolean “always”) 브라우저가 포커스에 되었을 때 refetch 여부를 boolean으로 설정할 수 있습니다. true로 설정하면 데이터가 오래된 경우 쿼리가 창 포커스에서 다시 가져옵니다. false로 설정하면 쿼리가 창 포커스에서 다시 가져오지 않습니다. “always”로 설정하면 쿼리는 항상 창 포커스에서 다시 가져옵니다. 함수를 설정하면 값을 계산하는 쿼리와 함께 함수가 실행됩니다. refetchOnMount (default: true) boolean “always” ((query: Query) =&amp;gt; boolean “always”) 새로 마운트가 되었을 때 refetch 여부를 설정할 수 있습니다. true로 설정하면 데이터가 오래된 경우 쿼리가 마운트 시 다시 가져옵니다. false로 설정하면 쿼리가 마운트 시 다시 가져오지 않습니다. “always”로 설정하면 하면 쿼리가 마운트 시 항상 다시 가져옵니다. 함수를 설정하면 값을 계산하는 쿼리와 함께 함수가 실행됩니다. refetchOnReconnect (default: true) boolean “always” ((query: Query) =&amp;gt; boolean “always”) 네트워크가 끊어졌다가 다시 연결될 때 refetch 여부 설정할 수 있습니다. true로 설정하면 데이터가 오래된 경우 쿼리가 다시 연결할 때 다시 가져옵니다. false로 설정하면 네트워크를 다시 연결할 때 쿼리를 다시 가져오지 않습니다. “always”로 설정하면 쿼리는 네트워크를 다시 연결할 때 항상 다시 가져옵니다. 함수를 설정하면 값을 계산하는 쿼리와 함께 함수가 실행됩니다. refetchInterval number false ((data: TData undefined, query: Query) =&amp;gt; number false) 데이터를 지정한 시간에 따라 refetch를 시켜주는 옵션입니다. refetchIntervalInBackground boolean  true로 설정하면 background에 있어도 refetchInterval에 의해 refetch 됩니다. staleTime (default: 0) number Infinity 데이터가 fresh 한 상태에서 오래된 상태로 변경되는 시간을 설정합니다. fresh 상태일 때는 쿼리 인스턴스가 새롭게 mount 되어도 네트워크 fetch가 일어나지 않습니다. 데이터가 한번 fetch 되고 나서 staleTime이 지나지 않았다면 mount 되어도 fetch가 일어나지 않습니다. Infinity로 설정하면 데이터가 오래된 것으로 간주되지 않습니다. cashTime (default: 5분) 데이터가 비활성화 상태일 때 캐싱된 상태로 남아있는 시간입니다. 쿼리 인스턴스가 unmount 되면 데이터는 비활성화 상태로 변경되며, 캐시는 cacheTime만큼 유지됩니다. cacheTime이 지나면 가비지 콜렉터로 수집됩니다. cacheTime이 지나기 전에 쿼리 인스턴스가 다시 마운트 되면, 데이터를 fetch 하는 동안 캐시 데이터를 보여줍니다. cacheTime은 staleTime과 관계없이, casheTime이 지나면  inactive 된 시점을 기준으로 캐시 데이터 삭제를 결정합니다. isFetching 데이터가 fetch 될 때 true or 캐싱 데이터가 있어서 백그라운드에서 fetch 될 때 true 반환합니다. isLoading 캐싱된 데이터가 없고 fetch 중일 때 true, 아닐 때 false 반환합니다. useQuery(&quot;names&quot;, fetch, { onSuccess: (data) =&amp;gt; { console.log(data); }, onError, select: (data) =&amp;gt; { const names = data.data.map((el) =&amp;gt; el.name); return names; },});  onSuccess 이 함수는 쿼리가 새 데이터를 성공적으로 가져올 때마다 실행됩니다. onError 이 함수는 쿼리에 오류가 발생하고 오류가 전달되면 실행됩니다. select (data: TData) =&amp;gt; unknown  비동기 호출에서 반환되는 데이터를 재구성할 수 있습니다. useQuery( &quot;key&quot;, fetchSuperHeroes, { initialData: () =&amp;gt; { return { data: [ { id: 2, name: &quot;test&quot;, }, ], }; }, } ); initialData TData () =&amp;gt; TData 초기값을 설정할 수 있습니다. (쿼리가 아직 생성되거나 캐시되지 않은 경우) 캐시에 유지됩니다. const { refetch } = useQuery(&quot;key&quot;, fetch, { enabled: false,}); enabled boolean값으로 쿼리를  자동으로 실행 되지 않도록 설정할 수 있습니다. refetch 쿼리를 수동으로 다시 가져오는 기능입니다. const { isLoading, isError, error, data, isFetching } = useQuery( [&quot;colors&quot;, pageNumber], () =&amp;gt; fetchColors(pageNumber), { keepPreviousData: true, }); keepPreviousData boolean 새 데이터를 가져올 때 이전 데이터가 유지되고 새 데이터가 도착하면 이전 데이터와 스왑 되어 새 데이터를 표시합니다. isPreviousData로 현재의 제공된 데이터의 상태를 알 수 있습니다. useInfinitedQuery무한 스크롤 또는 더보기와 같은 목록을 로드할 때 유용합니다.const { isLoading, isError, error, data, fetchNextPage, hasNextPage, isFetching, isFetchingNextPage,} = useInfiniteQuery([&quot;colors&quot;], fetchColors, { getNextPageParam: (_lastPage, pages) =&amp;gt; { if (pages.length &amp;lt; 4) { return pages.length + 1; } else { return undefined; } },}); getNextPageParam 다음 페이지에 호출할 pageParam 값을 반환할 수 있습니다. getNextPageParams undefined일 때 hasNextPage는 false를 반환하고 그 외 다른 값을 반환할 때,hasNextPage는 true를 반환합니다.  hasNextPage 다음 페이지가 있는지 여부를 boolean으로 확인할 수 있습니다. fetchNextPage 더보기 버튼 클릭 or 무한 스크롤 시 호출할 때 사용됩니다. isFetchingNextPage isFetchingNextPage와 isFetchPreviousPage로 백그라운드 새로 고침 상태와 추가 로딩 상태를 구분할 수 있습니다. 비동기 여러 개를 실행할 경우 useQueries useQueriy를 Promise.all처럼 사용할 수 있는 것이 useQueries입니다.useQueries([ { queryKey: [&quot;id&quot;, id], queryFn: () =&amp;gt; loadIDData(), }, { queryKey: [&quot;gender&quot;, gender], queryFn: () =&amp;gt; loadGenderData(), },]);QueryCache쿼리에 대해 성공 및 실패 전처리를 할 수 있습니다.const queryClient = new QueryClient({ queryCache: new QueryCache({ onError: (error, query) =&amp;gt; { console.log(error, query); }, onSuccess: (data) =&amp;gt; { console.log(data); }, }),});useMutation데이터를 생성, 업데이트 또는 삭제할 때 사용하기 유용합니다.// Access the clientconst queryClient = useQueryClient();// Queriesconst query = useQuery([&quot;todos&quot;], getTodos);// Mutationsconst mutation = useMutation(postTodo, { onSuccess: () =&amp;gt; { // Invalidate and refetch queryClient.invalidateQueries([&quot;todos&quot;]); },}); mutate는 useMutation을 이용해 작성한 내용들이 실행될 수 있도록 도와주는 trigger 역할을 합니다.React-Query 공식 홈페이지" }, { "title": "CRA(React Create App) 웹팩 설정하기", "url": "/posts/CRA-%EC%9B%B9%ED%8C%A9-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "CRA 웹팩 설정", "date": "2022-09-20 00:00:00 +0900", "snippet": "CRA(Create React App)는 프로젝트 초기 세팅 및 복잡한 과정을 해결해줍니다.예를 들어, 아래와 같은 명령어로 타입스크립트 환경의 리액트 프로젝트를 만들 수 있습니다.yarn create react-app my-app --template typescript이렇게 프로젝트를 만들게 되면 바벨이나 웹팩 같은 종속된 라이브러리나 설정이 보이지 않습니다.숨겨진 종속성 및 설정을 확인하고 수정하기 위해서는 eject 명령어를 사용해야 하는데 이 방법은 단방향 프로세스로 한번 실행하면 다시 원상 태로 복구할 수 없고 이후 직접 유지보수를 해야 합니다.기존 설정을 유지하면서 새로 추가하고 싶은 설정만 추가하는 방법이 방법은 기존 설정들을 신경 쓰지 않고 원하는 설정만 적용할 수 있기 때문에 관리 및 유지 보수하기 좋습니다.CRA로 프로젝트를 설치한 후 다음과 같은 패키지들 설치합니다.Installcustomize-cra(eject 명령어를 사용하지 않고 webpack.config와 같은 설정 파일을 수정할 수 있는 라이브러리입니다.)yarn add customize-cra react-app-rewired --dev 아래와 같이 config-overrides.js (package.json과 같은 레벨) 파일을 생성합니다.const { override, addWebpackAlias } = require(&#39;customize-cra&#39;);const path = require(&#39;path&#39;);module.exports = override( addWebpackAlias({ &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;), })); package.json의 react-scripts -&amp;gt; react-app-rewired로 변경합니다. ... &quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, ...yarn start를 통해 실행해 보면 정상적으로 동작하는 것을 확인할 수 있습니다." }, { "title": "HTTP와 HTTPS", "url": "/posts/HTTP%EC%99%80-HTTPS/", "categories": "CS", "tags": "http, https", "date": "2022-08-01 00:00:00 +0900", "snippet": "HTTP 란? http는 Hyper Text Transfer Protocol의 약자로 웹에서 요청과 응답의 형태로 정보를 주고받을 수 있는 프로토콜입니다. TCP 기반으로 작동하며 비연결성, 비상태성 특징을 가집니다. 이로 인해 많은 실제 동시 접속을 최소화하여 더 많은 유저의 요청 처리를 할 수 있습니다.  비연결성, 비상태성 특징 때문에 사용자의 이전 상태(로그인 유무 등)를 알 수 없어 이를 해결하기 위해쿠키, 세션, JWT 등이 도입되었습니다. 클라이언트에서 서버로 request message 보내고 서버에게 response message를 받는 형태입니다. request message: startline(method, path, http version), header, body로 구성 response message: statusline(status code, status message, http version), header, body로 구성 HTTP status code HTTP status code는 클라이언트가 보낸 HTTP의 서버의 응답 코드로, 상태 코드를 통해 요청의 성광과 실패를 판단할 수 있습니다.  100부터 ~ 500번대 까지 총 5가지의 클래스로 구분되어 있으며 요청에 대한 상태를 알려줍니다. 웹 개발 시 상황에 맞는 응답 코드를 response에 담아서 클라이언트에 넘겨주며 이를 토대로 클라이언트는 알맞은 대응을 할 수 있습니다. status code 1xx: 요청을 완료했고 작업을 계속합니다. 2xx: 요청을 성공 적으로 처리하였습니다. 200: 요청을 성공 (ex: 조회 성공) 201: 데이터 생성을 성공적으로 처리 (ex: 회원가입 성공, 게시물 작성 성공) 3xx: 요청에 추가적인 작업이 필요합니다. 4xx: 클라이언트 요청에 문제가 있습니다 400: 데이터 형식이 올바르지 않을 때 401: 인증이 되지 않은 상태에서 인증이 필요한 리소스에 접근했을 때 403: 인증은 되었지만 권한이 없는 리소스에 접근했을 때 404: 존재하지 않는 route에 요청했을 때 5xx: 서버에 문제가 있습니다.HTTPS 란?보안 소켓 계층 SSL/TSL을 사용한 HTTP를 HTTPS라고 합니다.HTTP가 정보를 주고받을 때 텍스트 형태 그대로 주고받기 때문에 민감한 정보를 담고 있을 경우 이 정보를 탈취한다면 민감한 정보를 원본 그대로 볼 수 있는 단점이 있습니다.하지만 보안 소켓 계층 SSL/TLS을 사용한 HTTPS를 사용할 경우 주고받는 http message의 body 정보들이 암호화되어 중간에 누군가 탈취한다 하더라도 데이터를 쉽게 알아볼 수 없습니다. 또 인증기관(CA)으로부터 검증된 사이트만 https를 사용할 수 있으므로 안전한 사이트를 이용할 수 있기 때문에 HTTPS를 사용하는 하여 보안성을 확보해야 합니다.SSL/TLS TLS는 SSL의 업그레이드 버전으로 일반적으로 두 단어를 동일한 의미로 사용합니다. SSL은 웹 서버와 웹 브라우저간의 보안을 위해 만든 프로토콜입니다. 대칭키 방식과 공개키(비대칭키) 방식을 혼합해서 사용합니다. 대칭키: 양쪽에서 암호화를 같은 키로 암호화와 복호화를 하는 방법입니다. 대칭키: 데이터 암호화, 복호화 시 사용합니다.  대칭키 하나로 암호화와 복호화를 할 수 있기 때문에 대칭키를 탈취당할 경우 문제가 됩니다. 공개키(비대칭키): 양쪽에서 서로 다른 키로 암호화와 복호화를 하는 방법입니다. 공개키: 데이터 암호화 시 사용합니다. 개인키: 데이터 복호화 시 사용합니다. 공개키로 암호화한 데이터는 개인키로만 복호화가 가능하기 때문에 공개키를 가져가도 안전합니다. 공개키 방식이 좋은데도 혼합해서 사용하는 이유는 무엇일까? 공개키 방식만이 대칭키 방식보다 암호화 연산이 많이 소비되어 비용이 많이 듭니다. 때문에  공개키를 활용한 대칭키로 클라이언트와 서버는 통신할 수 있도록 혼합하여 사용합니다. SSL 인증서 / CASSL 인증서 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장합니다. SSL 통신에 사용할 공개키를 클라이언트에게 제공합니다.CA(Certificate Authority)  인증서 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 합니다. 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있습니다.아래의 설명을 위 그림으로 나타낸 것입니다. 서버는 사이트 정보와 자신의 공개키를 인증기관에 전달합니다. 인증기관에서는 전달받은 데이터를 검증 후 자신의 개인키로 서명한 사이트 인증서를 서버에 전달 합합니다. 인증기관은 클라이언트에 인정기관 공개키를 전달합니다. 이 공개키는 브라우저에 자동으로 내장됩니다. 클라이언트가 서버에 접속 요청을 시도하면 서버는 사이트 인증서를 전송합니다. 클라이언트는 브라우저에 내장되어있는 인증기관 공개키로 사이트 인증서를 복호화하여 검증하고 서버 공개키를 얻습니다. 클라이언트는 자신의 대칭키를  서버 공개키로 암호화하여 암호화한 대칭키를 서버에 전송합니다. 서버는 전달받은 대칭키를 자신의 개인키로 복호화하여 전달받은 대칭키를 알아냅니다.이렇게 공개키를 활용한 대칭키로 클라이언트와 서버는 통신하게 됩니다." }, { "title": "React에서 setInterval 사용하기", "url": "/posts/React%EC%97%90%EC%84%9C-setInterval-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "react setInterval", "date": "2022-07-28 00:00:00 +0900", "snippet": "업데이트 함수 setState를 활용하여 구현import { useEffect, useState } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const [count, setCount] = useState(0); useEffect(() =&amp;gt; { const timer = setInterval(() =&amp;gt; { setCount((prev) =&amp;gt; prev + 1); }, 1000); return () =&amp;gt; { clearInterval(timer); }; }, []); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{count}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; );}export default App;위 소스는 1초마다 카운트를 1 씩 올려주는 코드입니다. useEffect 두 번째 인자에 빈 배열을 넣어 componenetDidMount와 같이 timer 함수를 한 번만 세팅합니다. setInnerval로 timer를 세팅하고 컴포넌트가 사라질 때 clearInterval로 timer를 정리합니다. useEffect 두 번째 인자에 빈 배열을 넣을 경우 렌더링 후 한 번만 실행되기 때문에setState의 업데이트 함수(setCount(prev =&amp;gt; prev + 1))를 활용하여 구현합니다.  업데이트 함수 setCount(prev =&amp;gt; prev + 1) 사용한 경우 prev는 항상 최신 상태 값을 가져오는 것을 보장할 수 있습니다. setState(count + 1)을 사용할 경우 초기 count 값만을 가져오기 때문에 count가 1에서 멈춰 버립니다. 문제점업데이트 함수인 setState를 사용해서 상태 변경에서는 count 업데이트를 할 수 있지만 props가 변경된 경우에는타이머 함수가 실행되지 않습니다.  useEffect 두 번째 인자에 빈 배열을 넣어 timer함수를 한 번만 세팅했기 때문입니다. useRef를 활용한 타이머 구현import { useEffect, useRef, useState } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const timerRef = useRef(); const [count, setCount] = useState(0); const handleCount = () =&amp;gt; { setCount(count + 1); }; const handleRestart = () =&amp;gt; { if (!timerRef.current) { timerRef.current = setInterval(handleCount, 1000); } }; const handleStop = () =&amp;gt; { if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; } }; useEffect(() =&amp;gt; { timerRef.current = setInterval(handleCount, 1000); return () =&amp;gt; { clearInterval(timerRef.current); }; }); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{count}&amp;lt;/h1&amp;gt; &amp;lt;button onClick={handleRestart}&amp;gt;restart&amp;lt;/button&amp;gt; &amp;lt;button onClick={handleStop}&amp;gt;stop&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}export default App;timerRef.current에 timer를 저장하여 타이머를 정지하는 stop버튼과 다시 시작하는 restart 버튼을 추가하여 구현하였습니다. useRef는 리렌더링을 방지하고 useRef의 timerRef 객체는 컴포넌트의 전 생애주기 동안 유지되어 useRef로 관리하는 값은 state 값이 변경되어도 ref의 값을 유지합니다. count 상태 변경만의 리렌더링을 나타내고 restart 버튼 or stop 버튼을 클릭해도 리렌더링이 일어나지 않습니다." }, { "title": "React 18 업데이트 정리", "url": "/posts/React-18-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%A0%95%EB%A6%AC/", "categories": "Frontend", "tags": "react 18", "date": "2022-07-27 00:00:00 +0900", "snippet": "1. Automatic Batching 자동 배치란 여러 개의 state 업데이트를 하나로 묶어 render 함수를 호출(리렌더링 성능 개선)하는 것을 말합니다. 기존 17 버전에서도 이러한 배칭 처리는 되었지만 비동기 부분에서는 자동 배치 처리가 되지 않았습니다. 하지만 18 버전부터는 비동기에서도 자동 배치 처리를 지원합니다.import { useState } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const [number, setNumber] = useState(0); const [boolean, setBoolean] = useState(true); const onClick = () =&amp;gt; { setNumber((prev) =&amp;gt; prev + 1); setBoolean(!boolean); }; console.log(&quot;렌더링&quot;); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{number}&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{boolean.toString()}&amp;lt;/h2&amp;gt; &amp;lt;button onClick={onClick}&amp;gt;버튼&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}export default App;위 소스는 아래 화면을 나타냅니다.위 화면은 초기에 화면이 출력될 때 렌더링이 콘솔에 찍힙니다.위와 같이 버튼을 클릭하면 onClick함수가 호출되고 setNumber와 setBoolean의 상태 변경을 하나로 묶어 리렌더링을 한 번만 수행하는 것을 확인할 수 있습니다.여기까지는 버전 17과 같습니다.비동기에서 자동배치 기존 17 버전은 비동기에서 자동 배치를 지원하지 않았지만 18 버전에서는 비동기에서도 자동 배치를 지원합니다.아래는 비동기에서 상태를 업데이트하는 소스코드입니다.import { useState } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const [number, setNumber] = useState(0); const [boolean, setBoolean] = useState(true); const onClick = () =&amp;gt; { setTimeout(() =&amp;gt; { setNumber((prev) =&amp;gt; prev + 1); setBoolean(!boolean); }, 2000); }; console.log(&quot;렌더링&quot;); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{number}&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{boolean.toString()}&amp;lt;/h2&amp;gt; &amp;lt;button onClick={onClick}&amp;gt;버튼&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}export default App;아래 화면과 같이 18 버전은 비동기에서도 자동 배치를 지원하는 것을 확인할 수 있습니다. 아래와 같이 하나는 동기적 상태 업데이트와 비동기 상태 업데이트를 진행할 경우는 어떻게 될까?import { useState } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const [number, setNumber] = useState(0); const [boolean, setBoolean] = useState(true); const onClick = () =&amp;gt; { setTimeout(() =&amp;gt; { setNumber((prev) =&amp;gt; prev + 1); }, 2000); setBoolean(!boolean); }; console.log(&quot;렌더링&quot;); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{number}&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{boolean.toString()}&amp;lt;/h2&amp;gt; &amp;lt;button onClick={onClick}&amp;gt;버튼&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}export default App;아래와 같이 비동기에서 상태 업데이트와 일반 상태 업데이트를 따로 리렌더링 합니다.setTimeout 안에서 상태 업데이트를 하나로 그룹화하고 onClick 함수의 setTimeout 밖에서의 상태 업데이트를 그룹화합니다.만약 자동 배치 처리를 원하지 않는다면? react-dom의 flushSync을 사용할 수 있습니다.아래와 같이 flushSync를 활용하여 상태 업데이트하면 자동 배칭 처리가 되지 않습니다.import { useState } from &quot;react&quot;;import { flushSync } from &quot;react-dom&quot;;import &quot;./App.css&quot;;function App() { const [number, setNumber] = useState(0); const [boolean, setBoolean] = useState(true); const onClick = () =&amp;gt; { flushSync(() =&amp;gt; { setNumber((prev) =&amp;gt; prev + 1); }); flushSync(() =&amp;gt; { setBoolean(!boolean); }); }; console.log(&quot;렌더링&quot;); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;{number}&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;{boolean.toString()}&amp;lt;/h2&amp;gt; &amp;lt;button onClick={onClick}&amp;gt;버튼&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}export default App;아래 화면과 같이 자동 배치가 적용되지 않은 것을 확인할 수 있습니다.2. useTranstion 각 상태 업데이트에 대한 우선순위를 설정할 수 있는 hook입니다. isPending: boolean 은 state변경 직후에도 리렌더링 하지 않고 UI를 잠시 유지하는 상태입니다. startTransition은 클릭이나 키 입력에 의해 우선순위가 높은 상태 업데이트가 발생할 경우 내부에 선언한 상태 업데이트는 중단되고 클릭이나 키 입력이 끝난 후 이후에 해당 상태 업데이트가 발생합니다. 언제 사용할까?한번 렌더링 연산이 시작되면 멈출 수가 없는 블로킹 렌더링 문제를 개선할 수 있습니다.예를 들어, 사용자가 입력창에 검색어를 입력할 때 입력과 함께 검색 결과를 보여주는 경우 사용자가 입력을 하고 있음에도 렌더링 연산이 시작되면 멈출 수 없어 입력창이 버벅거리는 현상이 나타나 사용자 경험이 좋지 않게 됩니다.아래와 같이 긴급 업데이트와 전환 업데이트가 있다면 전환 업데이트 때문에 긴급 업데이트가 방해되어 블로킹 렌더링 문제가 발생합니다. 긴급 업데이트: 입력, 클릭, 누르기와 같은 사용자가 직접적인 상호 작용 전환 업데이트: UI 전환이전 버전에서는 검색 결과 등에서 사용했던 Debounce, Throttle 기능을 사용하여 일정 시간을 기다리는 것으로 문제를 해결하였습니다. Debounce와 Throttle의 경우 일정 시간을 기다리는 것으로 문제를 잠시 미루는 방식이었다면 startTranstion을 사용해서 화면을 그리는 우선순위를 낮추고 사용자 입력에 우선순위를 높여 사용자 경험을 향상할 수 있습니다. 즉 긴급 업데이트를 전환 업데이트보다 우선순위를 높게 설정하여 문제를 해결하는 것입니다.Debounce 입력이 다 끝나면 일정 시간 뒤 화면 업데이트를 할 수 있습니다. 입력하는 동안 화면을 그리지 않게 합니다. throttle  일정한 주기로 화면을 그리게 한다 사용자가 일정 주기 동안 입력을 하지 않을 경우에도 기다려야 한다.startTransition 화면 업데이트 중에도 사용자 입력을 받을 수 있습니다. 렌더링 하는 와중에도 우선순위가 높은 일이 생기면 그것을 먼저 처리할 수 있습니다. timeountMS 설정하면 해당 시간 동안 렌더링을 기다다가 결과를 갖지 못하면 강제로 렌더링 됩니다.아래는 useTrasition을 구현한 소스입니다.import { useState, useTransition } from &quot;react&quot;;import &quot;./App.css&quot;;function App() { const [isPending, startTransition] = useTransition({ timeoutMs: 5000 }); const [keyword, setKeyword] = useState(&quot;&quot;); const [list, setList] = useState([]); const onChange = (e) =&amp;gt; { setKeyword(e.target.value); // 긴급 업데이트 startTransition(() =&amp;gt; { // 전환 업데이트 setList([...Array(e.target.value.length * 1000)]); }); }; return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;input type={&quot;text&quot;} value={keyword} onChange={onChange} /&amp;gt; &amp;lt;div&amp;gt; {isPending &amp;amp;&amp;amp; &amp;lt;p&amp;gt;...isPending&amp;lt;/p&amp;gt;} {list.map((el, i) =&amp;gt; { return ( &amp;lt;div className=&quot;box&quot; key={i} /&amp;gt; ); })} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );}export default App;3. Suspense and SSR서버사이드 렌더링의 경우 서버에 데이터가 모두 채워진 html 리소스를 받아 렌더링하고 자바스크립트 코드를 로딩 후 Hydration 단계로 넘어갑니다. 자바스크립트를 로딩하기 전에는 Hydration(자바스크립트 연결) 단계로 넘어갈 수 없고 사용자가 앱과 상호 작용하기 위해서는 Hydration 단계까지 완료되어야 합니다. 이와 같은 문제를 Suspense와 lazy를 사용하여 렌더링 성능을 향상할 수 있습니다.lazy &amp;amp; Suspense모든 데이터가 fetch 되어야 렌더 할 수 있지만 Suspense에 컴포넌트를 감싸면 해당 컴포넌트의 데이터가 준비될 때까지 fallback으로 아직 처리되지 않았을 때의 컴포넌트(예: loading spinner)를 화면에 표시하고 데이터가 fetch 된 다른 컴포넌트 부분부터 보여줄 수 있습니다. lazy &amp;amp; Suspense를 활용해 구현할 경우 해당 컴포넌트가 아직 렌더링 되지 않았어도 상관없이 다른 컴포넌트들은 hydration을 시작할 수 있게 되었습니다.import React, { Suspense } from &#39;react&#39;;const OtherComponent = React.lazy(() =&amp;gt; import(&#39;./OtherComponent&#39;));function MyComponent() { return ( &amp;lt;div&amp;gt; &amp;lt;Suspense fallback={&amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt;}&amp;gt; &amp;lt;OtherComponent /&amp;gt; &amp;lt;/Suspense&amp;gt; &amp;lt;/div&amp;gt; );}" }, { "title": "Process란?", "url": "/posts/Process-%EB%9E%80/", "categories": "CS", "tags": "Process", "date": "2022-07-08 00:00:00 +0900", "snippet": "실행 중인 프로그램을 뜻하며, 실행파일(program)이 memory에 적재되어 CPU에 의해 실행(연산)되는 것을 말한다.예를 들어, 코드를 작성한 후 저장을 하면 하드디스크에 저장하는 것을 프로그램이라 부른다. CPU는 하드디스크에 저장된 프로그램을 읽을 수 없다. RAM memory에 올라와있는 프로그램만 읽을 수 있다. 프로그램을 실행시키기 위해 RAM memory에 적재를 하고 CPU를 할당받는다.여기까지의 과정을 가지면 프로세스가 된다.RAM Memory 적재memory는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다. program이 CPU에서 실행되려면 해당 내용이 memory에 적재된 상태여야 한다.메모리 역역에는 크게 stack, heep, data, code 영역으로 구분되어있으며, 각 process마다 독립적으로 할당을 받는다. 메모리 영역 설명 code 실행할 프로그램의 코드가 저장되는 역역이다.  data 프로그램의 전역 변수와 static변수가 저장되는 영역이다. heap 런타임 중에 메모리 할당이 되는 동적 메모리 할당 영역이다. stack 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 영역이다. CPU의 연산프로그램의 코드를 CPU가 실제로 연산을 해야만 프로그램이 실행된다. CPU 내부에 PC register가 code 영역의 다음 명령어의 주소 값을 순차적으로 가리키게 되고 해당 명령어를 CPU가 연산하게 되면서 process가 실행된다." }, { "title": "브라우저 렌더링 과정 이해하기", "url": "/posts/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/", "categories": "CS", "tags": "브라우저 렌더링 과정", "date": "2022-07-01 00:00:00 +0900", "snippet": "웹 브라우저에서 주소창에 google.com을 입력했을 때 어떤 일이 일어날까? 면접 질문으로 많이 나오는 질문이다.크게 두 가지 관점으로 나누어 볼 수 있다.하나는, 네트워크 관점이고 또 하나는 브라우저가 웹 페이지를 그리는 관점이다.우선 네트워크 관점부터 알아보면 아래 그림과 같은 흐름을 갖는다.웹 동작 방식 사용자가 주소창에 url을 입력하면 HTTP request message를 생성한다. IP 주소를 알아야 전송할 수 있으므로 DNS를 통해 serverIP주소를 알아낸다. 브라우저는 server IP와 3 way handshake 과정을 갖는다.(TCP 연결을 하기 위한 과정)이 과정은 TCP/IP 프로토콜을 통신하기 전 정확한 정보 전송을 위해 상태방 컴퓨터와 세션을 연결하는 과정이다. 클라이언트가 서버에게 접속을 요청하는 SYN 패킷을 보낸다. 서버는 요청을 수락하는 ACK 패킷을 포함하여 클라이언트에게 보낸다 (SYN + ACK) 클라이언트가 이것을 수신한 후 받은 ACK 패킷을 서버에게 발송하면 연결이 이루어지고 데이터를 주고받을 수 있게 된다. 브라우저는 server IP에게 자료를 요청하는 HTTP request message를 만들고 TCP/IP 패킷을 생성한 이후 서버로 전송 요청을 한다. server에서 HTTP request를 unpacking 해서 server process로 보낸 후 request에 대한 HTTP response message를 만든 후TCP/IP 패킷을 생성한 이후 전달받은 방식대로 client로 전송한다. HTTP response message가 도착하고 데이터를 주고받았다면 TCP 종료하기 위한 4 way handshake 과정을 갖는다. client TCP에서 FIN 세그먼트를 server에게 보낸다. server는 FIN 세그먼트를 받았다는 응답에 대한 ACK세그먼트를 client로 보낸다.(아직 server process가 종료되지 않을 수 있다.) server process 종료한 뒤 server TCP에서 FIN세그먼트를 client TCP에 보낸다. FIN 세그먼트를 받은 client는 server에 ACK 세그먼트를 보내고 TCP 연결이 종료가 된다. 아래는 리소스를 받은 후 화면이 그려지는 구조이다브라우저 렌더링 방식 브라우저는 서버에서부터 받은 데이터를 parsing(웹 표준화 기구인 W3C명세에 따라 HTML과 CSS를 해석)한다. 브라우저 렌더링 엔진은 HTML을 해석(parsing) 하여 DOM Tree를 생성한다. 이때 렌더링 엔진이 스타일 태그를 만나면 HTML 해석을 중지하고 CSS를 parsing 하여 CSSOM Tree를 생성한다. CSS 해석을 마치면 이전에 중지한 HTML 해석이 중단된 지점부터 다시 해석한다. 스크립트 태그를 만나면 다시 해석을 중지하고 자바스크립트 엔진에게 제어 권한을 넘긴다. 자바스크립트 엔진은 코드를 해석하여 추상 구문 트리인 AST를 만들고 실행한다. 중단되었던 parsing을 이어서 진행한 후 작업을 완료한다. 브라우저는 DOM Tree와 CSSOM Tree 합쳐 RenderTree를 생성한다.(RenderTree를 생성하는 것까지 constuction이라고 한다.) 렌더링 엔진은 RenderTree의 노드들을 화면의 올바른 위치에 그리는 레이아웃(Layout) 작업을 시작한다. UI Backend 가 RenderTree의 노드를 돌면서 UI를 그린다. (paint) 그다음 노드들을 레이어 순서대로 구성하는 composition 단계 (z-index가 낮은 요소를 먼저 놓고 그다음에 높은 요소를 놓는 것)를 거친다. 위 과정을 거쳐 최종적으로 화면에 출력된다." }, { "title": "TDD(테스트 주도 개발)", "url": "/posts/TDD-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/", "categories": "Frontend", "tags": "TDD, 테스트 주도 개발", "date": "2022-06-30 00:00:00 +0900", "snippet": "TDD(Test Driven Development)란?TDD란 Test Driven Development라는 약자로 테스트 주도 개발을 의미한다.테스트는 서비스의 품질 확인 및 버그를 찾는 데 사용할 수 있다. 내가 작성한 코드가 예상하는 대로 동작하는지 검증하고 확인하는 것이다.테스트 주도 개발은 무엇일까? 테스트 주도 개발이란 테스트를 통해서 개발이 이끌어지는 개발 방법론이다.예를 들어, 아래와 같이 진행한다.1. 테스트를 먼저 작성한다.(간단하게 어떤 결과가 예측되어야 하는지 기술하는 단계)2. 작성한 테스트의 기능만큼의 개발을 진행한다.3. 코드를 리팩토링 한다.여기서 테스트를 작성하지 않은 부분은 구현하지 않는 것이다.테스트 주도 개발은 위와 같은 사이클을 반복한다.1. 먼저 테스트를 작성하고 개발이 구현되어있지 않기 때문에 테스트 코드를 돌리면 실패를 하게 된다.(🔴)2. 작성한 테스트 코드가 정상적으로 수행이 되도록 실제 코드를 작업한다.(🟢)3. 작성한 코드를 표준에 맞도록 리팩토링 단계이다.(🟡)테스트 주도 개발이 필요한 이유프로젝트가 점점 커질 경우 어떤 기능을 추가할 때 해당 기능이 기존 코드들에 어떤 영향을 미칠지 모른다는 점이 가장 큰 문제이다. 하지만 테스트 주도 개발을 하는 경우 테스트 코드를 먼저 작성하기 때문에 무엇을 해야 하는지 명확하게 정의함으로써 불필요한 설계를 피할 수 있고 완성도 높은 설계로 이어진다. 따라서 예외상황이 생길 확률이 낮아지고 추가적인 요구 사항이 있어도 손쉽게 요구사항을 반영할 수 있게 된다.TDD cycle을 반복하는 경우 처음부터 두 개의 코드를 짜야하고, 중간중간 테스트를 하면서 고쳐나가기 때문에 생산성이 저하되는 단점이 있다. 하지만 결국 시간이 지나고 프로젝트가 커질수록 개발 비용을 줄이고 높은 퀄리티의 제품을 생산할 수 있게 된다." }, { "title": "정규 표현식 정리", "url": "/posts/%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC/", "categories": "정규 표현식", "tags": "정규표현식, 정규 표현식", "date": "2022-06-09 00:00:00 +0900", "snippet": " 표현식 의미 ex ex 설명 ^ 텍스트의 시작 ^hello hello 텍스트로 시작되는 것을 의미 $ 텍스트의 마지막 hello$ 마지막 텍스트 hello를 의미 \\$ $의 경우 문자열 끝을 찾을 때 사용 되기 때문에$를 일반 문자열로 바꿔주기 위해 \\(역슬래시)를 사용 ^$ 텍스트 $로 시작되는 것을 의미 . 모든 문자를 의미. 마침표가(ex:...) 여러 개일 경우 개수만큼의 단위 문자열의 의미 … 3개 단위의 문자열 모두를 의미 [] 대괄호 하나를 하나의 문자열로 보고 대괄호 안에 있는 해당되는 문자열 모두를 의미 [ab] a 또는 b가 해당되는 문자열 모두를 의미 []. 대괄호 뒤에. 이 붙을 경우 대괄호 안에 해당되는 문자열과 뒤에 오는 문자열 하나를 의미 [ab]. a 또는 b가 해당되는 문자열과 문자열 하나를 의미 [-] ~에서 ~까지 [a-z2-6] 소문자 a에서부터 z까지, 숫자 2 ~ 6까지를 의미 [^] 대괄호 안에서 ^는 부정을 뜻한다. [^CD45] C or D or 4 or 5가 해당되지 않는 것을 의미 () 괄호 안에 이스케이프로 나누어진 문자열 한 덩어리를 의미 (mon\\|sun) day monday와 sunday를 의미 * 없을 수도 있고 여러 개 있을 수도 있다는 의미 (0~) a*b b앞에 a가 있을 수도 있고 여러 개의 a가 있을 수도 있다는 의미 + 하나 이상을 의미 a+b b앞에 a가 하나 이상 있는 것을 의미 ? 없거나 하나인 것의 의미 a? b b앞에 a가 없거나 하나만 있는 것을 의미 {} 중괄호 안에 들어간 숫자 개수만큼을 의미 . {5} 어떤 문자건 다섯 글자를 의미 {,} 중괄호 안에 콤마가 들어간 경우 ~이상을 의미 [els]{1,3}, [a-z]{3,} e or l or s 가 1 이상 3 이하, a부터 z까지 3 이상 *? *(수량자) 뒤에? 가 붙을 경우 *(수량자)의 최소 단위 0개를 의미 r.*? r문자열 뒤에 아무것도 없는 것을 의미 +? +(수량자) 뒤에 ?가 붙을 경우 +(수량자)의 최소 단위 1개를 의미 r.+? r 그리고 r문자열 뒤에 한 개의 문자열을 의미 \\w w는 word(알파벳, 숫자, _)를 의미 \\w === [a-zA-Z0-9_] 알바 벳, 숫자, _ 문자열을 의미 \\W \\w반대 의미인 word(알파벳, 숫자, _)가 아닌 것을 의미 \\W 알바 벳, 숫자, _ 문자열이 아닌 것을 의미 \\d 0부터 9까지의 수 \\d===[0-9] 0부터 9까지의 수 \\D \\d의 반대 숫자가 아닌 것을 의미 \\D \\d의 반대 숫자가 아닌 것을 의미 \\b\\w \\b의 위치가 앞에 있다면 단어가 시작되는 것을 의미 \\b가 뒤에 있다면 단어 끝부분을 의미 \\b\\w \\b의 위치가 앞에 있다면 단어가 시작되는 것을 의미 \\b가 뒤에 있다면 단어 끝부분을 의미 \\B \\b의 반대의 의미 \\b\\w \\b의 반대의 의미 \\A 문장의 시작점을 의미 \\A... 문장 전체 시작점에서 문자 3개를 의미 \\Z 문장의 시작점을 의미 ...\\Z 문장 전체 끝점에서 문자 3개를 의미 ?= ?=뒤에 오는 문자를 제외되는 것을 의미 \\w+(?=X) word(알파벳, 숫자, _)가 하나 이상인 문자열 뒤에 X가 있는 문자열을 X를 제외한 것을 의미 g global을 표현하며 대상 문자열내에 모든 패턴을 검색하는 것을 의미     i ignore case를 표현하며 대상 문자열에 대해서 대/소문자를 식별하지 않는 것을 의미     m multi line을 표현하며 대상 문자열이 다중 라인의 문자열인 경우에도 검색하는 것을 의미     예제아래는 정규식을 사용한 예제이다. /[^a-z0-9-_.]/gi 소문자 알파벳, 숫자, -, _, .이 아닌 것 /[.]{2,}/gi .이 2개 이상 " }, { "title": "React에 Redux Toolkit 사용하기", "url": "/posts/React%EC%97%90-Redux-Toolkit-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "react @reduxjs/toolkit, redux toolkit, @reduxjs/toolkit", "date": "2022-05-12 00:00:00 +0900", "snippet": "Redux Toolkit이란?Redux Toolkit은 redux에서 지원하는 개발 도구이다. 스토어 설정, 리듀서, 데이터 가져오기 등 Redux 로직을 작성하기 위해 권장되는 접근 방식이다. Redux Toolkit의 configureStore는 설정을 단순화하고 일반적인 버그를 방지하는 데 도움이 되는 향상된 createStore 버전이다.사용하는 이유Redux Toolkit은 아래와 같은 Redux의 문제점을 보안해 준다. 복잡한 Redux 저장소 구성을 어느 정도 해결해 줄 수 있다. 리덕스를 사용하다 보면 코드 양이 점점 많아지게 되는데 Redux Toolkit을 사용하면 자체적으로 immer를 내부적으로 도입해서 사용하고 있어 코드의 양이 줄어든다.(boilerplate) Redux에서 주요 기능들을 사용하기 위해 많은 패키지를 추가해야 하는데 자주 사용하는 기능들을 모아두어(예: redux-thunk, redux devtool 등 디폴트로 제공) 패키지 의존성을 줄여준다. (saga를 제외한 기능들은 거의 모두 제공된다.)사용 방법InstallRedux 툴킷에는 Redux 코어와 Redux 응용 프로그램(예: Redux Thunk 및 Reselect)을 구축하는 데 필수적이라고 생각하는 기타 주요 패키지가 포함되어 있다.npm install react-redux @reduxjs/toolkit 기존 Redux 사용 방식에서 아래와같이 변경한다.slice Slice는 CreateSlice를 통해 Action과 Reducer를 한 번에 정의할 수 있다. 슬라이스를 식별하기 위한 문자열 이름(name), 초기 상태 값(initialState), 상태 업데이트 방법(reducers)을 정의한다. name : 이름을 작성한다. initialState : 초깃값 세팅한다. reducers : 리듀서를 작성한다.(리듀서의 키값으로 액션 함수가 자동으로 생성된다.) src/services/store/slice/user.tsimport { createSlice } from &#39;@reduxjs/toolkit&#39;;export const initialState = { name: null, isLogin: false,};export const userSlice = createSlice({ name: &#39;user&#39;, initialState, reducers: { setUserName: (state, action) =&amp;gt; { state.name = action.payload; }, setUserLogin: (state, action) =&amp;gt; { state.isLogin = action.payload; }, },});export const { setUser, setUserLoading } = userSlice.actions;export default userSlice.reducer;configureStore슬라이스에서 리듀서 함수를 가져와서 스토어에 추가한다. combineReducers를 사용하여 사용할 리듀서를 사용할 키값과 함께 정의한다. configureStore를 실행하여 옵션과 함께 스토어를 생성한다. reducer에 combineReducers으로 생성한 rootReducer를 넣어준다. middleware 배열을 반환하는 옵션으로 미들웨어를 사용할 수 있다getDefaultMiddleware와 함께 툴킷에서 제공하는 기본 미들웨어를 호출하고 다른 미들웨어를 배열에 넣어 같이 사용할 수 있다. import { combineReducers, configureStore } from &#39;@reduxjs/toolkit&#39;;import logger from &#39;redux-logger&#39;;import userReducer from &#39;./slice/user&#39;;/* slice(Action과 Reducer를 한번에 정의한 것)*/const rootReducer = combineReducers({ userReducer: userReducer,});const store = configureStore({ reducer: rootReducer, middleware: (getDefaultMiddleware) =&amp;gt; getDefaultMiddleware().concat(logger), // preloadedState (서버 사이드 렌더링 전용)});export type RootState = ReturnType&amp;lt;typeof store.getState&amp;gt;;export default store;React에 Redux 스토어 전달하기저장소가 생성되면 애플리케이션(&amp;lt;App&amp;gt;) 주위에 React-Redux &amp;lt;Provider&amp;gt;를 감싸 생성된 저장소(store)를 전달한다.src/index.tsximport React from &#39;react&#39;;import ReactDOM from &#39;react-dom/client&#39;;import &#39;./index.css&#39;;import App from &#39;./App&#39;;import reportWebVitals from &#39;./reportWebVitals&#39;;import { Provider } from &#39;react-redux&#39;;import store from &#39;src/services/store&#39;;const root = ReactDOM.createRoot( document.getElementById(&#39;root&#39;) as HTMLElement);root.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;Provider store={store}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/Provider&amp;gt; &amp;lt;/React.StrictMode&amp;gt;);reportWebVitals();상태 변경 및 확인 react-redux에서 제공하는 useDispatch, useSelector로 상태 관리를 한다. 슬라이스에서 작성한 리듀서 액션을 사용해서 상태 값을 변경할 수 있다.import React from &#39;react&#39;;import { useSelector, useDispatch } from &#39;react-redux&#39;;import { RootState } from &#39;src/services/store&#39;;import { setUserName } from &#39;src/services/store/slice/user&#39;;const MainPage = () =&amp;gt; { const dispatch = useDispatch(); const user = useSelector((state: RootState) =&amp;gt; state.userReducer); console.log(user); return ( &amp;lt;div&amp;gt; &amp;lt;button onClick={()=&amp;gt; dispatch(setUserName(&#39;raeyoung&#39;))} &amp;gt; test &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );};export default MainPage;" }, { "title": "AWS CodePipeline을 이용한 배포", "url": "/posts/AWS-CodePipeline%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B0%B0%ED%8F%AC/", "categories": "Backend", "tags": "codepipeline, codepipeline node ts", "date": "2022-05-08 00:00:00 +0900", "snippet": "AWS CodePipeline으로 배포하기사이드 프로젝트를 CodePipeline을 이용해서 배포해 보았다.그 과정을 아래와 같이 정리해 보았다.CodePipeline으로 배포할 때 Source -&amp;gt; Deploy으로 바로 배포할 수 있지만 프로젝트에 Typescript를 사용했기 때문에 Source -&amp;gt; Build -&amp;gt; Deploy로 Build부분을 추가했다.배포 과정Elastic Beanstalk(EB)CodePipeline은 배포 과정을 자동으로 진행시켜주는 것이고 결국은 EC2 인스턴스에 배포가 되는 것으로 먼저 Elastic Beanstalk을 이용해서 인스턴스를 생성한다. aws 콘솔 로그인 후 Elastic Beanstalk에서 새 환경 생성을 클릭한다. 웹 서버 환경 체크 후 선택 클릭 배포할 애플리케이션 이름을 적는다. 애플리케이션 이름을 적으면 환경 이름이 자동으로 만들어진다.(환경 이름은 나중에 변경할 수 있다) 플랫폼에서 Node.js 선택한다. CodePipeline과 연결시킬 거기 때문에 우선 샘플 애플리케이션 선택 후 환경 생성을 한다. 아래와 같이 환경이 생성된다 위 밑줄 친 주소로 들어가면 샘플 애플리케이션으로 만들어진 아래와 같은 화면이 나온다. Elastic Beanstalk &amp;gt; 구성 &amp;gt; 편집 &amp;gt; 소프트웨어 &amp;gt; 편집을 클릭한다 .env파일에서 관리하던 환경 변수를 입력한다. CodePipeline 파이프라인을 생성한다. 파이프라인 이름을 작성하고 다음으로 넘어간다. GitHub(버전 1)을 선택 후 GitHub에 연결한다. GitHub에 연결이 되면 연결된 계정의 repository를 확인할 수 있다. 해당 repository를 선택하고 배포 브랜치를 선택한다. 빌드 스테이지를 추가한다. 빌드 공급자를 AWS CodeBuild를 선택한다. 가까운 리전을 선택한다 .env파일에서 관리하던 환경 변수를 입력한다. 배포 공급자에서 AWS Elastic Beanstalk을 선택하고 만들어 두었던 EB 애플리케이션을 선택하고 리전 및 환경 이름도 선택한다. 마지막 검토에서 확인 후 파이프라인 생성을 클릭한다. CodeBuild에서 Buildspec을 수정한다. 아래 편집 &amp;gt; Buildspac or빌드 세부 정보에서 수정할 수 있다. 편집 &amp;gt; Buildspac 빌드 세부 정보 아래와 같이 수정한다. ex)version: 0.2phases: build: commands: - npm install &amp;amp;&amp;amp; npm run buildartifacts: files: - &#39;**/*&#39; 프로젝트 마스터 브랜치에 Push를 하면 자동으로 변경을 감지하고 아래와 같은 진행과정을 거쳐 연결된 EB에 배포된다. 아래와 같이 편집 &amp;gt; 스테이시 편집 &amp;gt; 표시된 수정 아이콘을 클릭하면 환경 변수 및 여러 가지를 수정할 수 있다." }, { "title": "Node에서 S3 이미지 저장 및 삭제", "url": "/posts/Node%EC%97%90%EC%84%9C-S3-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%80%EC%9E%A5-%EB%B0%8F-%EC%82%AD%EC%A0%9C/", "categories": "Backend", "tags": "Node & S3", "date": "2022-05-07 00:00:00 +0900", "snippet": "Node &amp;amp; AWS S3Installnpm i aws-sdkAWS S3 버킷 생성 및 권한 설정에서 이미지 저장 및 삭제는 권한(IAM 정책)을 부여했다. IAM 정책 생성시 받은 액세스 키(AWS_ACCESS_KEY), 시크릿 키(AWS_SECRET_KEY)와 S3 리전(AWS_REGION)을 .env에서 관리한다. ex) import aws from &#39;aws-sdk&#39;; const { AWS_SECRET_KEY, AWS_ACCESS_KEY, AWS_REGION } = process.env; export const s3 = new aws.S3({ secretAccessKey: AWS_SECRET_KEY, accessKeyId: AWS_ACCESS_KEY, region: AWS_REGION, }); 이미지 저장이미지를 저장하는 방법 중에 아래와 두 가지 방법이 있다. Client에서 -&amp;gt; Backend로 이미지 파일을 전송 후 multer-s3를 이용해 s3에 이미지를 저장하는 방법. 위의 방법은 이미지 용량이 크거나 여러 장 저장할 때 서버에 부하를 줄 수도 있고 이미지를 모두 저장 후 url을 받아 사용자에게 보여준다면 시간이 너무 오래 걸려 사용자 경험이 좋지 못하다. Client or Backend에서 PresignedUrl을 이용해 S3에 이미지를 업로드하는 방법. S3에서 특정 파일(Object)에 PresignedUrl(제한된 시간 동안 접근할 수 있도록 권한이 부여된 서명된 url(업로드 url))로 S3에 이미지를 저장하는 방법. 클라이언트에서 바로 S3로 업로드가 가능하기 때문에, 보안을 위해 백엔드를 걸쳐 이미지를 업로드 시켰다. Node에서 PresignedUrl 생성 createPresignedPost를 이용해 PresignedUrl을 생성한다. key부분은 이미지 저장 경로 및 파일 이름 ex) image/&amp;lt;파일 이름&amp;gt;.&amp;lt;파일 확장자&amp;gt;import aws from &#39;aws-sdk&#39;;const { AWS_SECRET_KEY, AWS_ACCESS_KEY, AWS_REGION } = process.env;export const s3 = new aws.S3({ secretAccessKey: AWS_SECRET_KEY, accessKeyId: AWS_ACCESS_KEY, region: AWS_REGION,});export const getSignedUrl = ({ key }: { key: string }) =&amp;gt; { return new Promise((resolve, reject) =&amp;gt; { s3.createPresignedPost( { Bucket: &#39;&amp;lt;your bucket name&amp;gt;&#39;, Fields: { key, /* ex) image/&amp;lt;파일 이름&amp;gt;.&amp;lt;jpeg or png&amp;gt; */ }, Conditions: [ [&#39;content-length-range&#39;, 0, 50 * 1000 * 1000], [&#39;starts-with&#39;, &#39;$Content-Type&#39;, &#39;image/&#39;], ], }, (err, data) =&amp;gt; { if (err) reject(err); resolve(data); } ); });}; getSignedUrl이용해 생성된 PresignedUrl하고 imageKey(image/&amp;lt;파일 이름&amp;gt;.&amp;lt;jpeg or png&amp;gt;)를 응답한다.import express, { Request, Response, NextFunction } from &#39;express&#39;;import { s3, getSignedUrl } from &#39;../aws&#39;;const router = express.Router();/* ... */router.post(&#39;/presigned&#39;, async (req, res, next) =&amp;gt; { try { const { contentTypes } = req.body; if (!Array.isArray(contentTypes)) throw new Error(&#39;error&#39;); const presignedData = await Promise.all( contentTypes.map(async (conteType) =&amp;gt; { const imageKey = `${uuid()}.${mime.extension(conteType)}`; const key = `image/${imageKey}`; const presigned = await getSignedUrl({ key }); return { imageKey, presigned }; }) ); res.json(presignedData); } catch (err) { next(err); }});/* ... */export default router;Client(React)에서 PresignedUrl로 이미지 업로드 PresignedUrl 생성하고 응답받은 presignedData(imageKey(이미지 파일 이름), PresignedUrl(업로드 url))을 이용해 Client에서 S3에 이미지를 저장한다. const imgContentTypes = imgFile.map((el) =&amp;gt; el?.type); /* presignedUrl 생성하기 */ const res = await request.post(&#39;/upload/presigned&#39;, { contentTypes: imgContentTypes, }); /* s3 이미지 저장 */ await Promise.all( imgFile.map((file, index) =&amp;gt; { const { presigned } = res.data[index]; const formData = new FormData(); for (const key in presigned.fields) { formData.append(key, presigned.fields[key]); } file &amp;amp;&amp;amp; formData.append(&#39;Content-Type&#39;, file.type); file &amp;amp;&amp;amp; formData.append(&#39;file&#39;, file); return axios.post(presigned.url, formData); }) );이미지 삭제 Bucket부분에 해당 S3 버킷 이름을 적어준다. Key부분에 버킷에서 삭재할 이미지 경로와 파일 이름을 적어준다. 버킷에서 image폴더에 이미지 저장했기 때문에 Key부분에 &amp;lt;폴더&amp;gt;/&amp;lt;삭제할 이미지 파일 이름&amp;gt;.&amp;lt;파일 확장자&amp;gt;를 입력했다. ex) image/&amp;lt;img 파일 이름&amp;gt;.jpeg 콜백으로 에러와 데이터를 확인할 수 있다.ex)import express, { Request, Response, NextFunction } from &#39;express&#39;;import { s3, getSignedUrl } from &#39;../aws&#39;;const router = express.Router();/* ... */router.delete( &#39;/image/:id&#39;, async (req: Request, res: Response, next: NextFunction) =&amp;gt; { try { await s3.deleteObject( { Bucket: &#39;&amp;lt;your bucket name&amp;gt;&#39;, Key: `image/${req.params.id}`, }, (err, data) =&amp;gt; { if (err) throw err; } ); res.json({ message: &#39;success&#39;, }); } catch (err) { next(err); } });/* ... */export default router;" }, { "title": "AWS S3 생성 및 설정", "url": "/posts/AWS-S3-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%84%A4%EC%A0%95/", "categories": "Backend", "tags": "AWS S3", "date": "2022-05-06 00:00:00 +0900", "snippet": "사이드 프로젝트를 진행하면서 이미지 파일 관리를 위해 AWS S3를 사용하면서 알게 된 정보를 정리해 보았다.S3(Simple Storage Service)란?쉽게 말해 AWS(Amazon Web Service)에서 제공하는 클라우드 파일 저장소이다.S3를 사용하는 이유?서버(EC2, ELB)만을 사용해서 파일을 저장을 하게 되면 성능 및 여러 다른 문제들이 생길 수 있는데 S3 파일 저장소를 별도로 따로 두어 관리하면 서버에 의존하지 않아 나중에 확장, 축소를 하기도 쉽고 DB 관리하는 것에도 속도를 유지하는 상태에서 저장소가 무제한이다.S3는 AWS에서 스스로 서버를 증설하고 성능을 관리하고 보안 및 안전성 등 비용 측면에서도 장점이 많다. 아래와 같은 그림으로 이미지를 관리하게 된다. AWS S3 버킷 생성버킷은 S3에 저장되는 데이터 컨테이너다. aws 콘솔 로그인 후 검색창에 s3를 검색한다. 버킷 만들기를 클릭한다. 버킷 이름을 적고 리전은 서울을 선택한다. 프로젝트에서 외부에 공개할 이미지이기 때문에 모든 퍼블릭 액세스 차단 체크박스를 풀어준다. (만약 공개되면 안 되는 파일이라면 체크!!) 이렇게 버킷을 생성하고 버킷에 들어오면 업로드를 통해 일반 구글 클라우드처럼 파일을 저장할 수 있다. 모든 퍼블릭 액세스 차단이 비활성화이지만 이미지를 업로드 후 url을 확인이면 조회가 되지 않는다. AWS S3 버킷 정책 이를 해결하기 위해 버킷 정책 편집을 클릭한다 정책 생성기 클릭 이미지 조회만 퍼블릭으로 설정할 거기 때문에 GetObject만 선택한다. 버킷 정책 편집에 ARN을 복사한다. 버킷(ARN)에 images 폴더에 모든 파일만 퍼블릭으로 설정한다. 위에 복사한 &amp;lt;YOUR ARN&amp;gt;을 붙여 넣고 /images/*를 추가한다. ex)&amp;lt;YOUR ARN&amp;gt;/images/* 입력 -Add Statement, Generate Policy를 클릭한다 아래와 같은 화면이 나오는데 전체를 복사한다. 복사한 json 문서를 아까 버킷 정책 편집 부분에 붙여넣기 후 저장한다. 버킷에 폴더 만들기로 images폴더를 만들면 버킷/images 폴더 안에 업로드된 파일들은 퍼블릭으로 조회할 수 있다. 이미지 저장 또는 삭제는 백엔드를 거쳐서 진행되기 때문에 실수를 방지하기 위해 파일 저장 및 삭제를 할 때 권한을 추가로 설정한다.AWS IAM 정책 사용자 정책을 만들기 위해 콘솔 검색창에 IAM을 검색한다. IAM &amp;gt; 정책 &amp;gt; 정책 생성에서 서비스는 S3를 선택 후 이미지 생성 및 삭제 부분에만 권한을 추가할 거라 DeleteObject, PutObject를 선택한다. 리소스에서 특정을 선택 후 아까 만들어둔 S3 ARN을 추가한다. 계속 다음으로 진행 후 정책 이름을 적고 정책을 생성한다. aws에 기본 정책들이 많아 정책을 찾기 쉽게 예시처럼 작성했다. ex) &amp;lt;s3 버킷 이름&amp;gt;-s3-management IAM &amp;gt; 사용자 &amp;gt; 사용자 추가에서 사용자 이름을 추가하고 프로그래밍 방식을 체크 후 다음으로 넘어간다. 권한 설정에서 기존 정책 연결을 선택 후 이전에 만든(&amp;lt;s3 버킷 이름&amp;gt;-s3-management) 정책을 선택 후 다음으로 넘긴 후 사용자 만들기를 한다. 사용자가 만들어지면 액세스 키 ID 와 비밀 액세스 키를 확인할 수 있다. 액세스 키 ID 와 비밀 액세스 키를 사용하여 이미지 생성 및 삭제에 권한을 준다." }, { "title": "React 이미지 업로드 전 미리보기 기능", "url": "/posts/React-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C-%EC%A0%84-%EB%AF%B8%EB%A6%AC%EB%B3%B4%EA%B8%B0-%EA%B8%B0%EB%8A%A5/", "categories": "Frontend", "tags": "React 이미지 미리보기", "date": "2022-05-04 00:00:00 +0900", "snippet": "이미지 업로드 전 미리보기 기능 구현하기이미지를 미리 보여 주는 기능을 만들려고 생각했을 때 아래 두 가지 방법을 생각했다. 이미지를 서버에 올리고 반환된 이미지 주소로 이미지를 미리 보여주는 방법 이미지를 서버에 올리기 전 이미지를 미리 보여주는 방법두 번째 이미지를 서버에 올리기 전 이미지를 미리 보여주는 방법을 선택했는데 이유는 사용자가 잘못 이미지를 올렸을 경우 서버에 불필요한 이미지가 저장되는 것을 막고, 사용자가 여러 번 이미지를 교체할 경우 서버에 올리는 시간이 걸리기 때문에 더 나은 사용자 경험을 주기 위해서다.구현 방법 limit을 주었을 때 이미지 업로드 개수를 제한할 수 있는 컴포넌트로 구현하였다. &amp;lt;input /&amp;gt;태그로 파일을 불러오기 때문에 &amp;lt;input ref={fileRef}/&amp;gt;태그에 fileRef를 넣고, +를 클릭했을 때(ex: fileRef.current?.click()) onFileChange함수가 실행될 수 있도록 했다. import React, { useRef, useState } from &#39;react&#39;; interface Props { limit?: number; } const FileInput: React.FC&amp;lt;Props&amp;gt; = ({ limit, }) =&amp;gt; { const fileRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); /*...*/ return ( &amp;lt;div className=&quot;flex w-full overflow-auto scrollbar-hide&quot;&amp;gt; {/*...*/} &amp;lt;div&amp;gt; &amp;lt;input accept=&quot;image/*&quot; ref={fileRef} onChange={onFileChange} type=&quot;file&quot; className=&quot;hidden&quot; /&amp;gt; &amp;lt;div onClick={() =&amp;gt; { fileRef &amp;amp;&amp;amp; fileRef.current?.click(); }} className=&quot;cursor-pointer border-dashed text-[40px] w-[200px] h-[200px] border border-gray-200 mt-5 flex items-center justify-center font-jua text-gray-300&quot; &amp;gt; + &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; {/*...*/} &amp;lt;/div&amp;gt; ); }; export default FileInput; 이미지를 불러올 때 이벤트 함수 onFileChange함수가 작동되면서 이미지 파일을 불러온다. e.target.files 배열에 파일의 정보가 담겨있다. const onFileChange = async (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const file = e.target.files?.[0]; }; new FileReader()의 readAsDataURL에 이미지 파일을 넣어준다. FileReader.readAsDataURL const onFileChange = async (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const file = e.target.files?.[0]; const fileReader = new FileReader(); fileReader.readAsDataURL(file); }; new FileReader()의 onload를 사용해서 파일을 읽는다. e.target.result에 담겨있는 url을 이미지 태그 src에 넣어준다. const onFileChange = async (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const file = e.target.files?.[0]; const fileReader = new FileReader(); fileReader.readAsDataURL(file); fileReader.onload = (e) =&amp;gt; { const result = e?.target?.result as string; setImgSrcList([...imgSrcList, result]); }; }; 전체 구현 소스 아래는 이미지 생성 및 수정을 할 수 있도록 구현한 전체 소스이다. 이미지는 이미지 크기 줄여 업로드하였다.import React, { useRef, useState } from &#39;react&#39;;import { useEffect } from &#39;react&#39;;import { CgClose } from &#39;react-icons/cg&#39;;import imageCompression from &#39;browser-image-compression&#39;;interface Props { data?: string[]; limit?: number; handleFile: (val: File) =&amp;gt; void; handleImgSrcList?: (val: string[]) =&amp;gt; void;}const FileInput: React.FC&amp;lt;Props&amp;gt; = ({ data, limit, handleFile, handleImgSrcList,}) =&amp;gt; { const fileRef = useRef&amp;lt;HTMLInputElement&amp;gt;(null); const [imgSrcList, setImgSrcList] = useState&amp;lt;string[]&amp;gt;([]); const onFileChange = async (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { const file = e.target.files?.[0]; const options = { maxSizeMB: 2, maxWidthOrHeight: 1920, }; if (file) { const compressedFile = await imageCompression(file, options); const formData = new FormData(); formData.append(&#39;image&#39;, compressedFile); handleFile(compressedFile); const fileReader = new FileReader(); fileReader.readAsDataURL(compressedFile); fileReader.onload = (e) =&amp;gt; { const result = e?.target?.result as string; setImgSrcList([...imgSrcList, result]); handleImgSrcList &amp;amp;&amp;amp; handleImgSrcList([...imgSrcList, result]); }; } }; const handleRemoveImage = (index: number) =&amp;gt; { const result = JSON.parse(JSON.stringify(imgSrcList)); result.splice(index, 1); setImgSrcList(result); handleImgSrcList &amp;amp;&amp;amp; handleImgSrcList(result); }; useEffect(() =&amp;gt; { if (data?.length) { setImgSrcList(data); handleImgSrcList &amp;amp;&amp;amp; handleImgSrcList(data); } }, [data?.length]); return ( &amp;lt;div className=&quot;flex w-full overflow-auto scrollbar-hide&quot;&amp;gt; {imgSrcList?.map((el, i) =&amp;gt; { return ( &amp;lt;div key={i} className=&quot;relative min-w-[200px] max-w-[200px] min-h-[200px] max-h-[200px] bg-black mt-5 mr-5 flex items-center justify-center&quot; &amp;gt; &amp;lt;button className=&quot;absolute top-0 right-0 bg-[#444040b8] text-white w-8 h-8 flex justify-center items-center&quot; onClick={() =&amp;gt; handleRemoveImage(i)} &amp;gt; &amp;lt;CgClose /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;img alt={&#39;이미지&#39;} src={el} className=&quot;w-full h-full object-contain&quot; /&amp;gt; &amp;lt;/div&amp;gt; ); })} {limit !== imgSrcList?.length ? ( &amp;lt;div&amp;gt; &amp;lt;input accept=&quot;image/*&quot; ref={fileRef} onChange={onFileChange} type=&quot;file&quot; className=&quot;hidden&quot; /&amp;gt; &amp;lt;div onClick={() =&amp;gt; { fileRef &amp;amp;&amp;amp; fileRef.current?.click(); }} className=&quot;cursor-pointer border-dashed text-[40px] w-[200px] h-[200px] border border-gray-200 mt-5 flex items-center justify-center font-jua text-gray-300&quot; &amp;gt; + &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) : null} &amp;lt;/div&amp;gt; );};export default FileInput;" }, { "title": "커밋 메세지 수정하기", "url": "/posts/%EC%BB%A4%EB%B0%8B-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Git", "tags": "git amend, git 커밋 메세지 수정", "date": "2022-03-24 00:00:00 +0900", "snippet": " 변경된 커밋 메세지 해시 코드를 확인해 보면 해시 코드가 변경된 것을 확인할 수 있다. 때문에 서버에 아직 업로드되기 전에 사용하고, 개발자와 협업하고 있는 상황에서는 서버에 업로드된 history에는 사용하지 않는 것이 좋다.최근 커밋 메세지 수정하기git commit --amend -m &quot;&amp;lt;메세지 변경&amp;gt;&quot; git log 확인 최근 커밋 메세지를 변경하고 싶을 때 아래와 같이 --amend -m 옵션으로 커밋 메세지를 변경할 수 있다. 최근 커밋 메세지에 수정된 파일 적용하기git add .git commit --amend예를 들어, 커밋 한 후 빠진 내용이 있을 경우 빠르게 파일 수정 후 --amend옵션만 줄 경우 최근 커밋 메세지에 수정된 파일이 함께 적용된다.특정 커밋 메세지 수정하기git rebase -i &amp;lt;변경할 커밋 이전 해시 코드&amp;gt; 수정하고 싶은 커밋에 pick -&amp;gt; reword로 변경 후 메세지를 변경하고 저장하면 특정 커밋 메세지가 변경된다. git log 커밋 메세지 2를 변경하고 싶다면 이전 커밋 해시 코드를 복사한다. rebase -i &amp;lt;변경할 커밋 이전 해시 코드&amp;gt; 수정하고 싶은 커밋에 pick -&amp;gt; reword로 변경한다. 커밋 메세지를 변경 후 저장한다. git log를 확인해 보면 특정 커밋 메세지가 변경된 것을 확인할 수 있다." }, { "title": "git stash", "url": "/posts/git-stash/", "categories": "Git", "tags": "git stash", "date": "2022-03-23 00:00:00 +0900", "snippet": "git stash 커밋을 하지 않고 스택에 잠시 하던 작업물을 임시로 저장할 수 있다. 잠시 하던 작업물을 stash stack에 저장 후 다른 브랜치로 이동할 때 유용하다. stack 구조로 새로운 것이 위로 쌓이는 구조이다.기본 명령어stash stack에 저장하기 (push 생략 가능)git stash orgit stash push 위 명령어로 stash stack에 저장할 경우 타이틀 없이 저장된다.stash stack에 메세지와 함께 저장하기git stash push -m &quot;메세지&quot; 아래와 같이 메세지를 입력해서 stash stack에 저장할 수 있다.stash 목록 확인하기git stash list위 명령어로 stash stack에 쌓인 목록을 확인할 수 있다.stash stack 유지하면서 적용하기git stash apply &amp;lt;stash 아이디&amp;gt;git stash list stash 목록을 확인해 보면 stash stack이 유지된 걸 확인할 수 있다. &amp;lt;stash 아이디&amp;gt;를 따로 적지 않으면 stack 가장 위에 있는 작업물이 적용된다.stash popgit stash pop 위 명령어를 사용할 경우 stash stack 가장 위에 쌓인 저장물이 스택에서 빠져나오면서 적용된다. stash 목록을 확인해 보면 stash stack에서 빠져나온 것을 확인할 수 있다.stash stack 특정 작업물 제거하기git stash drop &amp;lt;stash 아이디&amp;gt;stash stack 비우기git stash clear" }, { "title": "typescript + express.js + node.js 세팅", "url": "/posts/Typescript-Node+Express-%EC%84%B8%ED%8C%85/", "categories": "Backend", "tags": "typescript + express.js + node.js 세팅, typescript node express", "date": "2022-03-21 00:00:00 +0900", "snippet": "installnpm initnpm i express morgan express-async-errors typescipt ts-node 기본적으로 typescript, express.js, node.js를 사용하기 위해 필요한 라이브러리를 설치한다.npm i nodemon concurrently @types/node @types/express @types/morgan --save-dev typescript를 사용하기 위해 @types/node,@types/express, @types/morgan을 추가로 설치한다. nodemon을 설치해 서버 코드를 변경할 때마다, 서버를 자동으로 재시작한다. nodemon과 타입스크립트에서 제공하는 tsc -w를 같이 사용하기 위해 concurrently를 설치한다. tsconfig.json 설정tsc --init 위와 같이 명령어를 사용하면 기본 tsconfig.json 파일이 생성된다.{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2016&quot;, / &quot;module&quot;: &quot;commonjs&quot;, &quot;sourceMap&quot;: true, &quot;outDir&quot;: &quot;dist&quot;, &quot;esModuleInterop&quot;: true, &quot;strict&quot;: true, &quot;skipLibCheck&quot;: true }} &quot;outDir&quot;: &quot;dist&quot;로 설정하여 자바스크립트로 컴파일 하는 경로를 지정해준다. 이렇게하면 타입스크립트로 코드로 작성한 파일이 자바스크립트로 컴파일이되고 dist 폴더에 들어간다. dist 폴더안에 자바스크립트로 변환된 파일들이 노드에 반영이 되어 실행되게 된다..gitignore .gitignore 파일 생성 후 위와 같이 작성해 필요하지 않는 파일 들을 git에서 제외한다..DS_Store/dist/node_modules자동으로 재실행 시키기package.json start 부분에 아래와 같이 작성하면 concurrently를 사용하여 nodemon과 tsc -w를 같이 사용하여 자동으로 타입스크립트 코드를 컴파일하고 노드에 반영이 되어 실행된다.{ /* 생략 */ &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;, &quot;start&quot;: &quot;concurrently \\&quot;tsc -w\\&quot; \\&quot;nodemon dist/app\\&quot;&quot; }, /* 생략 */}ESLint &amp;amp; Prettier 적용 코드 품질 및 일관성을 위해 eslint 설정을 해주었다.npm i eslint prettier eslint-config-prettiernpm i eslint-plugin-prettier --save-dev.eslint.jsmodule.exports = { /* 생략 */ plugins: [&quot;@typescript-eslint&quot;, &quot;prettier&quot;], rules: { &quot;prettier/prettier&quot;: &quot;error&quot;, },};" }, { "title": "React Portal을 이용해 모달 구현", "url": "/posts/React-Portal-%EB%AA%A8%EB%8B%AC-%EA%B5%AC%ED%98%84/", "categories": "Frontend", "tags": "react portal 모달", "date": "2022-03-18 00:00:00 +0900", "snippet": "Portal 이란?Portal 이란 부모 컴포넌트를 벗어나 DOM 계층 구조 바깥에 있는 DOM 노드로 자식을 렌더링 하는 방법이다.DOM은 트리구조로 부모와 자식 관계를 가지면서 렌더링 되는데 엘리먼트가 위치한 부모와 자식 관계의 구조 따라 z-index가 먹히지 않는 경우가 있다.아래와 같이 1-modal이 fixed에 z-index를 높였을 때 2-parent 엘리먼트가 z-index 우선순위가 높게 되어 렌더링 된다.&amp;lt;div id=&#39;1-parent&#39;&amp;gt; &amp;lt;div id=&#39;1-modal&#39;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div id=&#39;2-parent&#39;&amp;gt; &amp;lt;div id=&#39;2-child&#39;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;이렇게 트리 구조 사이에서 컴포넌트를 구현하다 보면 스타일 속성에 제약을 받는 경우가 있는데 Portal을 이용해 계층 구조 바깥 독립적인 위치에서 렌더링 하면 편리하다.Portal 모달 구현하기installnpm i react-domnpm i npm i --save-dev @types/react-dom/components/Portal/index.tsx children으로 넣어주는 Portal을 만들어 준다.import { useEffect, useMemo } from &#39;react&#39;;import type { FC, AriaAttributes } from &#39;react&#39;;import { createPortal } from &#39;react-dom&#39;;export interface Props extends AriaAttributes { style?: Partial&amp;lt;CSSStyleDeclaration&amp;gt;;}const Portal: FC&amp;lt;Props&amp;gt; = ({ children, style }) =&amp;gt; { const element = useMemo(() =&amp;gt; document.createElement(&#39;div&#39;), []); useEffect(() =&amp;gt; { if (style) { for (const property in style) { const value = style[property]; if (value) element.style[property] = value; } if (style.position === &#39;absolute&#39;) document.body.style.position = &#39;relative&#39;; } document.body.appendChild(element); return () =&amp;gt; { document.body.removeChild(element); if (document.body.style.position) document.body.removeAttribute(&#39;style&#39;); }; }, [element, style]); return createPortal(children, element);};export default Portal;/components/ImageSliderModal/index.tsx Portal에 children을 넣어 모달을 구현한다.import { SwiperImage, Portal } from &#39;components&#39;;import React, { FC } from &#39;react&#39;;interface Props { data: string[]; selectedImgIndex: number; onClose: () =&amp;gt; void;}const ImageSliderModal: FC&amp;lt;Props&amp;gt; = ({ data, onClose, selectedImgIndex }) =&amp;gt; { return ( &amp;lt;Portal&amp;gt; &amp;lt;div className=&quot;fixed inset-0 bg-black flex justify-center items-center&quot;&amp;gt; &amp;lt;div className=&quot;w-full h-full flex items-center justify-center flex-col&quot;&amp;gt; &amp;lt;button className=&quot;text-white mb-5 p-2&quot; onClick={onClose}&amp;gt; 닫기 &amp;lt;/button&amp;gt; &amp;lt;SwiperImage data={data} initialImgIndex={selectedImgIndex + 1} /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/Portal&amp;gt; );};export default ImageSliderModal;" }, { "title": "React 이미지 슬라이드(infinite loop) 구현", "url": "/posts/React-Slider-Image-%EA%B5%AC%ED%98%84/", "categories": "Frontend", "tags": "react 이미지 슬라이드 구현, Image Slider 구현", "date": "2022-03-14 00:00:00 +0900", "snippet": "To do라이브러리 없이 아래 나열된 기능을 기준으로 이미지 슬라이드 구현을 해보았다. &amp;lt; (이전), &amp;gt;(다음) 버튼 클릭으로 슬라이드 이미지 전환 모바일에서 터치로 슬라이드 이미지 전환 무한 루프로 마지막 이미지에서 다음 이미지로 터치 또는 클릭 시 자연스럽게 첫 번째 이미지로 이미지 전환, 첫 번째 이미지에서 이전 이미지로 터치 또는 클릭 시 마지막 이미지로 자연스럽게 이미지 전환완성된 화면버튼 클릭 시 이미지 슬라이드 전환 기능 아래와 같이 이미지 링크(string)를 배열로 받을 수 있는 컴포넌트로 구현하였다.import React, { FC } from &#39;react&#39;;import { SwiperImage } from &#39;components&#39;;const Sample: FC = () =&amp;gt; { /* ... 생략 ...*/ const data = [&#39;이미지 url 링크 1&#39;, &#39;이미지 url 링크 2&#39;]; return ( &amp;lt;div&amp;gt; &amp;lt;SwiperImage data={data} /&amp;gt; &amp;lt;/div&amp;gt; );};export default Sample;슬라이드 기능 위와 같이 보일 주황색 네모칸처럼 화면 크기를 정해둔 뒤 overflow: hidden 속성으로 주황색 네모칸을 벗어나는 이미지들은 숨김 처리한다. 이미지를 감싸고 있는 div에 display: flex 속성으로 가로로 이미지를 나열한다. 슬라이드 기능이 오른쪽으로 넘어가야 되기 때문에 x축이 마이너스 방향으로 이동되기 때문에 transform: translateX(-${보일 이미지 인덱스}00%)로 이동된다. transition: all 0.4s ease-in-out 속성과 주어 자연스러운 모션을 준다. 아래는 위의 설명을 구현한 소스이다.import classNames from &#39;classnames&#39;;import React, { FC, useEffect, useRef, useState } from &#39;react&#39;;import { IoIosArrowBack, IoIosArrowForward } from &#39;react-icons/io&#39;;interface Props { data: string[];}const SwiperImage: FC&amp;lt;Props&amp;gt; = ({ data }) =&amp;gt; { const ref = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const [imageList, setImageList] = useState([ data[data?.length - 1], ...data, data[0], ]); const [currentImgIndex, setCurrentImgIndex] = useState(1); const [style, setStyle] = useState({ transform: `translateX(-${currentImgIndex}00%)`, transition: `all 0.4s ease-in-out`, }); const nextSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex + 1); setStyle({ transform: `translateX(-${currentImgIndex + 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; const prevSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex - 1); setStyle({ transform: `translateX(-${currentImgIndex - 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; return ( &amp;lt;div className=&quot;relative&quot;&amp;gt; &amp;lt;div className=&quot;overflow-hidden max-w-[480px] min-w-[280px] w-full bg-black&quot; &amp;gt; &amp;lt;div ref={ref} style={style} className={`flex`}&amp;gt; {imageList?.map((el, i) =&amp;gt; { return ( &amp;lt;img key={i} src={el} className={&#39;w-auto h-auto object-contain&#39;} /&amp;gt; ); })} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div className=&quot;absolute w-full flex justify-between top-[50%]&quot;&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={prevSlide}&amp;gt; &amp;lt;IoIosArrowBack /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={nextSlide}&amp;gt; &amp;lt;IoIosArrowForward /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; {/* ... 생략 ... */} &amp;lt;/div&amp;gt; );};export default SwiperImage;여기서 문제점!여기서 첫 번째 이미지에서 사용자가 이전 버튼을 또 클릭하게 되면 마지막 이미지로 전환되지만 자연스럽지 못하게 휘리릭 마지막으로 넘어간다.자연럽게 무한 루프 기능 추가하기 위 화면과 같이 첫 번째 이미지(이미지 1) 왼쪽에 트릭을 주기 위한 가짜 마지막 이미지(이미지 4)를 두고 마지막 이미지(이미지 4) 오른쪽에도 트릭을 주기 위한 가짜 첫 번째 이미지(이미지 1)를 둔다. 이미지 4에서 다음 버튼을 클릭할 경우 오른쪽에 있는 trick 이미지 1으로 넘어가는데, 여기서 settimeout으로 빠르게 transition: 0ms으로 효과 없이 사용자가 눈치채지 못하도록 진짜 이미지 1으로 이동한다. 이미지 1에서 다음 버튼을 클릭할 경우 오른쪽에 있는 trick 이미지 4으로 넘어가는데, 여기서 settimeout으로 빠르게 transition: 0ms으로 효과 없이 사용자가 눈치채지 못하도록 진짜 이미지 4으로 이동한다. 인덱스 0과 인덱스 imageList[imageList.length - 1]는 trick 이미지이기 때문에 가장 첫 번째 인덱스와 마지막 인덱스를 제외한 이미지들을 보여준다. 아래는 위 내용을 구현한 소스이다.import classNames from &#39;classnames&#39;;import React, { FC, useEffect, useRef, useState } from &#39;react&#39;;import { IoIosArrowBack, IoIosArrowForward } from &#39;react-icons/io&#39;;interface Props { data: string[];}const SwiperImage: FC&amp;lt;Props&amp;gt; = ({ data }) =&amp;gt; { const ref = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const [imageList, setImageList] = useState([ data[data?.length - 1], ...data, data[0], ]); const [currentImgIndex, setCurrentImgIndex] = useState(1); const [touch, setTouch] = useState({ start: 0, end: 0, }); const [style, setStyle] = useState({ transform: `translateX(-${currentImgIndex}00%)`, transition: `all 0.4s ease-in-out`, }); const nextSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex + 1); setStyle({ transform: `translateX(-${currentImgIndex + 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; const prevSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex - 1); setStyle({ transform: `translateX(-${currentImgIndex - 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; useEffect(() =&amp;gt; { if (currentImgIndex === 0) { setCurrentImgIndex(imageList.length - 2); setTimeout(function () { setStyle({ transform: `translateX(-${imageList.length - 2}00%)`, transition: &#39;0ms&#39;, }); }, 500); } if (currentImgIndex &amp;gt;= imageList?.length - 1) { setCurrentImgIndex(1); setTimeout(() =&amp;gt; { setStyle({ transform: `translateX(-${1}00%)`, transition: &#39;0ms&#39;, }); }, 500); } }, [currentImgIndex, imageList.length]); useEffect(() =&amp;gt; { setStyle({ transform: `translateX(-${1}00%)`, transition: &#39;0ms&#39;, }); }, [imageList]); return ( &amp;lt;div className=&quot;relative&quot;&amp;gt; &amp;lt;div className=&quot;overflow-hidden max-w-[480px] min-w-[280px] w-full bg-black&quot; &amp;gt; &amp;lt;div ref={ref} style={style} className={`flex`}&amp;gt; {imageList?.map((el, i) =&amp;gt; { return ( &amp;lt;img key={i} src={el} className={&#39;w-auto h-auto object-contain&#39;} /&amp;gt; ); })} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div className=&quot;absolute w-full flex justify-between top-[50%]&quot;&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={prevSlide}&amp;gt; &amp;lt;IoIosArrowBack /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={nextSlide}&amp;gt; &amp;lt;IoIosArrowForward /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; {/* ... 생략 ... */} &amp;lt;/div&amp;gt; );};export default SwiperImage;모바일 터치 슬라이드 기능 구현 onTouchStart e.touches[0].pageX 처음 터치한 위치를 기억해 둔다. onTouchMove 터치하면서 넘길 때 해당 위치까지 끌려오기 위해 transition: 0ms으로 이동할 위치로 이동한다 const current = ref.current.clientWidth * currentImgIndex; const result = -current + (e.targetTouches[0].pageX - touch.start); // 터치이동 시 이동되는 위치 setStyle({ transform: `translate3d(${result}px, 0px, 0px)`, transition: &#39;0ms&#39;, }); onTouchEnd 처음 터치했을 때 위치보다 마지막 이동된 위치가 더 작을 경우 이전 슬라이드로, 반대인 경우 다음 슬라이드로 이동한다. const end = e.changedTouches[0].pageX; if (touch.start &amp;gt; end) { nextSlide(); } else { prevSlide(); } setTouch({ ...touch, end, }); 완성된 구현 소스import classNames from &#39;classnames&#39;;import React, { FC, useEffect, useRef, useState } from &#39;react&#39;;import { IoIosArrowBack, IoIosArrowForward } from &#39;react-icons/io&#39;;interface Props { data: string[];}const SwiperImage: FC&amp;lt;Props&amp;gt; = ({ data }) =&amp;gt; { const ref = useRef&amp;lt;HTMLDivElement&amp;gt;(null); const [imageList] = useState([data[data?.length - 1], ...data, data[0]]); const [currentImgIndex, setCurrentImgIndex] = useState(1); const [touch, setTouch] = useState({ start: 0, end: 0, }); const [style, setStyle] = useState({ transform: `translateX(-${currentImgIndex}00%)`, transition: `all 0.4s ease-in-out`, }); const nextSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex + 1); setStyle({ transform: `translateX(-${currentImgIndex + 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; const prevSlide = () =&amp;gt; { setCurrentImgIndex(currentImgIndex - 1); setStyle({ transform: `translateX(-${currentImgIndex - 1}00%)`, transition: `all 0.4s ease-in-out`, }); }; useEffect(() =&amp;gt; { if (currentImgIndex === 0) { setCurrentImgIndex(imageList.length - 2); setTimeout(function () { setStyle({ transform: `translateX(-${imageList.length - 2}00%)`, transition: &#39;0ms&#39;, }); }, 500); } if (currentImgIndex &amp;gt;= imageList?.length - 1) { setCurrentImgIndex(1); setTimeout(() =&amp;gt; { setStyle({ transform: `translateX(-${1}00%)`, transition: &#39;0ms&#39;, }); }, 500); } }, [currentImgIndex, imageList.length]); return ( &amp;lt;div className=&quot;relative&quot;&amp;gt; &amp;lt;div className=&quot;overflow-hidden max-w-[480px] min-w-[280px] w-full bg-black&quot; onTouchStart={(e) =&amp;gt; { setTouch({ ...touch, start: e.touches[0].pageX, }); }} onTouchMove={(e) =&amp;gt; { if (ref?.current) { const current = ref.current.clientWidth * currentImgIndex; const result = -current + (e.targetTouches[0].pageX - touch.start); setStyle({ transform: `translate3d(${result}px, 0px, 0px)`, transition: &#39;0ms&#39;, }); } }} onTouchEnd={(e) =&amp;gt; { const end = e.changedTouches[0].pageX; if (touch.start &amp;gt; end) { nextSlide(); } else { prevSlide(); } setTouch({ ...touch, end, }); }} &amp;gt; &amp;lt;div ref={ref} style={style} className={`flex`}&amp;gt; {imageList?.map((el, i) =&amp;gt; { return ( &amp;lt;img key={i} src={el} className={&#39;w-auto h-auto object-contain&#39;} /&amp;gt; ); })} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div className=&quot;absolute w-full flex justify-between top-[50%]&quot;&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={prevSlide}&amp;gt; &amp;lt;IoIosArrowBack /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button className=&quot;text-white text-xl&quot; onClick={nextSlide}&amp;gt; &amp;lt;IoIosArrowForward /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div className=&quot;text-gray-500 mt-4 text-center flex justify-center&quot;&amp;gt; {data.map((el, i) =&amp;gt; { return ( &amp;lt;div key={i} className={classNames( &#39;bg-gray-200 h-[6px] w-[6px] mr-1 rounded&#39;, { &#39;bg-rose-200&#39;: i + 1 === currentImgIndex, } )} /&amp;gt; ); })} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );};export default SwiperImage;" }, { "title": "Git 커밋 합치기", "url": "/posts/%EC%BB%A4%EB%B0%8B-%ED%95%A9%EC%B9%98%EA%B8%B0/", "categories": "Git", "tags": "Git 커밋 합치기", "date": "2022-02-24 00:00:00 +0900", "snippet": "Commit(커밋 합치기)git log 위 명령어로 아래와 같이 git history를 확인한다. 예를 들어, .으로 되어있는 커밋들을 합쳐서 2 commit으로 만들고 싶다면합치고 싶은 이전 commit 해시 키값 3ab1e91ea735703d92fb264c25316ca01a0e70c4을 복사한다. rebase -i 옵션과 합께 해시값을 명령어로 입력한다. git rebase -i 3ab1e91ea735703d92fb264c25316ca01a0e70c4 아래와 같이 합칠 커밋을 squash로 변경한 다음 start rebase버튼을 클릭한다. 아래와 같이 커밋이 합쳐진 것을 확인할 수 있다.주의할 점!스크린샷 해시 키값을 확인해 보면 리베이스가 시작된! 커밋이 삭제된 부분부터는 해시 키값이 변경된 것 을 알 수 있다.즉, 새로운 커밋이 되었기 때문에 서버에 push가 된 history에 push를 하려면 아래 명령어로 서버에 업로드할 수 있다.git push origin main --force그렇기 때문에 혼자 또는 서버에 아직 업로드되기 전에 사용하고, 개발자와 협업하고 있는 상황에서는 서버에 업로드된 history에는 사용하면 안 된다." }, { "title": "Git 커밋 삭제하기", "url": "/posts/%EC%BB%A4%EB%B0%8B-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0/", "categories": "Git", "tags": "Git 커밋 삭제", "date": "2022-02-22 00:00:00 +0900", "snippet": "마음에 들지 않는 커밋을 삭제하고 싶을 때git log 위 명령어로 아래와 같이 git history를 확인한다. 삭제하고 싶은 커밋 이전 커밋 해시 키값을 복사한다.예를 들어, 3 commit 을 삭제하고 싶거나 3 commit ~ 4 commit을 삭제하고 싶다면 2 commit해시 키값을 복사한다. rebase -i 옵션과 함께 복사한 키값을 뒤에 입력한다. git rebase -i 49ae0dd3960d31de41656744e0c3da6153a446e6 여기서 rebase를 중지하고 싶다면 git rebase --abort 명령어로 원래 상태로 되돌아간다. 삭제하고 싶은 커밋을 drop으로 변경 start rebase버튼을 클릭한다. 아래와 같이 conflict가 나는 경우 git status로 파일을 확인한 후 파일을 수정한다. 파일을 수정한 뒤 git add . 후 리베이스를 계속 진행한다.git rebase --continue git log로 확인해 보면 아래와 같이 커밋이 삭제된 것을 확인할 수 있다.주의할 점!스크린샷 해시 키값을 확인해 보면 리베이스가 시작된! 커밋이 삭제된 부분부터는 해시 키값이 변경된 것 을 알 수 있다.즉, 새로운 커밋이 되었기 때문에 서버에 push가 된 history에 push를 하려면 아래 명령어로 서버에 업로드할 수 있다.git push origin main --force그렇기 때문에 혼자 또는 서버에 아직 업로드되기 전에 사용하고, 개발자와 협업하고 있는 상황에서는 서버에 업로드된 history에는 사용하면 안 된다." }, { "title": "Next.js &amp; Typescript 프로젝트 초기 기본 세팅", "url": "/posts/Nextjs&Typescript%EC%B4%88%EA%B8%B0%EC%84%B8%ED%8C%85/", "categories": "Frontend", "tags": "Next.js & Typescript 세팅", "date": "2022-02-21 00:00:00 +0900", "snippet": "Next.js &amp;amp; Typescript installnpx create-next-app --ts &amp;lt;project-name&amp;gt;touch tsconfig.jsonnpm run dev에러 나면 아래와 같이 설치 후 다시 실행npm install --save-dev @types/node package.json{ /*...*/ &quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build &amp;amp;&amp;amp; next export&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;lint&quot;: &quot;next lint&quot; }, /*...*/}ESLint 적용하기npm i eslintnpx eslint --initnpm i prettier eslint-config-prettiernpm i -D eslint-plugin-prettier .eslintrc.jsmodule.exports = { env: { browser: true, es2021: true, }, extends: [ &#39;eslint:recommended&#39;, &#39;plugin:react/recommended&#39;, &#39;plugin:@typescript-eslint/recommended&#39;, &#39;plugin:prettier/recommended&#39;, &#39;next/core-web-vitals&#39;, // &quot;airbnb&quot;, ], parser: &#39;@typescript-eslint/parser&#39;, parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: 12, sourceType: &#39;module&#39;, }, plugins: [&#39;react&#39;, &#39;@typescript-eslint&#39;], rules: { &#39;prettier/prettier&#39;: [&#39;error&#39;, { singleQuote: true, parser: &#39;flow&#39; }], &#39;react/jsx-filename-extension&#39;: [ 1, { extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.tsx&#39;, &#39;.ts&#39;] }, ], },};BaseUrl 설정baseUrl 옵션을 사용하여 기본 경로를 지정해주면, 상대경로가 아닌 절대경로로 파일을 import 할 수 있다. base 가 되는 경로를 직접 설정함으로써, 패키지 depth 가 깊어질수록 길어지는 import 문을 짧게 나타낼 수 있다. tsconfig.json{ &quot;compilerOptions&quot;: { /*...*/ &quot;baseUrl&quot;: &quot;.&quot;, /*...*/ }, /*...*/}" }, { "title": "safe-area-inset 안전영역(Next.js)", "url": "/posts/safe-area-inset-%EC%95%88%EC%A0%84%EC%98%81%EC%97%AD/", "categories": "Frontend", "tags": "safe-area-inset", "date": "2021-12-28 00:00:00 +0900", "snippet": "Safe Area아이폰 디스플레이에서 영역이 상/하단 라운드 영역을 포함하고 있는 경우 추가적으로 상단 영역은 카메라, 스피커 등의 센서가 있는 노치(notch) 영역 존재하므로 안정적으로 콘텐츠가 보일 수 있도록 Safe Area를 설정해 주어야 한다.해결방법 _app.tsx 파일에 뷰포트 메타태그에서 viewport-fit=cover를 추가한다.import Head from &#39;next/head&#39;;function MyApp({ Component, pageProps }: AppProps) { return ( &amp;lt;&amp;gt; &amp;lt;Head&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover&quot; /&amp;gt; &amp;lt;/Head&amp;gt; &amp;lt;/&amp;gt; );}export default MyApp; style.css 해당 셀렉터에 아래와 같이 safe-area-inset를 적용한다. (constant 및 env 값을 둘 다 추가해야 IOS 구버전, 신버전 대응이 가능하다.).safe-button { height: auto; padding: 20px 0px calc(constant(safe-area-inset-bottom) + 20px); padding: 20px 0px calc(env(safe-area-inset-bottom) + 20px);}" }, { "title": "클립보드 복사하기", "url": "/posts/%ED%81%B4%EB%A6%BD%EB%B3%B4%EB%93%9C-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "클립보드 복사하기", "date": "2021-11-17 00:00:00 +0900", "snippet": "클립보드 복사하기ex) const onCopy = () =&amp;gt; { const copiedText = &#39;test&#39;; navigator.clipboard .writeText(`${copiedText}`) .then(() =&amp;gt; { alert(&#39;코드가 복사되었습니다.&#39;); }) .catch(() =&amp;gt; { alert(&#39;코드 복사가 실패되었습니다.&#39;); }); };" }, { "title": "stack or tab 스크린 이동 시 새로 고침", "url": "/posts/ReactNative-%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%9D%B4%EB%8F%99%EC%8B%9C%EC%83%88%EB%A1%9C%EA%B3%A0%EC%B9%A8/", "categories": "React Native", "tags": "React Native 스크린 이동 시 새로 고침", "date": "2021-10-21 00:00:00 +0900", "snippet": "tab screen 이동할 때 새로 고침 옵션에unmountOnBlur: true 추가하면 해당 탭에 이동할 때 항상 새로 고침이 된다.import {createBottomTabNavigator} from &#39;@react-navigation/bottom-tabs&#39;;import React from &#39;react&#39;;import * as screens from &#39;screens&#39;;const Tab = createBottomTabNavigator();export default function TabStack() { ... const options = { ... unmountOnBlur: true, ... } return ( &amp;lt;Tab.Navigator&amp;gt; ... &amp;lt;Tab.Screen name=&quot;MyPage&quot; component={screens.MyPage} options={options} /&amp;gt; &amp;lt;/Tab.Navigator&amp;gt; );}tab or stack 스크린 이동할 때 lifecycle 실행하기 스크린을 이동 navigation.pop()(뒤로 가기)를 할 때 lifecycle 실행이 되지 않는데 lifecycle을 실행시키고 싶을 때 useIsFocused를 적용한다.import {useIsFocused, useNavigation} from &#39;@react-navigation/native&#39;;export default () =&amp;gt; { const isFocused = useIsFocused(); import React, {useEffect} from &#39;react&#39;; ... useEffect(() =&amp;gt; { getData(); }, [isFocused]); ...}" }, { "title": "React Native 커스텀 폰트 사용하기", "url": "/posts/%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%8F%B0%ED%8A%B8-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "React Native", "tags": "React Native 커스텀 폰트 사용하기", "date": "2021-10-20 00:00:00 +0900", "snippet": " 다운로드한 폰트를 디렉토리 안에 넣어준다. ex) src/assets/font/&amp;lt;폰트&amp;gt;.ttf rnpm 설치 npm install -g rnpm package.json &quot;rnpm&quot;: { &quot;assets&quot;: [ &quot;./src/assets/fonts&quot; ] }아래와 같이 명령어를 실행하면 rnpm link assets android는 android/app/src/main/assets/fonts에 자동으로 폰트가 추가된다. ios는 Info.plist 파일에 아래와 같이 폰트가 추가된다. &amp;lt;key&amp;gt;UIAppFonts&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;폰트.ttf&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; 아래와 같이 스타일을 적용하는 부분에 넣어 사용할 수 있다.fontFamily: &#39;폰트이름&#39;참고📝" }, { "title": "ESLint &amp; Prettier 적용하기", "url": "/posts/ESLint&Prettier-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Frontend", "tags": "ESLint & Prettier, ESLint & Prettier 적용하기", "date": "2021-08-30 00:00:00 +0900", "snippet": "ESLint는 JavaScript, JSX의 정적 분석 도구로 코드를 분석해 문법적인 오류를 찾아주고 일관된 코드 스타일로 작성하도록 도와준다. ESLint는 스타일 가이드를 좀 더 편리하게 적용할 수 있다.(예: Airbnb Style Guide, Google Style Guide) 포맷팅 : 일관된 코드 스타일을 유지할 수 있다. (들여 쓰기, 코드 라인 너비 규칙 등등) 코드 품질: 잠재적 오류나 버그 예방(사용하지 않는 변수 등)installnpm i eslint// 코드 검증 및 수정npx eslint [파일]npx eslint [파일] --fix명령어로 ESlint 세팅npx eslint --init위와 같이 커맨드 창의 입력하면 대화 형식으로 설정 파일을 만들 수 있다.해당 설정에 맞게 세팅하고 필요한 라이브러리들을 추가 설치하면아래와 같이 루트 디텍토리에 .eslintrc.js 파일이 만들어진다. module.exports = { env: { browser: true, es2021: true, }, extends: [ &#39;plugin:react/recommended&#39;, // [https://eslint.org/docs/rules/](https://eslint.org/docs/rules/) 에 체크되어있는 것이 전부 세팅되어있다. &#39;airbnb&#39;, ], parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: 12, sourceType: &#39;module&#39;, }, plugins: [ &#39;react&#39;, ], rules: { },}; &quot;extends&quot;: &quot;eslint:recommended&quot; 는 https://eslint.org/docs/rules/ 에 체크되어 있는 것이 전부 세팅되어 있다. 링크를 확인해보면 자동으로 수정할 수 있는 것은 렌치 표시가 되어있다. Prettier 프리티어는 es-lint에서 고쳐주지 않는 것까지 고쳐준다.npm i prettiernpm i eslint-config-prettier// 프리티어에 있는 규칙을 eslint에 넣기npm i -D eslint-plugin-prettier// 코드 수정npx prettier [파일] --wirteESLint &amp;amp; Prettiermodule.exports = { env: { browser: true, es2021: true, }, extends: [ &quot;eslint:recommended&quot;, // 미리 설정된 규칙 세트를 사용한다. &quot;plugin:react/recommended&quot;, &quot;airbnb&quot;, &quot;plugin:prettier/recommended&quot;, ], parserOptions: { ecmaFeatures: { jsx: true, }, ecmaVersion: 12, sourceType: &quot;module&quot;, }, plugins: [&quot;react&quot;, &quot;prettier&quot;], rules: { &quot;prettier/prettier&quot;: &quot;error&quot;, ... },};vs-codeinstallsetting{ &quot;workbench.colorTheme&quot;: &quot;Default Dark+&quot;, &quot;terminal.integrated.defaultProfile.osx&quot;: &quot;zsh&quot;, &quot;editor.tabSize&quot;: 2, &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true }, &quot;js/ts.implicitProjectConfig.strictNullChecks&quot;: true, &quot;[javascript]&quot;: { &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; }}" }, { "title": "React Webpack 설정", "url": "/posts/React-%EC%9B%B9%ED%8C%A9-%EC%84%A4%EC%A0%95/", "categories": "Frontend", "tags": "React Webpack 설정", "date": "2021-08-26 00:00:00 +0900", "snippet": "package.jsonnpm initgitgit init .gitignore 루트에 .gitignore 파일을 생성 후 아래와 같이 git에 저장하고 싶지 않은 폴더 및 파일을 입력한다. node_modulesdist/*.DS_Storereactyarn add react react-dombabelyarn add @babel/runtimeyarn add --dev @babel/core babel-loader @babel/preset-react @babel/preset-env @babel/plugin-transform-runtimewebpack yarn add --dev webpack webpack-dev-server webpack-cli html-webpack-plugin copy-webpack-plugin webpack.config.jsconst path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const CopyPlugin = require(&quot;copy-webpack-plugin&quot;);module.exports = { mode: &quot;development&quot;, entry: &quot;./index.js&quot;, // 모듈이 시작되는 부분 (엔트리 포인트) output: { path: path.resolve(&quot;./dist&quot;), // 모듈이 시작되는 부분부터 모두 합쳐준 결과물을 저장하는 곳 filename: &quot;bundle.js&quot;, // 합쳐진 결과물 파일 이름 }, resolve: { extensions: [&quot;.jsx&quot;, &quot;.js&quot;], }, module: { rules: [ { test: /\\.(js)x?$/, // js, jsx로 끝나는 모든 파일 exclude: /node_module/, use: { loader: &quot;babel-loader&quot;, }, }, { test: /\\.css$/, // css로 끝나는 모든 파일 use: [&quot;style-loader&quot;, &quot;css-loader&quot;], // css-loader는 css파일을 모듈 처럼 사용할 수 있게 해주는 로더이고 style-loader는 css-loader가 처리해준 모듈처럼 사용할 수있게 한 js파일의 css문자열을 브라우저에 html에 주입시켜 브라우저에 보여질 수 있도록 처리해주는 로더이다 }, { test: /\\.s[ac]ss$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;], // 로더는 한 파일에 여러개가 실행될 때 뒤에서 부터 앞으로 실행된다. }, { test: /\\.(png|svg|jpg|jpeg|gif|ico)$/, exclude: /node_modules/, use: [&quot;file-loader?name=[name].[ext]&quot;], // 이미지 파일을 모듈로 사용할 수 있도록 변환하는 역할을 하는 로더이다. }, ], }, plugins: [ new HtmlWebpackPlugin({ template: &quot;./index.html&quot;, }), new CopyPlugin({ patterns: [{ from: &quot;./src/assets&quot;, to: &quot;&quot; }], }), ],}; babel.config.jsmodule.exports = { presets: [&quot;@babel/env&quot;, &quot;@babel/react&quot;], plugins: [&quot;@babel/plugin-transform-runtime&quot;],}; package.json yarn start 개발환경 yarn build 하나로 만들어진 자바스크립트 파일이 dist 폴더에 bundle.js라는 파일 이름으로 생성된다. { &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;amp;&amp;amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --mode development --config ./webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --mode production --config ./webpack.config.js&quot; },}" }, { "title": "웹팩(Webpack)", "url": "/posts/%EC%9B%B9%ED%8C%A9(Webpack)/", "categories": "Frontend", "tags": "Webpack", "date": "2021-06-06 00:00:00 +0900", "snippet": "웹팩이란?출처 모듈로 연결된 여러 개의 자바스크립트 파일을 하나로 만들어주는 역할을 한다. 하나로 합쳐진 파일을 번들이라고 하는데 웹팩은 번들을 만들어주는 번들러이다.웹팩 설치 webpack &amp;amp; webpack-cli 을 설치한다.npm install -D webpack webpack-cli 웹팩 설치 후 프로젝트 루트 폴더에 webpack.config.js 파일을 만든다.웹팩 설정webpack.config.jsconst path = require(&#39;path&#39;);module.exports = { mode: &#39;development&#39;, entry: ./src/index.js, output: { path: path.resolve(./dist), filename: bundle.js }, ...} 웹팩 필수 옵션 조건 --mode : development, production, none 웹팩 빌드 옵션으로 환경에 따라 설정해 준다. --entry: 모듈의 시작점을 엔트리 또는 엔트리 포인트라고 한다. 엔트리 포인트부터 하나씩 모듈을 엮어 js 파일로 만든다. (예: src/index.js) --output : 모듈이 시작되는 부분부터 모두 합쳐준 결과물을 저장하는 곳 path: 합쳐진 결과물 파일을 저장하는 폴더 경로 filename: 합쳐진 결과물 파일 이름이다. 보통 “bundle.js” 또는 “[name].js”로 많이 사용한다. 로더로더는 모든 파일을 자바스크립트 모듈처럼 만들어준다. 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해 주거나 이미지 및 css 파일을 자바스크립트에서 직접 로딩할 수 있도록 해준다. 로더는 modules 객체의 rules 배열에 추가하여 설정할 수 있다. rules 배열에는 객체를 넣는데 test에는 로더가 처리해야 할 파일들의 패턴을 정규 표현식으로 작성하고 use에는 사용할 로더를 작성한다.css-loader &amp;amp; style-loadercss-loader는 css 파일을 모듈처럼 사용할 수 있게 해주는 로더이고 style-loader는 css-loader가 처리해 준 모듈처럼 사용할 수 있게 해주는 로더이다. js 파일의 css 문자열을 브라우저에 html에 주입시켜 브라우저에 보일 수 있도록 처리해준다.npm install css-loader style-loaderwebpack.config.jsconst path = require(&#39;path&#39;);module.exports = { mode: &quot;development&quot;, entry: &quot;./src/app.js&quot;, output: { path: path.resolve(&#39;./build&#39;), filename: &quot;bundle.js&quot; }, module: { rules: [ { test: /\\.css$/, // css로 끝나는 모든 파일 use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] } ] }} css로 끝나는 모든 파일마다 작성한 로더가 실행된다. 위와 같이 로더는 한 파일에 여러 개가 실행될 때 배열의 뒤에서부터 앞으로 실행된다. (예: css-loader → style-loader 순으로 실행된다.)file-loader이미지 파일을 모듈로 사용할 수 있도록 변환하는 역할을 하는 로더이다.npm i file-loaderwebpack.config.jsconst path = require(&#39;path&#39;);module.exports = { mode: &quot;development&quot;, entry: &quot;./src/app.js&quot;, output: { path: path.resolve(&#39;./build&#39;), filename: &quot;bundle.js&quot; }, module: { rules: [ { test: /\\.css$/, //css로 끝나는 모든 파일 use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { test: /\\.(png|jpg|svg|gif)$/, //png,jpg,svg,gif로 끝나는 모든 파일 loader: &#39;file-loader&#39;, options: { publicPath: &#39;./dist/&#39;, name: &#39;[name].[ext]?[hash]&#39; // [원본 파일명].[확장자명].[해쉬값] } }, ] }} 빌드된 이미지 경로를 사용할 수 있도록 publicPath 경로를 설정해 준다. option name에 [원본 파일명].[확장자명].[해쉬값(캐시와 관련된 문제를 해결)]를 설정한다. 더 많은 로더 보기플러그인로더는 모듈로 연결되어 있는 파일마다 변환하는 과정에서 처리한다면 플러그인은 아웃풋으로 번들링 된 결과물을 처리해 준다.BannerPluginchild_process 설치하면 터미널 명령어를 실행할 수 있다. childProcess.execSync에 문자열을 넣어 터미널 명령어를 사용할 수 있다.const path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);const childProcess = require(&#39;child_process&#39;); // 터미널 명령어를 실행할 수 있다.(node_module)module.exports = { mode: &quot;development&quot;, entry: &quot;./src/app.js&quot;, output: { path: path.resolve(&#39;./build&#39;), filename: &quot;bundle.js&quot; }, module: { rules: [ { test: /\\.css$/, //css로 끝나는 모든 파일 use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { test: /\\.(png|jpg|svg|gif)$/, //png,jpg,svg,gif로 끝나는 모든 파일 loader: &#39;file-loader&#39;, options: { publicPath: &#39;./dist/&#39;, name: &#39;[name].[ext]?[hash]&#39; // [원본 파일명].[확장자명].[해쉬값] } }, ] }, plugins: [ new webpack.BannerPlugin({banner: ` Build Date: ${new Date().toLocaleString()} Commit Version: ${childProcess.execSync(&#39;git rev-parse --short HEAD&#39;)} Author: ${childProcess.execSync(&#39;git config user.name&#39;)} `}) ]}CleanWebpackPluginwebpack으로 빌드를 할 때마다 자동으로 이전에 빌드 된 아웃풋 폴더를 삭제하고 다시 빌드 할 수 있는 플러그인이다.npm i clean-webpack-pluginconst path = require(&#39;path&#39;);const webpack = require(&#39;webpack&#39;);const childProcess = require(&#39;child_process&#39;); // 터미널 명령어를 실행할 수 있다.(node_module)const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;);module.exports = { mode: &quot;development&quot;, entry: &quot;./src/app.js&quot;, output: { path: path.resolve(&#39;./build&#39;), filename: &quot;bundle.js&quot; }, module: { rules: [ { test: /\\.css$/, //css로 끝나는 모든 파일 use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { test: /\\.(png|jpg|svg|gif)$/, //png,jpg,svg,gif로 끝나는 모든 파일 loader: &#39;file-loader&#39;, options: { name: &#39;[name].[ext]?[hash]&#39; // [원본 파일명].[확장자명].[해쉬값] } }, ] }, plugins: [ ... new CleanWebpackPlugin(), ... ]} 더 많은 플러그인 보기" }, { "title": "타입스크립트 OOP 객체지향", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/", "categories": "Typescript", "tags": "typescript, 객체지향, OOP", "date": "2021-03-14 00:00:00 +0900", "snippet": "객체지향이란?서로 관련 있는 데이터와 함수를 객체(하나의 역할을 수행하는 메소드와 변수의 묶음)로 정의해서 서로 상호작용할 수 있도록 프로그래밍 해나가는 것을 말한다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.장점객체지향을 사용하면 중복되는 관련 객체를 재사용할 수 있어 코드의 중복을 어느 정도 줄일 수 있고 관련 있는 객체들의 역할 분담을 좀 더 확실하게 할 수 있어서 가독성이 높아질 수 있다. 생산성을 높여준다. 유지 보수 및 확장성이 높다.참고-위키백과참고-나무위키객체지향 요소캡슐화(Encapsulation) 서로 연관되어 있는 데이터와 함수들을 캡슐화하는 것을 말한다.정보 은닉(Infomation Hiding) 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈 내부로 감추는 것이다. 서로 연관 있는 데이터와 함수들을 오브젝트 안에 담아두고 외부에서 보일 필요가 없는 세부 데이터를 숨겨 높음으로 외부에서 내부 데이터를 변경할 수 없도록 할 수 있다. 일반적으로 세 종류의 접근 제한이 사용된다.constructor class를 가지고 instance(object)를 만들 때 항상 호출되는 함수로 데이터를 담아 호출할 수 있다. static 이란 키워드를 사용해서 object를 만드는 함수를 제공한다면 private constructor로 설정해두어 static method를 사용할 수 있도록 권장한다.public 클래스의 외부에서 사용 가능하도록 노출시키는 것이다. 외부에서 데이터를 확인 또는 변경할 수 있다. class 안에서 변수나 함수에 따로 키워드를 사용하지 않으면 기본적으로 public 상태이다.private 클래스의 내부에서만 사용되며 외부로 노출되지 않는다. 외부에서 데이터를 확인 또는 변경할 수 있다.protected 다른 클래스에게는 노출되지 않지만, 상속받은 자식 클래스에게는 노출되는 것이다. 외부에서 접근할 수 없고 상속받은 class만이 접근이 가능하다.class Animal { private emotion: string = &#39;&#39;; private energy: number = 0; constructor( private animalType: string, private name: string, private gender: string ) { this.animalType = animalType; this.name = name; this.gender = gender; } play() { this.emotion = &#39;happy&#39;; } eat(food: number) { this.energy = food; }}const dog = new Animal(&#39;dog&#39;, &#39;sam&#39;, &#39;male&#39;);const cat = new Animal(&#39;cat&#39;, &#39;jang&#39;, &#39;female&#39;);추상화 내부의 복잡한 기능 private 키워드를 사용해 외부에서 보이지 않도록 함으로서 외부에서 보이는 인터페이스(함수)만을 통해 내부 기능을 이해하지 않아도 사용할 수 있다.예를 들어, eat , play 함수를 사용하면서 외부에서는 에너지나 감정이 변화하는 함수를 이해하지 않아도 사용할 수 있다.class Animal { private emotion: string = &#39;&#39;; private energy: number = 0; constructor( private animalType: string, private name: string, private gender: string ) { this.animalType = animalType; this.name = name; this.gender = gender; } private energyUp (energy: number) { this.energy = energy; } private energyDown () { this.energy -=- 1; } private happyEmotion () { this.energyDown(); this.emotion = &#39;happy&#39;; } play() { this.happyEmotion(); } eat(food: number) { this.energyUp(food); this.happyEmotion(); }}const dog = new Animal(&#39;dog&#39;, &#39;sam&#39;, &#39;male&#39;);dog.eat();dog.play();상속 상속을 사용하여 코드의 재사용성을 높일 수 있다.extends extends라는 키워드를 사용하여 class를 상속받을 수 있다. 상속을 할 때 constructor가 private일 경우 상속이 되지 않는다. public 또는 자식 클래스에서 접근이 가능하도록 protected 키워드를 사용해야 한다. 자식 클래스가 부모 클래스의 함수를 이용하고 싶다면 super 키워드로 접근할 수 있다. 자식 클래스에서 constructor는 반드시 super를 호출해야 하며 부모 클래스에서 필요한 데이터를 super를 이용해 전달해 주어야 한다.상속의 단점: 타입스크립트에서 상속은 두가지 이상 상속받을 수 없으며 부모클래스의 변화가 있을 경우 자식 클래스도 영향을 미치는 단점이 있다.class Animal { private emotion: string = &#39;&#39;; private energy: number = 0; constructor( private animalType: string, private name: string, private gender: string ) { this.animalType = animalType; this.name = name; this.gender = gender; } private energyUp (energy: number) { this.energy = energy; } private energyDown () { this.energy -= 1; } private happyEmotion () { this.emotion = &#39;happy&#39;; } play() { this.happyEmotion(); } eat(food: number) { this.energyUp(food); this.happyEmotion(); }}class Dog extends Animal { constructor(animalType, name, gender) { super(animalType, name, gender) } barking() { super.energyDown(); return &#39;wang wang&#39;; }}const seryDog = new Dog(&#39;dog&#39;, &#39;sery&#39;, &#39;female&#39;);seryDog.barking();다형성 상속을 통해서 만들어진 자식 클래스들의 종류와 상관없이 부모 클래스에 정의된 함수를 호출할 수 있다.class Animal { private emotion: string = &#39;&#39;; private energy: number = 0; constructor( private animalType: string, private name: string, private gender: string ) { this.animalType = animalType; this.name = name; this.gender = gender; } private energyUp (energy: number) { this.energy = energy; } private energyDown () { this.energy -=- 1; } private happyEmotion () { this.emotion = &#39;happy&#39;; } play() { this.energyDown(); this.happyEmotion(); } eat(food: number) { this.energyUp(food); this.happyEmotion(); }}class Dog extends Animal { constructor(animalType, name, gender) { super(animalType, name, gender) } ... barking() { super.energyDown(); return &#39;wang wang&#39;; } ...}class Cat extends Animal { constructor(animalType, name, gender) { super(animalType, name, gender) } ... play() { super.play(); } ...}const seryDog = new Dog(&#39;dog&#39;, &#39;sery&#39;, &#39;female&#39;);seryDog.barking();static 변수나 함수에 static이라는 키워드를 사용하면 class level로 지정된고 static이 사용하지 않으면 object level이다. class level은 class와 연결되어 있기 때문에 instance마다 만들어지거나 생성되지 않는다. object level은 this를 사용해 접근할 수 있고 class level을 사용할 때 class 이름으로 접근할 수 있다.class Animal { static private emotion: string = &#39;&#39;; static private energy: number = 0; constructor( private animalType: string, private name: string, private gender: string ) { this.animalType = animalType; this.name = name; this.gender = gender; } static makeAnimal (animalType: string, name: string, gender: string) { return new Animal(animalType, name, gender) } private energyUp (energy: number) { Animal.energy = energy; } private energyDown () { Animal.energy -=- 1; } private happyEmotion () { Amimal.emotion = &#39;happy&#39;; } play() { this.happyEmotion(); } eat(food: number) { this.energyUp(food); this.happyEmotion(); }}const dog = Animal.makeAnimal(&#39;dog&#39;, &#39;sery&#39;, &#39;female&#39;);getter 와 setter getter와 setter를 사용하면 조금 더 다양한 연산을 할 수 있으며, 전달된 인자가 정확한지에 대해서 유요성 검사를 할 수 있다.class User { constructor(private name: string, private age: number) { this.name = name; this.age = age; } get userInfo(): string { return `name: ${this.name} , age: ${this.age}` } get age(): number { return this.age; } set age(num: number) { if (num &amp;lt; 0) { throw Error(&#39;error&#39;) } this.age = num; }}const user = new User(&#39;sara&#39;, 30);console.log(user.userInfo) // name: sara , age: 30user.age = 20;console.log(user.age) // 20interface class와 상호작용하기 위한 규약을 정의하는 것이다. interface를 사용할 때 implements라는 키워드랄 사용해서 class를 구현한다. interface로 정의한 규약을 class로 구현해야한다.type IOS = { serialNumber: string}interface PhoneIOS { makePhone(serialNumber: string):IOS }class Phone implements PhoneIOS { constroctor(private serialNumber: string) { this.serialNumber = serialNumber } makePhone(serialNumber: string):IOS { return { serialNumber: string } }}composition 각각의 기능을 클래스로 만들어두어 필요한 기능을 외부에서 주입받아 가져다 쓰는 것을 말한다. 클래스 간의 상호작용을 하는 경우 interface를 통해 상호작용하는 것이 좋다.abstract class 상속 클래스를 이용할 때 특정 기능만 자식 클래스에서 달라진다면 Abstact class를 만들어 볼 수 있다. 클래스 앞에 abstract라는 키워드를 사용하면 해당 클래스로 자체 오브젝트를 생성할 수 없다." }, { "title": "타입스크립트란 type", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%83%80%EC%9E%85/", "categories": "Typescript", "tags": "typescript", "date": "2021-02-22 00:00:00 +0900", "snippet": "원시 타입아래와 같이 타입을 설정하면 다른 타입의 종류를 할당할 수 없다. 다른 타입을 할당할 경우 타입 에러가 발생한다.numberconst age:number = 30 // number 타입만 할당이 가능하다.const name:string = 3 // error (string 타입을 할당해야 한다.)stringconst name:string = &#39;sara&#39;; // string 타입만 할당이 가능하다.booleanconst isActive:boolean = true; // beelean 타입만 할당이 가능하다.undefined : 값이 결정되지 않은 상태let age: number | undefined // number 이거나 undefinedage = 30;age = undefined;function sum (): number | undefined { // .. return 되는 값이 number 이거나 undefined};null: 값이 없는 상태let name: string | null;name = &#39;ann&#39;;name = null;unknown 어떤 데이터의 종류가 담길지 알 수 없는 상태 로 어떤 타입의 데이터든 할당할 수 있다. 가능하면 사용하지 않는 것이 좋다.let unknown:unknown = &#39;hello world&#39;;unknown = 30;unknown = true;any 어떤 데이터의 종류든 담을 수 있는 상태로 어떤 타입의 데이터든 할당할 수 있다. 가능하면 사용하지 않는 것이 좋다.let anything:any = &#39;hello world&#39;;unknown = 30;unknown = true;Object 타입Objectfunction object(obj:object) {}object({age: 22});object([1, 2, 3, 4, 5]);Array 문자열만 가지는 배열const names: string[] = [&#39;teaback&#39;, &#39;taesoon&#39;, &#39;sara&#39;];const names: Array&amp;lt;string&amp;gt; = [&#39;teaback&#39;, &#39;taesoon&#39;, &#39;sara&#39;]; number 타입만 가지는 배열const ages: number[] = [20, 30, 50];const ages: Array&amp;lt;number&amp;gt; = [20, 30, 50]; 문자열과 숫자를 동시에 가지는 배열const arr: (string | number)[] = [10, &#39;hello&#39;, 22, &#39;world&#39;, 34];const arr: Array&amp;lt;string | number&amp;gt; = [11, &#39;hello&#39;, 2, &#39;world&#39;, 33, 35]; 배열이 가지는 값의 타입을 어떤 것이든 담을 때 any를 사용할 수 있다.const arr: (any)[] = [1, &#39;a&#39;, 2, &#39;b&#39;, &#39;c&#39;, 3];const arr: Array&amp;lt;any&amp;gt; = [1, &#39;a&#39;, 2, &#39;b&#39;, &#39;c&#39;, 3];readonly 인자의 데이터를 변경할 수 없고 읽을 수만 있다.function readNumbers(numbers: readonly number[]) { // Array&amp;lt;numbers&amp;gt;는 사용할 수 없다. console.log(numbers) numbers.push(6); // error }readNumbers([1, 2, 3, 4, 5])function : void 아무것도 리턴하지 않는다.function print():void { console.log(&#39;hello&#39;); return; // 생략 가능}function: never 절대 리턴할 수 없다.function throwError(message: string): never { // message -&amp;gt; server (log) // throw new Error(message); // while 문..}promise 숫자를 리턴하는 promise function fetchNum(id: string): Promise&amp;lt;number&amp;gt; { ... return new Promise((resolve, reject) =&amp;gt; { resolve(100); });} optional parameter 인자로 전달 받을수도 있고 전달 받지 않을 수도 있다.function fullName(firstName:string, lastName?:string) {} // lasName을 전달 받을 수 있고 전달 받지 않을 수 있다.fullName(&#39;minsoo&#39;, &#39;kim&#39;);fullName(&#39;minsoo&#39;);default 인자를 전달 받지 않을 때 기본 값으로 설정해 놓을 수 있다.function printMessage(message:string = &#39;default message&#39;) {};printMessage(); // default message Rest parameter 전달하는 인자 개수의 제한이 없고 동일한 타입의 데이터를 인자로 전달할 때 사용할 수 있다.function addNumbers(...numbers: number[]): number { return numbers.reduce((acc, curr) =&amp;gt; acc + curr);};addNumbers(1, 2);addNumbers(1, 2, 3, 4);Tuple 고정된 서로 다른 타입을 할당할 때 사용한다. 사용을 권장하지 않음. interface, type alias, class 대체해서 사용하는 것이 좋음.let anything: [string, number];anything = [&#39;abc&#39;, 123];anything[0];anything[1];const [string, number] = anything;Type Alias 아래와 같이 Text , Num , Person 라는 타입을 정의할 수 있다.type Text = string;const name: Text = &#39;ellie&#39;;const const address: Text = &#39;korea&#39;;type Num = number;type Person = { name: string; age: number;};const person: Person = { name: &#39;kim rae young&#39;, age: 33,}; 아래와 같이 Name에 ‘name’이라는 타입을 정의한다면 ‘name’만 할당할 수 있다.type Name = &#39;name&#39;;let name = Name;name = &#39;name&#39;Union type 아래의 Size 타입과 같이 다중의 타입을 말한다. printSize 함수의 인자는 Size 타입을 인자로 전달받기 때문에 25 | 26 | 27 | 28의 값만 전달받을 수 있다.type Size = 25 | 26 | 27 | 28;function printSize(size: Size) { console.log(size);};printSize(25);printSize(27);Intersction type : &amp;amp; 타입 하나로 묶을 수 있다.type A = { name : string; age: number;};type B = { feeling : () =&amp;gt; void;}function anything(AB: A &amp;amp; B) {};anything({ name: &#39;taeback&#39;, age: 1, feeling: () =&amp;gt; {}});Enum enum은 다른 값을 할당할 수 있어 가능한 enum을 사용하지 않는것이 좋다. 가능한 union 타입을 사용한지만 , 네이티브 프로그래밍에는 enum을 사용한다.enum Aphabet { A, B, C, D, ...}// enum에 따로 값을 정하지 않으면 0 부터 하나씩 증가한다.// 1을 할당 해주면 1부터 증가하고 문자열도 할당할 수 있다. let b = Aphabet.B;b = 10console.log(b); // 10// 위와 같이 다른 값을 할당할 수 있어 가능한 enum을 사용하지 않는 것이 좋다." }, { "title": "타입스크립트란?", "url": "/posts/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/", "categories": "Typescript", "tags": "typescript", "date": "2021-02-03 00:00:00 +0900", "snippet": "타입스크립트는 마이크로소프트에서 개발하고 관리하는 오픈소스 프로그래밍 언어로 자바스크립트를 베이스로 하는 javascript를 감싸는 자바스크립트의 상위 집합(superset of javascript) 언어이다.브라우저나 운영체제 상관없이 javascript가 동작하는 곳 어디든 대체해서 사용할 수 있다.타입스트립트 장점1. 컴파일 단계에서 오류를 발견할 수 있다.(정적 타입)자바스크립트는 프로그래밍이 동작할 때 타입이 결정되는 언어이다.자바스크립트는 동적 타입이 특징으로 프로그래밍이 동작할 때 실시간으로 타입이 결정이 되어서 사용자가 애플리케이션을 사용하면서 에러가 터질 수 있다. 반면 타입스크립트는 타입이 정적으로 결정되기 때문에 코딩을 할 때 즉각적으로 타입 에러를 받아볼 수 있다. 이런한 이유로 개발할 때 에러에 대한 검사를 받을 수 있어 조금 더 안정적이고 확장이 쉬운 소프트 웨어를 만들 수 있다.예를 들어, 동적 타입의 경우 아래와 같이 변수를 선언하면서 문자열을 할당했다가 이후 숫자를 할당할 수 있다.동적 타입(dynamically type)let name = &#39;sara&#39;;name = 158;또 아래와 같이 숫자를 더하는 함수를 기대했는데 문자열을 인자로 넣어도 함수는 에러를 나타내지 않고 동작한다.function sum (a, b) { return a + b};sum(5, 1); // 6sum(&#39;hello&#39;, &#39;world&#39;); // &#39;helloworld&#39;정적 타입의 경우 아래와 같이 변수를 선언할 때 타입을 명시해서 작성을 해야 하고 한번 결정된 타입을 바꿀 수 없다. 다른 타입을 할당하면 에러를 나타낸다.정적 타입(statically type)let name:string = &#39;sara&#39;;name = 158; // error또 아래와 같이 숫자를 리턴하는 함수를 만들었다면 인자와 리턴되는 값 모두 타입을 명시하면 인자와 리턴되는 값 모두 숫자여야만 한다. 정적 타입은 예상치 못한 오류를 방지할 수 있다. function sum (a:number, b:number): number { return a + b }; sum(&#39;hello&#39;, &#39;world&#39;); // error2. 컴파일링브라우저나 운영체제 상관없이 javscript가 동작하는 곳 어디든 대체해서 사용할 수 있는 이유는 타입스크립트 코드를 컴파일 해서 자바스크립트 코드로 변환하기 때문이다.컴파일링 할 때 어떤 버전으로 컴파일 할 건지 설정할 수 있어서 모든 브라우저에서 동작 가능한 웹 애플리케이션을 만들 수 있고 최신 문법으로 코딩을 할 수 있다.3. oop 객체 지향프로그래밍이 가능하다.객체 위주로 모듈성 있는 코드를 작성할 수 있다.작업환경 설정" }, { "title": "Git 기본", "url": "/posts/Git-%EA%B8%B0%EB%B3%B8/", "categories": "Git", "tags": "Git", "date": "2020-11-22 00:00:00 +0900", "snippet": "계정 연결git config --global user.name &#39;kimraeyoung&#39;git config --global user.email &#39;&amp;lt;깃헙 계정 이메일&amp;gt;&#39;alias alias 명령어를 짧게 사용하도록 설정하는 법. git config --glboal alias.co checkout (checkout 을 co로 변경)git config --global alias.br branch (branch를 br로 변경)git config --global alias.ci commit (commit을 ci로 변경)git config --global alias.st status (status를 st로 변경)git config --global alias.lg &quot;log --graph --abbrev-commit --decorate --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --all&quot; alias 및 현재 Git 설정 상태 보기: git config --listGitHub 온라인 코드 저장소로 무료로 사용할 수 있다. 단 비공개 저장소의 경우 3명 이상이 사용할 경우 유료이다.cd ~mkdir git-exercd git-exerecho &quot;파일 생성&quot; &amp;gt;&amp;gt; README.mdgit initgit add README.mdgit commit -m &quot;initial commit&quot;git remote add origin &amp;lt;원격 저장소&amp;gt;git push -u origin masterclone 아래 명령어로 원격 저장소에 있는 코드를 내려받는다. git clone &amp;lt;원격 저장소&amp;gt;git LifecycleUntracked git이 대상 파일일 추적하지 않는 상태이다. git add &amp;lt;파일명&amp;gt; 명령어를 사용했을 때 git의 관리 대상으로 파일을 추적한다. git이 관리하는 파일을 삭제하면 Untracked가 된다.Staged 코드를 저장해도 좋은 상태로 commit이 가능한 상태이다. Untracked, Modified 상태인 파일을 add 하면 Staged상태가 된다.Unmodified git에 코드 저장이 완료된 상태이다. Staged상태에서 commit 을 하면 Unmodified가 된다.Modified Git으로 관리되고 있던 코드를 수정하여 변경이 일어난 상태로 Unmodified 상태인 파일을 수정하면 Modified가 된다. 수정된 파일은 다시 Stage(add) 상태가 되어야 commit을 할 수 있다.기본 git status 파일들의 상태를 확인할 수 있다. git이 추적하는 파일과 아닌 파일들을 확인할 수 있다. git add 추적되지 않은 파일들을 commit 할 수 있는 Stage 상태로 만들어준다. git add . 추적되지 않는 모든 파일을 Staged 상태로 변경한다. git add &amp;lt;파일명&amp;gt; 해당 파일만 Staged 상태로 변경한다. git commit Staged 상태의 파일을 저장한다. Staged 상태가 Unmodified 상태로 변경된다. SHA-1 알고리즘을 적용한 해시값을 키로 생성한다. 커밋 단위로 히스토리가 쌓인다. 실무에서 한 작업 (기능, 피처) 단위로 한 커밋을 권장한다. git commit -m &quot;메모 ..&quot; 메모와 함께 파일을 저장한다. git commit -a add를 같이한다. git commit -am -a와 -m을 합친 것이다. git commit —amend 만약 Stage에 아무것도 없다면 - 마지막 커밋을 수정한다. - Stage 상태의 파일들과 같이 커밋 된다. 만약 commit 이후 작없을 하지 않은 상태에서는 커밋 메세지만 수정된다. git log 히스토리를 조회할 수 있는 명령어로 해당 브랜치의 커밋 한 로그를 확인할 수 있다. log를 볼 줄 알아야 develop, release, hotfix 브랜치가 난무할 때 merge 방향이나 순서를 이해할 수 있다. git branch 커밋 사이를 이동할 수 있는 어떤 포인터 같은 것. 하나의 작업 공간 단위이다. branch들을 확인할 수 있다. 브랜치 생성 : git branch &amp;lt;브랜치 네임&amp;gt; 브랜치 삭제 : git branch -D &amp;lt;브랜치 네임&amp;gt; 리모트의 브랜치 삭제 : git push origin —delete &amp;lt;브랜치 네임&amp;gt; 삭제된 리모트 브랜치를 로컬에도 반영할 때 : git fetch -p 리모트 브랜치 확인할 때 : git branch -r git checkout &amp;lt;브랜치 네임&amp;gt;or&amp;lt;해시 키 값&amp;gt; &amp;lt;브랜치 네임&amp;gt; 은 해당 브랜치로 이동한다. &amp;lt;해시 키 값&amp;gt;은 원하는 커밋 상태로 이동할 수 있다. 브랜치 생성과 이동 동시에 할 때 git checkout -b &amp;lt;브랜치 네임&amp;gt; 을 사용한다. git push 원격 저장소에 저장할 수 있다. clone 한 리모트 저장소에 쓰기 권한이 있어야 한다. 같은 브랜치로 여러 명이 받아서 작업 후 누군가 push를 했다면 다른 사람은 push가 되지 않는다. 다른 사람이 작한 것 을 가져와서 합친 후 (merge or rebase) 후 push 할 수 있다. push가 거절당했을 때 로컬 브랜치의 파일들을 원격 저장소에 덮어씌우려고 한다면? git push origin master —force 위험한 명령어로 혼자 작업하던 feature 브랜치에서만 사용해야 한다. git pull clone한 서버에서 데이터를 가져와 자동으로 현재 잡헙하는 코드와 merge한다. 충돌이 났을 때 아래와 같이 merge가 되지 않는다. cat &amp;lt;파일명&amp;gt;으로 변경된 파일을 확인할 수 있다. 이렇게 충돌이 날 경우 변경된 부분을 수정 후 다시 커밋 후 push 해야 한다. git merge —abort - 이전에 하려던 git pull이 취소된다. git fetch clone 한 서버에서 데이터를 가져오지만 merge하지 않는다. git log —all 확인하면 아래와 같이 데이터는 가져오지만 merge 되어있지 않다. stash 작업 중 다른 브랜치로 변경해야 할 때 커밋은 하고 싶지 않은 경우 잡업 하던 파일을 임시로 저장할 수 있다. stack처럼 작동한다. (마지막에 작업하던것이 가장 먼저 나오는 구조) git stash git stash list git pop git drop merge 현재 브랜치와 다른 브랜치를 합쳐서 코드를 합친다. 두 갈래로 나온 변경 커밋들이 합쳐서 새로운 커밋을 만든다. 다른 브랜치에서 같은 파일을 변경했을 경우 confilct가 난다. reabase merge와 같이 코드를 합치지만 rebase 한 브랜치의 커밋이 이전 상태로 생성된다. git rebase --abort 원래 상태로 되돌아간다. git rebase -i @~3 ( @는 HEAD 이고 3은 최근 커밋 한 3개를 말한다. ) 최근 3개의 커밋을 하나로 합칠 수 있다. conflict가 날 경우 충돌이 나는 파일을 변경한 뒤 add 만 한 후 git rebase —continue 를 실행한다. reset 이전 커밋 상태로 되돌아간다. show 커밋 상태를 보여준다. 한 커밋 이전 ex) HEAD~, HEAD^, @~, @^ (HEAD === @) @~2 (2 커밋 이전) git reset --soft &amp;lt;commit hash or @~3&amp;gt; commit 명령어만 되돌리고 Stage 상태가 된다. git reset --mixed &amp;lt;commit hash&amp;gt; commit 명령어로 되돌리고 Modified 상태가 된다. git reset --hard &amp;lt;commit hash&amp;gt; commit 명령도 되돌리고 UnModified 상태가 된다. 디렉토리 상태도 되돌려버리기 때문에 복구가 불가능한다. git branch 전략git flowmaster git init을 하면 생기는 태초의 브랜치이다. 배포 브랜치이다.develop 보통 작업할 때 기준이 되는 브랜치이다. develop 기준으로 배포하며 테스트 한다. 생성 위치는 mater이다.hotfix 서비스에 문제가 생기거나 버그를 고쳐 배포해야할 때 사용한다. master브랜치와 develop브랜치 두 곳 다 merge해 준다. 생성위치 mater이다.feature 기능을 만드는 브랜치이다. 현업에서는 develop 브랜치에서 따온 freature 브랜치 특정 기능을 개발한 후 풀리퀘스트를 보내서 코드리뷰를 받은 후 develop 브랜치에 merge 한다. 생성위치 develop이다.release 새로운 기능들을 추가하여 배포하기 위한 브랜치이다. master 와 develop 브랜치에 merge한다. 생성위치 develop이다." }, { "title": "react-native 안드로이드 이미지가 깨져 보일 때(png)", "url": "/posts/react-native-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9D%B4%EB%AF%B8%EC%A7%80%EA%B0%80%EA%B9%A8%EC%A0%B8%EB%B3%B4%EC%9D%BC%EB%95%8C/", "categories": "React Native", "tags": "react-native 안드로이드 이미지 깨져 보일 때", "date": "2020-11-18 00:00:00 +0900", "snippet": "아이콘 이미지를 넣을 때 png 파일 사용 중 ios에서는 깨짐 현상 없이 정상적으로 렌더 되었지만 안드로이드에서는 흐릿하게 이미지가 깨져 보였다.구글링 결과 React Native에서 사용하고 있는 fresco에서 android 상 해상도 보다 큰 이미지를 자동으로 줄이는 기능이 있어 이미지가 깨져 보인다고 한다.해결방법 jpg로 사용한다. Fresco를 커스텀 한 버전을 사용한다. react-native-fresco react-native-fast-image 이미지를 사용한다. FastImage세 가지 방법 중 이미 프로젝트에 FastImage(react-native-fast-image)를 사용하고 있어 세 번 째 방법으로 문제를 해결했다.import FastImage from &#39;react-native-fast-image&#39;;import * as style from &#39;./style&#39;; // 스타일 컴포넌트 사용const CategoryBar = () =&amp;gt; { ... return ( ... &amp;lt;style.Item&amp;gt; &amp;lt;FastImage /* ... */ source={images.fLogoWhite} /* ... */ /&amp;gt; &amp;lt;/style.Item&amp;gt; )};export default CategoryBar;" }, { "title": "react-native-webview(Domain undefined Error code -1)", "url": "/posts/react-native-webview-Domain-undefinedErrorcode-1/", "categories": "React Native", "tags": "react native domain error", "date": "2020-10-26 00:00:00 +0900", "snippet": "Android 버전이 tagetSdkVersion 28 이상일 경우 부터는 WebView에 일반적인 텍스트로 http:// URL 접근이 막혔다.해결방법AndroidManifest.xml 에서 application 의 usesClearTextTraffic 속성을 true로 바꿔주어 텍스트 URL 을 무조건 허용하게했다.&amp;lt;manifest ...&amp;gt; ... &amp;lt;application ... android:usesCleartextTraffic=&quot;true&quot;&amp;gt;" }, { "title": "react-native-webview에서 외부 앱 실행 (pg)", "url": "/posts/react-native-webview-%EC%99%B8%EB%B6%80%EC%95%B1%EC%8B%A4%ED%96%89/", "categories": "React Native", "tags": "react-native-webview 외부 앱 실행(pg)", "date": "2020-10-20 00:00:00 +0900", "snippet": "react-native-webview를 이용하여 모바일 web으로 이동한 후 앱 카드 결제 시 앱 카드 앱 호출이 되지 않는 이슈가 발생하였다. 구글링을 통해 마침내 외부 앱을 실행했다.. 정확한 원리와 이해를 완벽히 한 건 아니지만 내가 시도했던 것들을 아래에 정리해 보았다.android안드로이드의 경우 intent 호출을 할 수 없기 때문에 라이브러리를 설치해 intent 호출을 할 수 있었다.install react-native-send-intentnpm install react-native-send-intent --savenpx react-native link react-native-send-intent android/setting.gradle ... include &#39;:RNSendIntentModule&#39;, &#39;:app&#39; project(&#39;:RNSendIntentModule&#39;).projectDir = new File(rootProject.projectDir, &#39;../node_modules/react-native-send-intent/android&#39;) android/app/build.gradle ... dependencies { ... compile project(&#39;:RNSendIntentModule&#39;) }구글링을 통해 here1 를 발견했다.댓글에 나와있던 here2 와 같이 아래 파일을 수정해서 openAppWithUri함수를 만들었다. node_modules/react-native-send-intent/android/src/main/java/com/burnweb/rnsendintent/RNSendIntentModule.java 에 아래 소수를 추가한다. ... @ReactMethod public void openAppWithUri(String intentUri, ReadableMap extras, final Promise promise) { try { Intent intent = Intent.parseUri(intentUri, Intent.URI_INTENT_SCHEME); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); Intent existPackage = this.reactContext.getPackageManager().getLaunchIntentForPackage(intent.getPackage()); if (existPackage != null) { this.reactContext.startActivity(intent); } else { Intent marketIntent = new Intent(Intent.ACTION_VIEW); marketIntent.setData(Uri.parse(&quot;market://details?id=&quot;+intent.getPackage())); marketIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); this.reactContext.startActivity(marketIntent); } promise.resolve(true); } catch (Exception e) { promise.resolve(false); } } ... node_modules/react-native-send-intent/index.js 에 아래 소스를 추가한다. openAppWithUri(intentUri, extras) { return RNSendIntentAndroid.openAppWithUri(intentUri, extras || {}); }## ios — AppDelegate.m 파일에 아래의 소스를 추가한다. 참고 문서 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url options:(NSDictionary&amp;lt;UIApplicationOpenURLOptionsKey,id&amp;gt; *)options { return [RCTLinkingManager application:application openURL:url options:options]; } - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation]; } - (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler { return [RCTLinkingManager application:application continueUserActivity:userActivity restorationHandler:restorationHandler]; }iOS 9 버전부터 LSApplicationQueriesSchemes라는 Info 항목에 URL scheme을 사용해서 외부 앱을 열 경우, 특별한 제한이 없던 기존 방식에서 화이트리스트에 등록된 scheme만 열 수 있도록 보안 정책이 강화되어 화이트리스트에 등록되지 않은 경우, 웹뷰에서는 무조건 차단하는 정책으로 변경되었기 때문에 info.plist 파일에 LSApplicationQueriesSchemes에 스키마를 추가한다. &amp;lt;key&amp;gt;LSApplicationQueriesSchemes&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;lguthepay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;lguthepay-xpay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;smartxpay-transfer://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;nhappcash-acp:// &amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;SmartBank2WB://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;hdcardappcardansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;smhyundaiansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;shinhan-sr-ansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;smshinhanansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;kb-acp://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;mpocket.online.ansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;ansimclickscard://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;tswansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;ansimclickipcollect://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;vguardstart://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;samsungpay&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;scardcertiapp://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;lottesmartpay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;lpayapp://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;lotteappcard://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;payco://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;cloudpay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;hanamopmoasign://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;hanawalletmembers://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;nhappcardansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;nhallonepayansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;nonghyupcardansimclick://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;citispay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;citicardappkr://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;ispmobile://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;uppay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;shinsegaeeasypayment://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;wooripay://&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;kftc-bankpay&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;itms-apps&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;citimobileapp&amp;lt;/string&amp;gt; &amp;lt;string&amp;gt;kakaotalk&amp;lt;/string&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;NSAppTransportSecurity&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;NSAllowsArbitraryLoads&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;NSExceptionDomains&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;localhost&amp;lt;/key&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;NSExceptionAllowsInsecureHTTPLoads&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/dict&amp;gt;react-native-webviewRN 웹뷰 내에서 onShouldStartLoadWithRequest 메소드를 이용해서 url이 바뀔 때마다 감지해서 http, https 외의 외부 앱 호출일 경우 android 경우 react-native-send-intent 등 외부 라이브러리를 이용해 intent를 호출하고 ios의 경우 Linking.openUrl을 사용해 intent를 호출한다. originWhitelist 참고문서 onShouldStartLoadWithRequest 참고 문서 originWhitelist={[&#39;*&#39;]} 를 넣고 onShouldStartLoadWithRequest 로 핸들링한다. import {WebView} from &#39;react-native-webview&#39;; import {Linking, Platform} from &#39;react-native&#39;; ... const onShouldStartLoadWithRequest = () =&amp;gt; { if ( event.url.startsWith(&#39;http://&#39;) || event.url.startsWith(&#39;https://&#39;) || event.url.startsWith(&#39;about:blank&#39;) ) { return true; } if (Platform.OS === &#39;android&#39;) { SendIntentAndroid.openAppWithUri(event.url) .then(isOpened =&amp;gt; { if (!isOpened) { alert(&#39;앱 실행에 실패했습니다&#39;); } }) .catch(err =&amp;gt; { console.log(err); }); } else { Linking.openURL(event.url).catch(err =&amp;gt; { alert( &#39;앱 실행에 실패했습니다. 설치가 되어있지 않은 경우 설치하기 버튼을 눌러주세요.&#39;, ); }); return false; } }; ... &amp;lt;WebView ref={webview} originWhitelist={[&#39;*&#39;]} source={/* url ... */} onLoadStart={() =&amp;gt; onLoadStart()} onLoadProgress={({nativeEvent}) =&amp;gt; onLoadProgress(nativeEvent)} onLoad={() =&amp;gt; onLoadEnd()} onNavigationStateChange={navState =&amp;gt; onChangeNavState(navState)} onShouldStartLoadWithRequest={event =&amp;gt; { return onShouldStartLoadWithRequest(event); }} onMessage={event =&amp;gt; onMessage(event)} /&amp;gt;" }, { "title": "react-native-codepush 배포하기", "url": "/posts/react-native-codepush/", "categories": "React Native", "tags": "react-native, react-native-codepush", "date": "2020-09-21 00:00:00 +0900", "snippet": "앱 업데이트를 할 때 각 스토어의 심사를 받아야 하기 때문에 최소 하루 이상 시간이 소요된다. Microsoft에서 서비스하고 있는 Code Push를 사용하면 스토어의 심사를 받지 않고 빠르게 앱을 업데이트할 수 있다.하지만 일부 기능이 추가되어 빌드를 해야 하는 경우를 제외한다.간단하게 javascript 나 스타일같이 간단한 수정을 했을 때 바로 적용할 수 있다.setUpsudo npm install -g code-push-cli //code-push-cli을 설치 npm install -g appcenter-cli npm install --save react-native-code-pushnpx react-native link react-native-code-push codepush에 앱을 등록하기 위해 아래 명령어를 실행하고 Visual Studio App Center에 로그인한다. code-push register 로그인 후 발급된 인증 토큰을 복사한 뒤 터미널에 붙여넣기한다. Android와 iOS 서비스를 등록한다. code-push app add &amp;lt;myAppName-android&amp;gt; android react-native code-push app add &amp;lt;myAppName-ios&amp;gt; ios react-native 서비스 등록이 완료되면 Deployment Production Key 와 Staging Key 확인할 수 있다. Deployment Key 확인하려면 아래 명령어를 실행한다. code-push deployment ls &amp;lt;myAppName-android&amp;gt; -k code-push deployment ls &amp;lt;myAppName-ios&amp;gt; -k 등록한 서비스 확인 명령어 code-push app list ios 설정 ios setUp Add App Center install npm install appcenter appcenter-analytics appcenter-crashes --save-exact ios/AppCenter-Comfig.plist 파일에 아래 소스를 추가한다. &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;https://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt; &amp;lt;plist version=&quot;1.0&quot;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;AppSecret&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;--appcenter key--&amp;lt;/string&amp;gt; &amp;lt;/dict&amp;gt; &amp;lt;/plist&amp;gt; /ios/&amp;lt;app-name&amp;gt;/AppDelegate.m 파일에 아래 소스를 추가한다. #import &amp;lt;CodePush/CodePush.h&amp;gt; #import &amp;lt;AppCenterReactNative.h&amp;gt; #import &amp;lt;AppCenterReactNativeAnalytics.h&amp;gt; #import &amp;lt;AppCenterReactNativeCrashes.h&amp;gt; - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge { #if DEBUG return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil]; #else return [CodePush bundleURL]; #endif } /ios/&amp;lt;app-name&amp;gt;/info.plistCodePushDeploymentKey에 CodePush에서 받은 Staging Deployment Key을 입력한다. &amp;lt;key&amp;gt;CodePushDeploymentKey&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;--Staging Deployment Key--&amp;lt;/string&amp;gt; cd ios &amp;amp;&amp;amp; pod install &amp;amp;&amp;amp; cd ..android 설정 안드로이드 setUp Add App Center install. npm install appcenter appcenter-analytics appcenter-crashes --save-exact android/app/src/main/assets/appcenter-config.json { &quot;app_secret&quot;: &quot;&amp;lt;app_secret_value&amp;gt;&quot; } android/settings.gradle 파일에 아래 소스를 추가한다. include &#39;:app&#39;, &#39;:react-native-code-push&#39; project(&#39;:react-native-code-push&#39;).projectDir = new File(rootProject.projectDir, &#39;../node_modules/react-native-code-push/android/app&#39;) android/app/build.gradle 파일 가장 아래에 아래 소스를 추가한다.(Cannot add task ‘bundleDebugJsAndAssets’ as a task with that name already exists. 에러가 발생하면 이미 같은 작업의 이름이 있다는 것. 파일을 확인한 후 중복되어 있는 (예: apply from: “../../node_modules/react-native/react.gradle”) 부분을 제거한다. apply from: &quot;../../node_modules/react-native/react.gradle&quot; apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot; android/app/src/main/java/&amp;lt;app-name&amp;gt;/MainApplication.java ReactNativeHost 설정에 getJSBundleFile() 추가한다. import com.microsoft.codepush.react.CodePush; @Override protected String getJSBundleFile() { return CodePush.getJSBundleFile(); } android/app/src/main/res/values/strings.xml 파일에 CodePushDeploymentKey를 추가한다. &amp;lt;resources&amp;gt; &amp;lt;string name=&quot;app_name&quot;&amp;gt;fetching-android&amp;lt;/string&amp;gt; &amp;lt;string moduleConfig=&quot;true&quot; name=&quot;CodePushDeploymentKey&quot;&amp;gt;--Staging Deployment Key--&amp;lt;/string&amp;gt; &amp;lt;/resources&amp;gt; multi-deployment-testing-android android/app/build.gradle 에 아래 소스를 추가하고 android/app/src/main/res/values/strings.xml 파일에 CodePushDeploymentKey를 삭제한다. android { ... buildTypes { debug { ... // Note: CodePush updates should not be tested in Debug mode as they are overriden by the RN packager. However, because CodePush checks for updates in all modes, we must supply a key. resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, &#39;&quot;&quot;&#39; ... } releaseStaging { ... resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, &#39;&quot;&amp;lt;INSERT_STAGING_KEY&amp;gt;&quot;&#39; // Note: It is a good idea to provide matchingFallbacks for the new buildType you create to prevent build issues // Add the following line if not already there matchingFallbacks = [&#39;release&#39;] ... } release { ... resValue &quot;string&quot;, &quot;CodePushDeploymentKey&quot;, &#39;&quot;&amp;lt;INSERT_PRODUCTION_KEY&amp;gt;&quot;&#39; ... } } ... }code-push 업데이트 앱 센터code-push release-react &amp;lt;appName&amp;gt; &amp;lt;platform&amp;gt; -d Staging [or Production] android appcenter codepush release-react -a &amp;lt;project.co.kr&amp;gt;/&amp;lt;projectname-android&amp;gt; -d Staging [or Production] ios appcenter codepush release-react -a &amp;lt;project.co.kr&amp;gt;/&amp;lt;projectname-ios&amp;gt; -d Staging [or Production] Production으로 배포할 경우 실 배포 앱에 적용된다. 이렇게 배포가 성공했는데 실 배포 앱에 적용되지 않는다면 배포된 파일의 appcenter key 와 staging key와 현재 적용하고 있는 파일의 appcenter key 와 staging key가 일치하는지 확인해 봐야 한다." }, { "title": "react-native의 간단한 기본 원리 및 개발 환경", "url": "/posts/ReactNative-%EA%B8%B0%EB%B3%B8%EC%9B%90%EB%A6%AC%EB%B0%8F%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/", "categories": "React Native", "tags": "react-native", "date": "2020-09-13 00:00:00 +0900", "snippet": " 리액트 네이티브는 페이스북에서 만든 오픈소스 모바일 응용 프로그램으로 네이티브 앱 개발을 위한 자바스크립트 프레임워크이다. 크로스 플랫폼으로 하나의 코드 개발로 ios와 android에서 동일하게 동작시킬 수 있다. 자바스크립트를 기본 언어로 쓰기 때문에 자바나 코틀린 언어에 의존하는 안드로이드 네이티브 앱 혹은 swift 언어에 의존하는 ios 네이티브 앱 개발 보다 진입장벽이 낮고 쉽다는 장점을 가지고 있다.react native 기본 원리 ios 경우 object-c 혹은 swift 코드를 ios 플랫폼에 타켓팅해주는 컴파일러가 존재하고 android의 경우 자바나 코틀린을 android 플랫폼에 타켓팅해주는 컴파일러가 존재한다. 자바스크립트로 짜여진 리액트 네이티브의 JS bundle 은 JS thread에 의해 실행한다. 각 플랫폼의 앱 실행은 native thread에 의해 실행되는데 JS thread와 Native thread와 직접적으로 커뮤니케이션을 할 수 없는데 중간에 react-native에서 제공되는 brideg에 의해 상호작용을 하게 된다.Expo CLI vs React Native CLIExpo CLI react-native로 앱을 제작할 때 자주 사용하는 네이티브 기능들을 패키지로 묶어서 제공한다.그래서 개발 환경 구축과 실제 개발이 쉽고 편하다. 하지만 OS Layer와 직접 상호 작용이 불가능하다. (Java, Kotlin, obj-c, swift로 추가 코딩이 불가하다.) expo에서 제공해 주는 모듈만 가져다 사용할 수 있기 때문에 개발 관점에서의 자유도가 낮다.React Native CLI 초기 개발 환경 구축 및 실제 앱 개발 시 설정 시간이 다소 걸리지만 OS Layer와 직접 상호작용이 가능하다. (Java, Kotlin, obj-c, swift로 추가 코딩이 가능하다.) Native 기능에 접근이 가능하기 때문에 원하는 언어로 추가 코딩이 가능하기 때문에 필요한 기능이 있는 경우 모듈을 직접 만들어서 사용할 수 있어 개발 관점에서의 자유도가 높다." }, { "title": "다른 도메인간 쿠키 전송하기(cors-credentials) (react &amp; node.js)", "url": "/posts/%EB%8B%A4%EB%A5%B8%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B0%84%EC%BF%A0%ED%82%A4%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0/", "categories": "CS", "tags": "cors-credentials", "date": "2020-07-05 00:00:00 +0900", "snippet": "프론트엔드 netlify 배포 (cors)프론트엔드와 백엔드의 도메인 주소가 다른 경우 cors 문제가 생기는데 로컬에서 이를 해결하기 위해 프론트 쪽에서 proxy 설정을 해두어 cors 문제를 해결했었다.하지만 netlify에 배포한 뒤에는 cors 에러가 아닌 계속 404에러가 나타났다. 다시 로컬로 돌아가서 확인해보니 또 cors 문제없이 서버와의 통신이 가능했다. cors 에러가 아닌 404에러 메시지 나타나기 때문에 해결하는 데 굉장히 어려움이 있었다. 로컬에서는 아무 이상 없이 돌아갔기 때문에 왜 이런 에러가 나타나는지 이해할 수 없었다. 어쨌든 서버와 통신을 할 수 없었고 proxy 설정이 뭔가 잘못돼서 404에러는 나타내는 게 아닌가 생각했다. 이리저리 많은 블로그나 문서에 나와있는 여러 가지 방법을 모두 시도해보았지만 해결되지 않았다. 그렇게 계속 시도한 끝에 스택오버플로우에서 netlify에서는 cors 문제를 서버에서 해결해 주어야 한다는 글을 보았다. 개인 프로젝트를 진행했었을 때에도 netlify로 프론트엔드쪽 배포를 했었는데 cors 문제를 서버에서 해결했었다. 이번 프로젝트의 경우 proxy로 cors 문제를 해결했었고 proxy로 문제를 해결하고 싶었는데 결국 netlify에서 배포 후 서버와 통신하기 위해서는 cors 문제를 서버에서 해결해 주어야 했었다.다른 도메인간 쿠키 전송하기(credentials)서버에서 cors 문제를 해결한 후 프론트와 서버 간의 쿠키 전송이 되지 않아 로그인을 할 수 없었다. 요청과 응답에 헤더를 설정해 준 뒤 쿠키 전송에 성공하였다. 서버에서 origin을 허용하고 클라이언트와 서버 모두 Credentials를 활성화해야 한다.server Access-Control-Allow-Origin 요청을 보내는 프론트 주소와 응답을 보내는 백엔드 주소가 다른경우 cors에러가 발생한다. 이 때, 서버에서 응답메시지로 Access-Control-Allow-Origin에 허용할 클라이언트 주소 또는 * 을 적어 주어야 에러가 나지 않는다. * 을 명시해 줄 경우 모든 요청을 보내는 모든 프론트 주소를 허용한다는 의미이다. 이렇게 *을 명시해줄 경우 모든 요청을 허용하기 때문에 보안에 취약해질 수 있다. 다른 도메인간 쿠키를 전송하기 위해서 Access-Control-Allow-Origin에 * (와일드 카드)를 사용할 수 없다. 허용할 origin 또는 true를 명시해야한다. Access-Control-Allow-Credentials은 true로 설정한다. res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:3000&quot;);res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;POST, PUT, GET, DELETE&#39;);res.header(&quot;Access-Control-Allow-Credentials&quot;, true);res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;X-Requested-With, Content-Type&#39;);- cors 미들웨어를 사용할 경우app.use(&#39;/user&#39;, cors({ orgin: &amp;lt;허용할 클라이언트 주소&amp;gt;, // or true methods: [&#39;POST&#39;, &#39;GET&#39;, &#39;PUT&#39;, &#39;DELETE&#39;, &#39;PATCH&#39;], // 허용할 메소드 credictials: true, allowedHeaders: [&#39;Origin&#39;, &#39;X-Requested-With&#39;, &#39;Content-Type&#39;, &#39;Accept&#39;, &#39;Authorization&#39;],}), userRouter);client클라이언트에서도 요청을 보낼 때, 헤더에 Credentials를 활성화해야한다. 클라이언트에서 헤더에 Credentials 활성화를 한 후 요청을 보내는 데이 아래의 세 가지 방법을 사용했었다.다른 블로그에서는 첫 번째나 두번째 방법으로 해결이 되었지만 나 같은 경우 마지막 방법으로 해결이 되었다. 세 가지모두 같은 의미이긴 한데.. 디폴트로 설정한 후 해결이 되었다. axios.create({withCredentials: true})import axios from &#39;axios&#39;;const api = axios.create({ withCredentials: true});api.get(&#39;/&#39;) .then((res) =&amp;gt; { console.log(res) }) .catch(err =&amp;gt; console.error(err)) withCredentials: true 를 설정한 후 요청을 보낸다.import axios from &#39;axios&#39;;axios.get(&#39;/&#39;, { withCredentials: true }) .then((res) =&amp;gt; { console.log(res) }) .catch(err =&amp;gt; console.error(err)) default로 설정한다. (index.js 에 한번만 설정해 주어도 된다.)import axios from &#39;axios&#39;;axios.defaults.withCredentials = true;" }, { "title": "mySQL", "url": "/posts/mySQL/", "categories": "Backend", "tags": "mySQL", "date": "2020-06-23 00:00:00 +0900", "snippet": " 관계형 데이터베이스는 현재 가장 많이 사용되고 있는 데이터베이스의 한 종류이다.관계형 데이터 베이스는 엑셀 시트처럼 행과 열이 있는 표 그래프 형태를 가지고 있다. 하나의 데이터베이스 안에 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다. mySQL은 관계형 데이터베이스 중 하나이다. 관계형 데이터베이스의 테이블(table)은 다음 그림처럼 구성된다.mysql 설치local 아래 폴더로 이동한다. cd /usr/local/mysql/bin 루트 유저로 사용하겠다는 명령어를 입력한 후 패스워드를 입력한다. ./mysql -uroot -p RDS mysql install brew install mysql 데이터베이스 연결 mysql -u &amp;lt;MASTERUSER&amp;gt; --host 엔드포인트 -P &amp;lt;DBPORT&amp;gt; -p 패스워드 입력 데이터베이스 리스트 보기 show databases; 데이터베이스 생성하기 CREATE DATABASE &amp;lt;YOUR DATABASE&amp;gt; default CHARACTER SET UTF8; 데이터베이스 사용하기 use &amp;lt;DATABASE NAME&amp;gt; 테이블 리스트 확인 show tables; datebase 생성 데이터를 생성한다.CREATE DATABASE &amp;lt;data name&amp;gt;; SHOW DATABASES; 로 데이터베이스가 생성되었는지 확인할 수 있다.SHOW DATABASES; 해당 데이터를 사용하겠다는 명령어를 입력한다.USE &amp;lt;data name&amp;gt;;CRUDtable 생성 NOT NULL (정보가 없으면 안 된다.) AUTO_INCREMENT (id 값은 자동으로 증가한다.) VARCHAR(사이즈 값) - 사이즈 값만큼의 문자가 저장된다. 아래와 같이 여러 종류의 Data Type이 있다. PRIMARY KEY(id)는 중복을 방지한다. CREATE TABLE topic( -&amp;gt; id INT(11) NOT NULL AUTO_INCREMENT, -&amp;gt; title VARCHAR(100) NOT NULL, -&amp;gt; description TEXT NULL, -&amp;gt; created DATETIME NOT NULL, -&amp;gt; author VARCHAR(15) NULL, -&amp;gt; profile VARCHAR(200) NULL -&amp;gt; PRIMARY KEY(id)); 테이블 삭제DROP TABLE &amp;lt;table name&amp;gt;; 생성한 테이블을 확인할 수 있다. SHOW TABLES; table 이름을 바꾸는 방법은 아래와 같다. RENAME TABLE &amp;lt;databaseName&amp;gt; TO &amp;lt;renameDatabaseName&amp;gt;; table 구조 확인하기 DESC &amp;lt;table name&amp;gt;; you must reset your password 비밀번호 바꾸는 방법 SET PASSWORD = PASSWORD(&#39;your password&#39;); Createinsert 칼럼 만들기 INSERT INTO 뒤에 &amp;lt;해당 테이블 네임&amp;gt;과 (괄호 안에 칼럼들을 넣어주고) VALUE (칼럼 순서에 맞는 값들을 넣어준다.) INSERT INTO &amp;lt;table name&amp;gt; (title, description, created, author, profile) VALUES(&#39;mysql&#39;, &#39;my sql is ....&#39;, NOW(), &#39;raeyoung&#39;, &#39;developer&#39;); ReadSelect 테이블 전체 확인하기 SELECT * FROM &amp;lt; tableName &amp;gt;; 원하는 부분만 데이터 확인하기 SELECT &amp;lt;칼럼(id)&amp;gt;, &amp;lt;칼럼(title)&amp;gt; FROM &amp;lt;tableName(topic)&amp;gt; WHERE &amp;lt;칼럼(author)&amp;gt;=&amp;lt;값(&#39;raeyoung&#39;)&amp;gt;; 원하는 부분 정렬한 데이터 확인하기 id 큰 숫자 순으로 정렬 SELECT &amp;lt;컬럼(id)&amp;gt;, &amp;lt;컬럼(title)&amp;gt; FROM &amp;lt;tableName(topic)&amp;gt; WHERE &amp;lt;칼럼(author)&amp;gt;=&amp;lt;값(&#39;raeyoung&#39;)&amp;gt; ORDER BY id DESC; limit 부분만큼 데이터 확인하기 SELECT &amp;lt;칼럼(id)&amp;gt;, &amp;lt;칼럼(title)&amp;gt; FROM &amp;lt;tableName(topic)&amp;gt; WHERE &amp;lt;칼럼(author)&amp;gt;=&amp;lt;값(&#39;raeyoung&#39;)&amp;gt; ORDER BY id DESC LIMIT &amp;lt;limit값(2)&amp;gt;; 테이블 구조 확인하기 DESC &amp;lt;table name&amp;gt;; Update WHERE 문을 꼭 사용해야 한다.UPDATE &amp;lt;tableName&amp;gt; SET &amp;lt;칼럼이름&amp;gt;=&amp;lt;수정할 값&amp;gt;, &amp;lt;칼럼이름&amp;gt;=&amp;lt;수정할 값&amp;gt; WHERE id=2;Delete WHERE 문을 꼭 사용해야 한다.DELETE FORM topic WHERE id=2;join 각 테이블마다 중복되는 데이터들의 관계를 이어준다.SELECT * FROM &amp;lt;table1 name&amp;gt; LEFT JOIN &amp;lt;table2 name&amp;gt; ON &amp;lt;table1.id&amp;gt; = &amp;lt;table.exmpleId&amp;gt;;" }, { "title": "redux 사용하기 (Redux Persist)", "url": "/posts/Redux&Redux-Persist/", "categories": "Frontend", "tags": "Redux", "date": "2020-06-19 00:00:00 +0900", "snippet": "react만 사용해도 애플리케이션을 개발할 수 있다. 하지만, 규모가 커지고 구조가 복잡해질수록 컴포넌트의 상태(state) prop으로 넘겨주고 관리하는 일이 귀찮아진다. 리액트로 상태를 관리하면 부모 자식 관계처럼 위에서 아래로 또는 아래에서 위로 상태(state)를 props로 넘겨주어야 한다. 하지만 아래 그림과 같이 redux를 사용하게 되면 위아래로 상태 값을 넘겨주지 않고도 상태 값들을 저장하고 받아올 수 있다.출처install redux와 react와 연결해 줄 react-redux를 설치한다.npm i reduxt react-redux redux-logger src/reducers/index.js -&amp;gt; root store index 파일에 combineReducers로 reducer를 하나로 모아준다. import { combineReducers } from &#39;redux&#39;; // 흩어진 reducer 들을 하나로 모아준다.import user from &#39;./user&#39;;import post from &#39;./post&#39;;const rootReducer = combineReducers({ user, post,});export default rootReducer;action src/acitons/action.jsimport * as type from &#39;./types&#39;;export const loginAcion = (userData) =&amp;gt; { return { type: type.LOGIN_USER, userData, isLoggedIn: true };};export const logoutAction = () =&amp;gt; { return { type: type.LOGOUT_USER, userData: {}, isLoggedIn: false };};type src/action/type.jsexport const LOGIN_USER = &#39;LOGIN_USER&#39;; // 액션의 이름export const LOGOUT_USER = &#39;LOGOUT_USER&#39;;reducer src/reducers/user.jsimport * as type from &#39;../actions/types&#39;;const initialState = { user: {}, isLoggedIn: false};const user = (state = initialState, action) =&amp;gt; { switch (action.type) { case (type.LOGIN_USER): return { ...state, user: action.userData, isLoggedIn: action.isLoggedIn } case (type.LOGOUT_USER): return { ...state, user: action.userData, isLoggedIn: action.isLoggedIn } default: return state }};export default user;store createStore에 루트 리듀서를 전달한다. applyMiddleware에 미들웨어 형태의 리덕스 개발 도구를 추가한다. redux-logger로 store의 변화 값을 확인할 수 있다. src/store/store.jsimport { createStore, applyMiddleware } from &#39;redux&#39;;import logger from &#39;redux-logger&#39;;import reducers from &#39;../reducers&#39;;export default createStore(reducers, applyMiddleware(logger)); 아래와 같이 콘솔 창에서 이전 값과 action 그리고 변화된 값까지 확인할 수 있다. 이렇게 변화된 값들을 확인할 수 있어, 디버깅하는데 큰 도움이 된다.컴포넌트와 스토어 연결 애플리케이션에 사용된 모든 컴포넌트에서 스토어를 사용할 수 있게 스토어를 &amp;lt;Provider&amp;gt; 에 주입한다. src/index.js import reducer from &#39;../reducers&#39;; // reducer를 불러온다.import { Provider } from &#39;react-redux&#39;; //redux store와 react를 연결해준다.import { createStore } from &#39;redux&#39;;import App from &#39;./App&#39;;const App = ({store}) =&amp;gt; { &amp;lt;Provider store={store}&amp;gt; // 자식컴포넌트들도 redux store state에 접근할 수 있다. &amp;lt;App /&amp;gt; &amp;lt;/Provider&amp;gt;}export default App;const store = createStore(reducer, initialState)Redux Persist를 사용하여 앱을 종료해도 지속되는 Store 만들기redux는 상태 관리에 효율적이지만 리덕스 상태 앱을 종료하거나 브라우저를 새로 고침만 해도 저장되어 있던 모든 상태들이 없어진다. Redux Persist 라이브러리를 사용하면 마치 캐시 기능과 같이 상태 값을 지속적으로 저장한다. 참고자료 install npm install redux-persist src/store/store.jsimport { createStore, applyMiddleware } from &#39;redux&#39;;import logger from &#39;redux-logger&#39;;import { persistReducer } from &#39;redux-persist&#39;;import storage from &#39;redux-persist/lib/storage&#39;;import reducers from &#39;../reducers&#39;;const persistConfig = { key: &#39;root&#39;, storage};const enhancedReducer = persistReducer(persistConfig, reducers);**export default createStore(enhancedReducer, applyMiddleware(logger)); index.jsimport React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import { Provider } from &#39;react-redux&#39;;import store from &quot;./store/store&quot;;import { persistStore } from &#39;redux-persist&#39;;import { PersistGate } from &#39;redux-persist/integration/react&#39;;import App from &#39;./App&#39;;const persistor = persistStore(store);ReactDOM.render( &amp;lt;Provider store={store}&amp;gt; &amp;lt;PersistGate loading={null} persistor={persistor}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/PersistGate&amp;gt; &amp;lt;/Provider&amp;gt;, document.querySelector(&#39;#root&#39;));" }, { "title": "HOC(Higher Oder Component) Auth 인증체크", "url": "/posts/HOC-Auth-%EC%9D%B8%EC%A6%9D%EC%B2%B4%ED%81%AC/", "categories": "Frontend", "tags": "HOC, higher order component", "date": "2020-06-18 00:00:00 +0900", "snippet": "페이지 중 누구나 진입이 가능한 페이지와, 로그인한 회원만 진입이 가능한 페이지 또는 로그인 한 회원은 진입하지 못하는 페이지 (예: login 페이지) , 관리자만 진입이 가능한 페이지가 있다.이러한 인증 들은 어떻게 할 수 있을까?이런 경우 higher-order component function 을 사용하면 된다.Auth (HOC) higher-order component function 은 컴포넌트를 인자로 받아 새로운 컴포넌트를 리턴하는 함수이다. 서버에 응답받은 유저의 상태 정보(로그인이 되어있는지, 로그인이 되어있지 않은지 관리자인지)에 따라 Auth function에 인자의 값을 다르게 줌으로써 페이지들의 인증을 컨트롤할 수 있다. src/hoc/auth.js에 아래와 같이 파일을 만든다.import React, { useEffect } from &#39;react&#39;;import { useSelector } from &#39;react-redux&#39;;export default (SpecialComponent, option, adminRoute=null) =&amp;gt; { /* 예) option: null -&amp;gt; 누구나 출입이 가능한 페이지 (home) true -&amp;gt; 로그인한 유저만 출입이 가능한 페이지 false -&amp;gt; 로그인한 유저는 출입이 불가능한 페이지 */ const AuthenticateCheck = (props) =&amp;gt; { const isLoggedIn = useSelector(state =&amp;gt; state.user.isLoggedIn); useEffect(() =&amp;gt; { if (!isLoggedIn &amp;amp;&amp;amp; option) { props.history.push(&#39;/login&#39;); } }, []); return ( &amp;lt;SpecialComponent /&amp;gt; ) }; return AuthenticateCheck;}; 위에서 작성한 auth.js 파일을 불러온다. 아래와 같이 src/App.js에서 hoc에 component와 option에 인자를 넣어 페이지들의 접근 권한을 컨트롤한다. SpecialComponent = componen t option = boolean adminRoute = boolean import React from &#39;react&#39;;import { BrowserRouter, Route, Switch } from &#39;react-router-dom&#39;;import { useSelector } from &#39;react-redux&#39;;import Auth from &#39;./hoc/auth&#39;;import Header from &#39;./components/Header/Header&#39;;import MainPage from &#39;./components/MainPage/MainPage&#39;;import LoginPage from &#39;./containers/LoginPage/LoginPage&#39;;import SignUpPage from &#39;./components/SignUpPage/SignUpPage&#39;;import AdminPage from &#39;./components/AdminPage/AdminPage&#39;;import Menu from &#39;./components/Menu/Menu&#39;;function App() { const isLoggedIn = useSelector(state =&amp;gt; state.user.isLoggedIn); return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;BrowserRouter&amp;gt; &amp;lt;Header /&amp;gt; {isLoggedIn &amp;amp;&amp;amp; &amp;lt;Menu /&amp;gt;} &amp;lt;Switch&amp;gt; &amp;lt;Route path=&#39;/&#39; exact component={Auth(MainPage, null)} /&amp;gt; &amp;lt;Route path=&#39;/login&#39; component={Auth(LoginPage, false)} /&amp;gt; &amp;lt;Route path=&#39;/signUp&#39; component={Auth(SignUpPage, false)} /&amp;gt; /* 예) 관리자 페이지 세 번째 인자에 true라는 옵션을 주어 관리자만 들어갈 수 있는 페이지를 인증할 수 있다. */ &amp;lt;Route path=&#39;/admin&#39; component={Auth(AdminPage, true, true)} /&amp;gt; &amp;lt;/Switch&amp;gt; &amp;lt;/BrowserRouter&amp;gt; &amp;lt;/div&amp;gt; );};export default App;" }, { "title": "http CORS (Cross Origin Resource Sharing)", "url": "/posts/http-CORS/", "categories": "Frontend", "tags": "CORS, SOP", "date": "2020-06-11 00:00:00 +0900", "snippet": "프론트엔드 서버와 백엔드 서버를 따로 구성하는 경우가 많다.이렇게 출처(origins)가 다른 경우 보안상 문제로 요청을 주고받을 수 없는 것이 웹 브라우저 기본 정책이다. 하지만 CORS (Cross Origin Resource Sharing)라는 방식을 통하면 서로 다른 출처라도 요청을 주고받을 것이 가능하다.SOP (Same Origin Policy)웹 애플리케이션 중요한 보안 개념 중 하나가 동일 출처 정책이다.동일 출처란 같은 도메인, 프로토콜, 포트를 의미한다.같은 도메인, 같은 포트에 있는 리소스를 불러올 때는 문제가 없지만 다른 출처의 리소스를 요청하는 것을 제한하는 보안 방식이다.참고자료 - poiemaweb.comCORS (Cross Origin Resource Sharing)서로 다른 출처(origin)로 상호작용을 하기 위해 서버와 클라이언트가 정해진 헤더를 통해 서로 요청이나 응답에 반응할지 결정하는 방식이다.serverHTTP 응답 헤더 Access-Control-Allow-Origin : * 혹은 Access-Control-Allow-Origin: 허용하고자 하는 도메인을 설정해 준다.expressconst express = require(&#39;express&#39;)const cors = require(&#39;cors&#39;)const app = express() app.use(cors()) // cors(*)client서버에서 서버로 보내는 요청은 CORS 에러가 적용되지 않는다.프록시 서버를 추가로 만들어서 클라이언트에서 우리가 새로 만든 프록시 서버로 요청을 보내고 프록시 서버에서 원하는 타깃 서버에 요청을 보내면 브라우저가 개입되지 않았기 때문에 CORS 에러를 해결할 수 있다.프록시 서버 : 브라우저와 서버를 통신하는 과정 중간에서 정보교환을 도와주는 중간 서버이다.( 브라우저 - 프록시 서버 - 서버 )프록시 서버는 헤더를 추가하거나 요청을 허용/거부하는 역할을 중간에서 해준다. (Access-Control-Allow-Origin : *의 헤더를 담아 응답해 준다.)출처 - 위키백과reactsrc/setupProxy.jsconst { createProxyMiddleware } = require(&#39;http-proxy-middleware&#39;);module.exports = function (app) { app.use( &#39;/api&#39;, createProxyMiddleware({ target: `${process.env.REACT_APP_FETCHING_SERVER_URL}`, changeOrigin: true, }) );};참고 자료" }, { "title": "https와 SSL인증 (다른 컴퓨터에서 로그인이 되지 않을 때)&amp; Page Not Found on Netlify with React Router", "url": "/posts/https%EC%99%80-SSL%EC%9D%B8%EC%A6%9D/", "categories": "CS", "tags": "https와 SSL인증", "date": "2020-05-06 00:00:00 +0900", "snippet": "react로 소셜 로그인을 구현했는데 배포를 하고 나서 내 컴퓨터가 아닌 다른 컴퓨터 또는 핸드폰으로는 로그인 후 다음 화면으로 넘어가지 않는다.내 컴퓨터로만 작업을 하다 보니 그런 문제가 있는지도 몰랐었다.왜 다른 컴퓨터나 핸드폰에선 로그인이 정상적으로 작동되지 않는 걸까 …또 배포 후 다른 문제점은 url 주소창에서 url을 직접 작성해 라우터 이동을 하게 되면 페이지를 찾을 수 없다고 한다.이 두 가지 문제를 해결하고 부족한 부분을 보안해야겠다.Page Not Found on Netlify with React Router링크나 버튼을 이용했을 때 라우터 이동 시 문제가 없지만 url 주소창에 직접 url을 작성해 라우터를 이동하거나 엔터만 쳐서 리다이렉트만 시켜도 아래와 같이 Page Not Found가 된다.React는 싱글 페이지 응용 프로그램으로 모든 웹 페이지가 동일한 위치 ( index.html)에서 제공된다. 서버에서 프런트(예:ejs, pug)를 제공하는 경우 각 페이지마다 별도의 파일이 렌더 되지만 React의 경우 경로가 작동하게 하려면 _redirects를 만들어야 한다._redirects 파일은 요청하는 주소 또는 경로를 기반으로 클라이언트를 리디렉션 할 위치를 Netlify에 알려주는 파일로 React 라우터는 모든 라우팅을 처리하므로 Netlify가 모든 요청을 index.html로 리디렉션하도록해야한다 .(출처)public폴더에 _redirects파일을 만든 뒤 아래와 같이 모든 리다이렉션에 200을 줄 수 있도록 아래와 같이 작성 후 모든 다시 배포를 하니 해결되었다./* /index.html 200https와 SSL인증SSL 인증서는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하고, SSL 통신에 사용할 공개키를 클라이언트에 제공한다.악수 -&amp;gt; 전송 -&amp;gt; 세션종료Handshake(악수)실제 데이터를 주고받기 전에 클라이언트와 서버는 일종의 Handshake(인사)를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 믿을만한지, 또 상대방과 데이터를 주고받기 위해서는 어떤 방법을 사용해야 하는지를 파악한다.SSL 방식을 이용해서 통신을 하는 브라우저와 서버는 핸드 셰이크를 하는데, 이때 SSL 인증서를 주고받는다.세션(전송)실제로 서버와 클라이언트가 데이터를 주고받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다. 서로 암호를 복호화 한 후 데이터를 전송한다.세션 종료데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이때 통신에서 사용한 대칭키인 세션 카를 폐기한다.(출처-생활코딩)netlify로 클라이언트를 배포하면 기본적으로 https로 배포되기 때문에 SSL 인증서가 제공된다. 이후 aws에서 https를 설정하면서 SSL 인증서를 다시 제공받았고 이전 SSL 인증서와 이후 제공받은 SSL 인증서가 다르다.클라이언트와 서버가 서로 Handshake(악수)를 할 때 SSL 인증서를 통해서 신뢰할 수 있음을 판단하는데 이때 클라이언트가 와 서버의 Handshake(악수)에서 문제가 생겼던 것이다.도메인 DNS 관리에 들어가 CNAME을 aws 인증받은 서버 환경 url을 설정한다. 그리고 netlify에 환경 변수의 url도 CNAME에 설정한 url로 변경해 주고 다시 배포하니 해결되었다." }, { "title": "프론트엔드(netlify) 백엔드(AWS Elastic Beanstalk) 배포", "url": "/posts/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C(netlify)-%EB%B0%B1%EC%97%94%EB%93%9C(AWS-Elastic-Beanstalk)-%EB%B0%B0%ED%8F%AC/", "categories": "CS", "tags": "netlify, AWS Elastic Beanstalk", "date": "2020-04-30 00:00:00 +0900", "snippet": "처음으로 풀스택으로 프로젝트를 시작했다. 혼자 해결해 나가는 부분에서 삽질을 많이 했다. 아직도 미흡한 점이 많지만 일단 배포를 먼저 해보기로 결정했다. 고치고 싶은 부분이라면 끝도 없이 많기에 .. 프론트엔드는 react와 redux를 사용해서 작업했고 netlify 배포 서비스를 사용했다.백엔드는 node.js express 와 mongoDB를 사용해서 작업했고 AWS Elastic Beanstalk 를 사용해서 배포하였다.배포하는 과정에서 주의할 점을 정리해 보았다.프론트엔드 배포(netlify)netlify는 프론트엔드 스택으로만 구성된 정적 애플리케이션을 배포하는 용도로 최적화된 서비스다.배포하는 방법은 정말 간단하다. 프로젝트를 github 계정에 연결하고 레파지토리를 선택한 후 배포할 브랜치를 선택해 주면 된다.또 프로젝트를 수정하고 커밋 한 다음 다시 푸시 하면 자동으로 build 상태가 되고trigger deploy 버튼만 눌러주면 된다.여기서 주의할 점은 .env 파일에 작성했던 환경 변수를 모두 넣어 주어야 한다! 또 백엔드를 배포했다면 개발과정에서 사용했던 (예:localhost:5000) 이 부분도 모두 백엔드 server url로 바꿔준다.백엔드 배포(AWS Elastic Beanstalk)EC2를 조금 더 쉽게 배포할 수 있다는 Elastic Beanstalk을 사용해서 배포했다. 기본적인 설정이 되어있기 때문에 조금 더 간편하다고 한다.프론트엔드를 netlify로 배포하면 https로 기본 배포 되고 EB에서는 http를 기본으로 구성하기 때문에 Mixed Content 에러가 발생한다. http -&amp;gt; https 로 요청은 가능해도 https -&amp;gt; http 요청은 안된다. 여기서 https를 사용하지 않는 사이트로 요청을 보낸다는 것은 비 암호화된 구간으로 데이터를 전송시켜서 정보 유출의 우려가 있기 때문이다. 프론트에서 정보를 수신하기 위해서는 EB로 배포된 서버를 http에서 https로 바꿔야 하는데 그 과정에서 굉장히 애를 먹었다.기본 설치 과정 콘솔에 로그인한 뒤 지역을 설정한다 (예: 서울) 새 애플리케이션 생성을 한다. 기본 구성에 플랫폼을 node.js로 설정한다. brew를 이용해서 aws cli 설치 (mac os) brew install awscliaws --version (aws cli 설치 확인) brew를 이용해서 EB cli 설치 (mac os) brew install awsebcli eb --version (eb cli 설치 확인) 내 보안 자격 증명 에 들어간다. 액세스 키(액세스 키 ID 및 비밀 액세스 키)를 생성하고 파일을 다운로드한다. (이 정보는 절대 github이나 클라우드 등 어디에도 올라가서는 안된다) 최상위 루트에서 .aws 폴더를 만들고 credentials 파일 안에 액세스 키(액세스 키 ID 및 비밀 액세스 키)를 아래와 같이 작성한 뒤 저장한다.**~/.aws/credentials ** [default]aws_access_key_id=AKIAIOSFODNN7EXAMPLEaws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY eb init 으로 초기화를 하고 지역을 선택 하면 만들어놓은 애플리케이션 중 하나를 선택한다. 다음으로 do you wish to continue with CodeCommit? (y/n) 가 뜨는데 이부분은 잘 모르기 때문에 n을 하고 넘어가고 eb deploy 명령어로 배포를 한다. 프로젝트 폴더를 확인해보면 .elasticbeenstalk 이라는 폴더가 생겨있다. eb init(지역선택: 서울) 10(애플리케이션 선택: ktx-gogo) 1do you wish to continue with CodeCommit? (y/n) neb deploy 생성한 뒤 상태가 초록색으로 떠야 하는데 빨간색으로 뜬다면?? (degraed) 구성 -&amp;gt; 소프트웨어를 편집한다. node 명령을 작성한다.(예: npm start (개발과정에서 nodemon으로 되어있는 경우 에러가 발생할 수 있으니 node로 명령어가 되어있는지 확인한다.)) 환경 속성에 환경 변수를 작성한다.(.env 파일 안의 환경 변수들을 작성한다.)EB https클라이언트 https로 요청이 들어왔을 때 https로 요청을 받아 http로 통신한 데이터를 https로 응답해 주는 방법이다. 기본적으로 로드 밸런스 편집 기능이 없는 상태로 구성되기 때문에 로드 밸런스를 수정하기 위해 용량을 편집한다. 환경 유형을 로드밸런스로 선택한 뒤 적용한다. 인스턴스를 최대 2개 이상으로 설정한다. 로드밸런스를 편집한다. 리스너를 추가한다. 프로토콜 https 포트는 443 인스턴트 포트는 80으로 설정한다. ssl 인증서를 선택한 뒤 적용한다. (ssl인증서 발급) DNS 관리에 CNAME ssl 인증서에서 받은 키와 값을 넣어준다. " }, { "title": "mongoose", "url": "/posts/mongoose/", "categories": "Backend", "tags": "MongoDB, mongoose", "date": "2020-03-05 00:00:00 +0900", "snippet": "Mongoose는 Node.js와 MongoDB를 연결해 주는 역할을 한다. Node.js에서 MongoDB를 사용할 수 있게 해주는 라이브러리이다.노드 패키지 매니저 npm 또는 yarn을 사용해서 설치할 수 있다.npm install mongoose --save yarn add mongoose// -- save로 packge.json에 저장한다.디렉토리 구조nodeJs├── models/│ └── &amp;lt;filename&amp;gt;.js // schema작성├── routes/│ └── &amp;lt;filename&amp;gt;.js├── app.js└── pakage.jsonmongoDB와 연결해주기mongoose 모듈을 require 하고 connect method로 MongoDB에 연결한다. connect 인자로 두 개가 들어가는데 첫 번째 인자는 mongodb://localhost/&amp;lt;db-name&amp;gt; 가 들어가고 두 번째 인자로 {useNewUrlParser: true}를 적지 않으면 deprecatedError 가 발생한다.app.js에서 작성한다.const mongoose = require(&#39;mongoose&#39;); mongoose.connect(&#39;mongodb://localhost/test&#39;, {useNewUrlParser: true});Schema &amp;amp; ModelSchemaMongoDB는 NoSQL 비 관계형 데이터베이스 특성상 컬렉션에 들어갈 수 있는 데이터에 제약이 없다. 하지만 데이터를 조회할 때 조건을 명시하기 어렵기 때문에 스키마(Schema)를 만들고, 그 스키마(Schema)에 따라 문서 객체를 저장한다. 스키마(Schema)는 document의 구조가 어떤 방식으로 들어와야 하는지 알려주는 역할을 한다. 스키마(Schema)에서 사용되는 SchemaType은 String, Number, Date, Buffer, Boolean, Mixed, ObjectId, Array, Decimal128,Map 의 종류가 있다. 참고: [SchemaType] (https://mongoosejs.com/docs/schematypes.html)modelmodel은 데이터베이스에서 데이터를 읽고, 생성하고, 수정하는프로그래밍 인터페이스를 정의한다.mongoose.model(&amp;lt;collection name&amp;gt; , &amp;lt;shema&amp;gt;); schema는 models/&amp;lt;filename&amp;gt;.js 에 작성한다.아래와 같이 들어와야할 데이터의 형태를 정한다.// &amp;lt;shemaname&amp;gt; = Strawberryconst mongoose = require(&#39;mongoose&#39;);const Schema = mongoose.Schema;const StrawberrySchema = new Schema({ name: String, age: Number, weight: Number})/* const StrawberrySchema = new mongoose.Schema({ name: String, age: Number, weight: Number});*/module.exports = mongoose.model(&#39;Strawberry&#39;, StrawberrySchema); save() 참고 : Model.prototype.save()const Strawberry = require(&#39;파일경로&#39;); // 스키마에서 작성했던 모델을 가져온다.async function create (req, res, next) { await new Strawberry(`&amp;lt;저장할 데이터&amp;gt;`).save().then(function(db){ console.log(db) // 저장한 데이터 })}/* 아래는 바닐라 코딩 과제중 작성한 코드 일부분이다.exports.create = async function (req, res, next) { await new Article(req.body).save().then(function (db) { res.status(201) res.send({ result: &#39;ok&#39;, article: db }) });};*/update()여러 가지 method 중 findOneAndUpdate를 사용해서 update를 구현하였다.findOneAndUpdate는 첫 번째 인자로 {_id: &amp;lt;삭제할 데이터 id&amp;gt;와 두 번째 인자로 &amp;lt;update할 데이터&amp;gt;를 인자로 주고 세 번째 인자로 콜백 함수를 실행한다. 참고 : Model.findOneAndUpdate()const Strawberry = require(&#39;파일경로&#39;);function update () { Strawberry.findOneAndUpdate({_id: `&amp;lt;삭제할 데이터 id&amp;gt;` , `&amp;lt;update할 데이터&amp;gt;`, function(err,db){ if err throw err; console.log(db) // update한 데이터 })}/* 아래는 바닐라 코딩 과제중 작성한 코드 일부분이다.exports.update = async function (req, res, next) { Article.findOneAndUpdate({ _id: req.params.article_id }, req.body, function (err, db) { if (err) { res.status(400); res.send({ error: &#39;invalid article id&#39; }) } else { res.status(200); res.send({ result: &#39;ok&#39;, article: db }) } })};*/remove()여러 가지 method 중 findByIdAndRemove()를 사용해서 데이터 삭제를 구현하였다. findByIdAndRemove는 &amp;lt;삭제할 데이터 id&amp;gt;만 넣어주면 된다. 두 번째 인자로콜백 함수를 실행한다. 참고 : Model.findByIdAndRemove()const Strawberry = require(&#39;파일경로&#39;);function funtion delete (req, res, next) { Strawberry.findByIdAndRemove(`&amp;lt;삭제할 데이터 id&amp;gt;`, function (err) { if(err) throw err; }}/* 아래는 바닐라 코딩 과제중 작성한 코드 일부분이다.exports.delete = async function (req, res, next) { Article.findByIdAndRemove(req.params.article_id, function (err) { if (err) { res.status(400) res.send({ error: &#39;invalid article id&#39; }) } else { res.status(200) res.send({ result: &#39;ok&#39; }) } })};*/" }, { "title": "shallow copy vs deep copy", "url": "/posts/AllowCopy-vs-DeepCopy/", "categories": "Javascript", "tags": "Javascript", "date": "2020-02-29 00:00:00 +0900", "snippet": "String, Boolean, Number 같은 원시형 값을 복사했을 경우 순수한 값이 복사되고 독립적인 값이 저장된다. 하지만 Reference형 객체 복사에는 크게 얕은 복제(shallow copy)와 깊은 복제(deep copy)로 분류된다.Reference복사아래와 같이 새로운 변수obj2에 obj를 할당했다. 그리고 obj에 obj.c = 3 값을 추가하고 obj2를 확인해보면 obj와 같은 값을 가지고 있다.const obj = { a:1, b:2}const obj2 = objconsole.log(obj === obj2) // trueobj.c = 3console.log(obj2) // {a: 1, b: 2, c: 3}이처럼 주소를 참조하고 있다는 것은 서로 다른 변수이지만 같은 객체를 바라보고 있다.shallow copy?얕은 복사란 새로운 객체에 원본 객체의 프로퍼티 값을 복사하지만 프로퍼티의 값이 객체 형태라면 프로퍼티 객체의 주소를 복사한다.Object.assign () const obj = { a:&#39;hello&#39;, b: { c:&#39;world&#39; } } const objCopy = Object.assign({}, obj); console.log(obj === objCopy) // false obj.b.c = &#39;shallow copy&#39; console.log(obj); console.log(objCopy);위와 같이 obj.b.c의 값에 할당했지만 objCopy.b.c의 값도 변한 것을 확인할 수 있다.deep copy깊은 복사는 원본 객체를 완전히 복사한다.주소를 복사하지 않고 완전히 다른 것을 의미한다.JSON const obj = { a:&#39;hello&#39;, b: { c:&#39;world&#39; } } const copyObj = JSON.parse(JSON.stringify(obj)) obj.b.c = &#39;deep copy&#39;; console.log(obj); // {a: &quot;hello&quot;, b: {c: &quot;deep copy&quot;}} console.log(copyObj); // {a: &quot;hello&quot;, b: {c: &quot;world&quot;}}stringify 메소드는 function일 경우 아래와 같이 undefined로 처리되므로 주의해서 사용해야한다. const obj = { a:&#39;hello&#39;, b: { c:function(){} } } const copyObj = JSON.parse(JSON.stringify(obj)) console.log(obj) // {a: &quot;hello&quot;, b: {c: f()}} console.log(copyObj) // {a: &quot;hello&quot;, b: {}}" }, { "title": "React LifeCycle API 생명주기", "url": "/posts/ReactLifeCycle-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/", "categories": "Frontend", "tags": "React, LifeCycle", "date": "2020-02-27 00:00:00 +0900", "snippet": "LifeCycle API 생명주기출처-LifeCycleMountingcomponent가 브라우저에 나타날 때 constrctor : component가 만들어지는 과정에서가장 먼저 실행되는 함수로 초기 state를 설정한다.import React from &#39;react&#39;; class App extends React.Component { constructor(props) { super(props); this.state = { a:&#39;1&#39;, } } render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App;아래와 같이 생략하여 사용할 수 있다.import React, { Component } from &#39;react&#39;; class App extends Component { state = { a: &#39;1&#39;, } render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App; getDerivedStateFromProps : 주로 props로 받은 값을 state로 동기화를 시켜주고 싶을 때 사용한다. render : class component에 필수로 있어야 한다. jsx를 사용하여 사용자가 작성한 엘리먼트들을 DOM 노드로 변환해준다. Boolean 값이나 null은 화면에 아무것도 표시되지 않는다.import React from &#39;react&#39;; class App extends React.Component { constructor(props) { super(props); this.state = { a:&#39;1&#39;, b: null } } render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt; a : {this.state.a} &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; b : {this.state.b} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App; componentDidMount: 브라우저에 나타나는 시점에 어떤 작업을 할 때 명시해 준다. render가 실행될 때 실행된다. 예를 들어, 컴포넌트에서 필요한 데이터를 요청하거나 DOM에 관련된 작업을 할 때 사용한다.import React from &quot;react&quot;;class App extends React.Component { constructor(props) { super(props); console.log(&#39;constructor&#39;); } componentDidMount() { // 컴포넌트 첫 렌더링 후 호출, 비동기 요청을 이곳에서 많이 한다. console.log(&#39;componentDidMount&#39;); console.log(this.Div.getBoundingClientRect()); // DOM의 크기나 위치정보를 상세히 알 수 있다. } render() { console.log(&#39;render&#39;); return( &amp;lt;div ref={ref =&amp;gt; this.Div = ref}&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App; 콘솔을 확인해 보면 constroctor -&amp;gt; render -&amp;gt; componentDidMount 순서대로 실행된다. render가 실행된 후 가장 먼저 실행되는 함수이다.Updatingcomponent의 state나 props가 업데이트될 때 shouldComponentUpdate : 컴포넌트가 업데이트가 되는 성능을 최적화 시키고 싶을 때 사용한다.컴포넌트 업데이트 직전에 호출되며 Boolean 값으로 virtual DOM에 그릴지 말지 결정한다. shouldComponentUpdate를 따로 구현하지 않는다면 기본적으로 true로 설정된다.부모 컴포넌트가 렌더링이 되면 자식 컴포트들도 렌더링이 되기 때문에 성능을 최적화 시키고 싶을 때 사용되며 특정 조건에 따라 렌더링을 막아줄 수 있다.import React from &#39;react&#39;; class App extends React.Component { constructor(props) { super(props); this.state = { count: 1, } } handleClick= () =&amp;gt; { this.setState({ count: this.state.count+1 }); } shouldComponentUpdate(nextProps, nextState) { if(nextState.count === 5) return false; return true; } render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt;{this.state.count}&amp;lt;/div&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;클릭&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App; 아래와 같이 nextState.count === 5 특정 조건에 false가 되었을 때 state의 값만 바뀌고 렌더링은 되지 않았다.그다음 클릭을 했을 때 조건이 true가 되면서 5가 skip 되고 6이 렌더링 된다. componentDidUpdate : component가 업데이트되었을 때 호출되는 함수이다.예를 들어, 이전의 state와 현재 state가 바뀌었을 때 어떠한 작업을 하고 싶을 때 사용한다.import React from &#39;react&#39;;class App extends React.Component { constructor(props) { super(props); this.state = { count: 1, } } handleClick= () =&amp;gt; { this.setState({ count: this.state.count+1 }) } componentDidUpdate(prevProps, prevState) { if(this.state.count !== prevState.count) { console.log(&#39;componentDidUpdate&#39;) } } render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt;{this.state.count}&amp;lt;/div&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;클릭&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; ) }}export default App; 아래와 같이 이전 state와 다음 state 값이 다를 때마다 componentDidUpdate 함수가 호출된다.Unmounting브라우저에서 사라질 때 componenetWillUnmount : 컴포넌트가 사라지는 과정에서 호출되는 함수이다. 컴포넌트가 사라지기 직전, 비동기 요청 정리를 많이 한다. import React from &#39;react&#39;;import MyComponent from &quot;./MyComponent&quot;;class App extends React.Component {state = { count: 1};handleClick = () =&amp;gt; { this.setState({ count: this.state.count + 1 });};render() { return ( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; hello world &amp;lt;/h1&amp;gt; {this.state.count &amp;lt; 2 &amp;amp;&amp;amp; &amp;lt;MyComponent /&amp;gt;} &amp;lt;div&amp;gt;{this.state.count}&amp;lt;/div&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;클릭&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; );}}export default App; import React from &quot;react&quot;;class MyComponent extends React.Component {interval = null;componentDidMount() { this.interval = setInterval(() =&amp;gt; { console.log(&quot;componentDidMount&quot;); }, 1000);}componentWillUnmount() { console.log(&quot;componentWillUnmoun&quot;); clearInterval(this.interval);}render() { return( &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt; My Component &amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; )}}export default MyComponent; 아래와 같이 component가 사라질 때 componentWillUnmount함수가 호출된다. Hooks에서 LifeCyle 대체useEffect useEffect 두 번째 인자로 빈 배열을 넣어 줬을 때 한 번만 호출된다.import React, {useState, useEffect} from &quot;react&quot;;export default function App() { const [count, setCount] = useState(0); useEffect(()=&amp;gt;{ setTimeout(()=&amp;gt;{ setCount(count+1) },1000) },[]) // 빈배열일 때 한번만 호출된다. return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt;{count}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );} 배열 안에 인자를 넣어주면 인자가 변화될 때마다 호출된다.import React, { useState, useEffect } from &quot;react&quot;;export default function App() { const [count, setCount] = useState(0); useEffect(()=&amp;gt;{ const temp = setTimeout(()=&amp;gt;{ setCount(count+1) },1000); },[count]); // 배열에 인자를 넣어주면 인자가 변할 때마다 호출된다. return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt;{count}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );} return을 해주면 함수 호출을 정리한다.import React, { useState, useEffect } from &quot;react&quot;;export default function App() { const [count, setCount] = useState(0); useEffect(()=&amp;gt;{ const temp = setTimeout(()=&amp;gt;{ setCount(count+1); },1000); if(count === 5){ return clearInterval(temp); // 정리 } },[count]) return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt; &amp;lt;div&amp;gt;{count}&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; );}" }, { "title": "Promise / async &amp; await 활용", "url": "/posts/Promise&AsyncAwait-%ED%99%9C%EC%9A%A9/", "categories": "Javascript", "tags": "Promise, async await", "date": "2020-01-27 00:00:00 +0900", "snippet": "배열은 순차적으로 비동기 처리를 하려고 할 때, promise 사용법을 블로깅 하려고 한다.반복문이 있을 경우 promise를 사용하기 어려웠다.예를 들어,function test () { return new Promise(function (resolve, reject) { for(let i=0; i &amp;lt; 5; i++) { setTimeout(function(){ console.log(i); resolve(); }, i*1000); } })}test().then(function(){ console.log(&#39;Done&#39;)});i를 순차적으로 콘솔에 찍은후 then을 실행하여 ‘‘Done’‘를 찍으려고 작성했던 코드이다.하지만 아래와 같이 실행된다.위와 같이 실행되는 이유는 처음 i를 찍은 후 resolve()를 호출했기 때문에 then()을 실행하고 콜 스택에 쌓여있던 함수들이 순차적으로 실행된 것이다. resolve()는 한번 호출되면 바로 then() 을 실행한다.반복문을 순차적으로 실행 후 then을 호출하려면 어떻게 해야 할까?아래는 재귀를 사용해서 구현한 소스이다.const array = [1, 2, 3, 4, 5];let index = 0;test();function test () { const item = array[index] if(array.length === index){ return console.log(&#39;done&#39;); }else{ test2(item).then(test); index++; }}function test2(item){ return new Promise(function (resolve, reject) { setTimeout(function(){ console.log(item); resolve(); },1000) });}async &amp;amp; await 을 활용해 보았다.function delay(item) { return new Promise(function(resolve, reject){ setTimeout(function(){ console.log(item); resolve(); },1000) })}async function test(array) { for(let i=0; i&amp;lt; array.length; i++){ await delay(array[i]); } console.log(&#39;Done&#39;);}test([1,2,3,4,5]); 함수 앞에 async를 붙여 작성하게 되면 비동기 함수가 된다. async 함수는 promise를 반환한다. await은 async 함수 안에서만 사용이 가능하다. await 함수 실행이 모두 완료돼야만 다음 로직을 실행한다." }, { "title": "Bubble Sort / insertion Sort / Merge Sort / Quick Sort", "url": "/posts/BubbleSort-insertionSort-MergeSort-QuickSort/", "categories": "Javascript", "tags": "Sorting Algorithms, Bubble Sort, insertion Sort, Merge Sort, Quick Sort", "date": "2020-01-26 00:00:00 +0900", "snippet": "섞여있는 데이터들을 어떤 기준에 맞춰 정렬하는 여러종류의 정렬 알고리즘이 있다. 기본적으로 자바스크립트에는 데이터를 정렬해주는 sort()라는 메소드가 존재한다.하지만 정렬 알고리즘을 공부하는 이유는 데이터의 양이나 상황에 따라 적합하지 않을 수도 있기 때문에 여러 정렬 알고리즘을 상황에 맞게 잘 선택해서 사용해야 하기 때문이다.대표적인 Bubble sort, insertion sort, merge sort, quick sort 를 알아보자!Bubble Sort버블 정렬은 옆에 있는 요소와 비교해서 자신의 위치를 찾아간다.자신의 위치를 찾아가는 형태가 버블 같다고 해서 버블 정렬이라 한다.버블 정렬은 한번 순회할 때마다, 가장 오른쪽 끝자리부터 순차적으로 자리를 찾아간다. 기본적으로 데이터의 길이만큼 순회해야 모두 자기 자리를 찾아가게 된다.예를 들어, 아래와 같은 배열이 있다.작은 수 부터 큰수로 나열 한다고 했을 때,[4, 6, 3, 2, 8];4, 6을 서로 비교하면 4 &amp;lt; 6 이기 때문에 위치에 변화가 없다.[4, 6, 3, 2, 8];6, 3을 서로 비교하면 6 &amp;gt; 3 이기 때문에 두 요소의 위치가 바뀐다.[4, 3, 6, 2, 8];6, 2를 비교하면 6 &amp;gt; 2이기 때문에 두 요소의 위치가 바뀐다.[4, 3, 2, 6, 8];6, 8을 비교하면 6 &amp;lt; 8이기 때문에 두 요소의 위치에 변화가 없다.[4, 3, 2, 6, 8];위와 같이 배열의 길이만큼 한번 순회했을 때, 가장 오른쪽 끝8부터 가장 먼저 자기 자리를 찾게 된다. 이와 같은 방식으로 요소 각각마다 순회를 해야 하기 때문에 배열의 길이 ²이 되므로 데이터의 양이 많을수록 성능이 떨어진다. 참고 : bubble sortBig-O worst case : O(n²) best case : O(n) (이미 정렬이 되어 있는 경우)장점in place 추가 공간을 사용하지 않고 주어진 공간만 이용해서 정렬한다. 메모리 공간을 절약할 수 있다. 또 초보자들도 이해하기 쉽고 요소들을 탐색하기 용이하다.단점데이터의 양이 많을수록 성능이 떨어진다. 데이터의 길이의 제곱만큼 순회해야 하기 때문에 성능이 좋지 않다. 정렬 중에서도 성능이 좋지 않은 편이다.bubble sort javascript 구현아래 소스는 버블 정렬을 알고리즘 구현한 소스이다.function bubbleSort (array) { let changeNum; for (let i = 0; i &amp;lt; array.length; i++) { for (let j = 0; j &amp;lt; array.length; j++) { if (array[j] &amp;gt; array[j + 1]) { changeNum = array[j]; array[j] = array[j + 1]; array[j + 1] = changeNum; } } } return array;};bubbleSort([4, 6, 3, 2, 8]);가장 오른쪽 끝자리부터 자신의 자리를 찾기 때문에 순회할 때마다 가장 끝자리를 제외하며 순회할 수 있도록 아래와 같이 수정하였다.function bubbleSort (array) { let changeNum; for (let i = 0; i &amp;lt; array.length -1; i++) { for (let j = 0; j &amp;lt; array.length -1 -i; j++) { if (array[j] &amp;gt; array[j + 1]) { changeNum = array[j]; array[j] = array[j + 1]; array[j + 1] = changeNum; } } } return array;};bubbleSort([4, 6, 3, 2, 8]);insertion Sort아래 그림과 같이 삽입 정렬은 왼쪽부터 진행하면서 각각의 요소들을 비교하면서 자기 자기를 찾아간다. 삽입 정렬은 두 번째 자리 숫자부터 뽑아서 그 숫자가 첫 숫자보다 크면 첫 번째 자리 숫자 오른쪽에, 작으면 왼쪽에 넣는다. 세 번째 자리 숫자를 뽑아서 앞의 두 숫자와 크기를 비교해서 알맞은 자리에 넣는다. 이러한 패턴을 반복해서 정렬해 나간다.big-O worst case : O(n²) best case : O(n)장점in place 추가 공간을 사용하지 않고 주어진 공간만 이용해서 정렬한다. 메모리 공간을 절약할 수 있다. 또 초보자들도 이해하기 쉽고 요소들을 탐색하기 용이하다.단점worst case의 경우 버블 정렬과 마찬가지로 O(n²) 으로 성능이 떨어진다.insertion sort javascript 구현function insertionSort (array) { for (let i = 1; i &amp;lt; array.length; i++) { let temp = array[i]; let j = i - 1; while (j &amp;gt;= 0 &amp;amp;&amp;amp; array[j] &amp;gt; temp) { array[j + 1] = array[j]; j--; } array[j + 1] = temp; } return array;};insertionSort([5, 6, 1, 2, 4, 3]);Merge Sort버블 정렬이나 삽입 정렬보다는 복잡하지만 성능이 좋은 정렬 방법 중 하나이다. 배열을 반씩 잘라 나가면서 하나의 요소로 쪼갠 다음 다시 병합시키면서 정렬해 나간다. 참고 : merge sortbig - O병합 정렬은 분할과 병합 단계로 나뉘는데 분할 단계는 시간 복잡도에 포함되지 않는다. 병합 정렬의 시간 복잡도는 worst case, best case 모두 다 O(n log n)이다. worst case : O(n log n) best case : O(n log n)장점worst case , best case 어떤 경우에도 좋은 성능이 보장된다.또 중복 값의 위치가 변하지 않는다(stable)단점메모리 공간이 필요하다.분할할 때 데이터 요소의 양만큼 새로운 메모리 공간이 필요하다.merge sort javascript 구현const mergeValue = [];function mergeSort(array) { if (array.length &amp;lt; 2) { return array } let pivot = Math.floor(array.length / 2); let left = array.slice(0, pivot) let right = array.slice(pivot, array.length); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { let result = []; while (left.length &amp;amp;&amp;amp; right.length) { if (left[0].num &amp;lt;= right[0].num) { result.push(left.shift()); } else { result.push(right.shift()); } } mergeValue.push(result.concat(left, right)); return result.concat(left, right); } mergeSort([4,3,6,3,2,1,4,5]);Quick Sort퀵 정렬은 데이터에서 pivot(기준) 을 정한 뒤 pivot을 중심으로 pivot보다 작으면 왼쪽으로 이동하고, pivot보다 큰면 오른쪽으로 이동한다. 이러한 방법을 왼쪽에 다시 적용하고 오른쪽에도 다시 적용하는 것을 반복해나가면서 정렬한다.big - O worst case : O(n²) (이미 정렬이 되어 있는 경우) (ex: [1,2,3,4,5] or [5,4,3,2,1]) best case : O(n log n)장점성능이 좋다. in place 추가 공간을 사용하지 않고 주어진 공간만 이용해서 정렬한다. 메모리 공간을 절약할 수 있다. 또 초보자들도 이해하기 쉽고 요소들을 탐색하기 용이하다.단점중복값의 위치가 바뀔 수 있는 unstable 정렬방법 이다. pivot의 영향을 받아 worst case의 경우 시간 복잡도가 O(n²) 이된다. quick sort는 중복 값 위치가 바뀌지 않는 stable 한 방법과 중복 값 위치가 바뀔 수 있는 unstable 한 방법 두 가지가 있다.stable 한 경우 in place 방법이 아니기 때문에 메모리 공간이 필요하고, unstable 한 경우 in place 방법으로 메모리 공간은 절약할 수 있다. 이러한 이유로 unstable 한 하지만 in place 방법을 더 많이 사용한다.quick sort javascript 구현unstable / in placefunction partition (array, left, right, pivotIndex) { let swap; let pivot = array[pivotIndex]; while (left &amp;lt;= right) { while (array[left] &amp;lt; pivot) left++; while (array[right] &amp;gt; pivot) right--; if (left &amp;lt;= right) { swap = array[left]; array[left] = array[right]; array[right] = swap; left++; right--; } } swap = array[left]; array[left] = pivot; array[pivotIndex] = swap; return left;};function quickSort (array, left = 0, right = array.length -1) { let pivotIndex = right; pivotIndex = partition(array, left, right - 1, pivotIndex); if (left &amp;lt; pivotIndex - 1) quickSort(array, left, pivotIndex - 1); if (pivotIndex + 1 &amp;lt; right) quickSort(array, pivotIndex + 1, right); return array;};quickSort([3,6,5,3,2,5,4,3]); " }, { "title": "Promise", "url": "/posts/Promise/", "categories": "Javascript", "tags": "Promise", "date": "2020-01-25 00:00:00 +0900", "snippet": "Asynchronus자바스크립트는 비동기 처리를 위해 콜백 함수를 사용한다.콜백 함수는 순차적인 처리가 많을 경우 가독성이 나쁘다.또, 비동기 처리를 한꺼번에 처리하는 것도 한계가 있으며 에러 예외 처리에 대한 곤란한 부분이 있다.Promise?promise는 자바스크립트 비동기 처리에 사용되는 비동기 흐름을 제어해 주는 객체이다. 비동기 상태에서 주도권을 가지게 해준다.콜백 함수의 단점 가독성이 좋지 않다. 에러처리에 한계가 있다.콜백 지옥지금까지 공부한 비동기 방식 콜백 함수는 아래와 같다.function foo (callback) { setTimeout(function(){ console.log(&#39;비동기 작업&#39;); callback(); });}foo(function(){ console.log(&#39;종료&#39;);});콜백 함수를 인자로 넣어주고 비동기 작업이 종료될 때 콜백 함수를 호출한다. 아래와 같이 비동기 처리 순서를 보장하기 위해 여러 개의 콜백 함수가 중첩되어 복잡도가 높아지는 콜백 지옥이 발생하는 단점이 있다. 콜백 지옥은 가독성이 좋지 않다function foo (str, callback){ setTimeout(function () { console.log(str) callback(); }, 1000)}foo(&#39;1&#39;, function() { foo(&#39;2&#39;, function () { foo(&#39;3&#39;, function(){ console.log(&#39;end&#39;) }); });});에러 예외 처리예를 들어, 인자로 숫자가 들어가고 인자를 더한 값을 반환하는 함수가 있다. 하지만 문자가 인자로 들어갔을 경우 에러를 발생 시키지 않는다.function sum (a, b) { return a + b;}console.log(sum(1, 2)); // 3console.log(sum(&#39;hello&#39;, 2)); // &#39;hello2&#39;아래와 같이 자바스크립트 문법적 오류가 없어 발생하지 않는 오류를 예외로 처리해 준다.function sum (a, b) { if(typeof a !== &#39;number&#39; || typeof b !== &#39;number&#39;){ throw &#39;숫자가 아닙니다.&#39; } return a + b;}console.log(sum(1, 2)); // 3console.log(sum(&#39;hello&#39;, 2)); // errortry / catch / new Errorfunction foo () { console.log(&#39;3&#39;); throw new Error(&#39;에러&#39;) console.log(&#39;4&#39;);}function bar () { console.log(&#39;2&#39;); foo(); console.log(&#39;5&#39;);}console.log(&#39;1&#39;);bar();console.log(&#39;6&#39;)에러가 발생할 경우 실행되어야 할 함수들도 영향을 받아 모두 실행되지 않는다.new Error에러 객체를 사용하면 error 부분의 콜스택 정보도 담긴다.function foo () { console.log(&#39;3&#39;); throw new Error(&#39;에러&#39;) console.log(&#39;4&#39;);}function bar () { console.log(&#39;2&#39;); foo(); console.log(&#39;5&#39;);}console.log(&#39;1&#39;);try{ bar();}catch(err){ console.log(err);}console.log(&#39;6&#39;)try , catch를 사용할 경우 try 사이에서 발생한 error는 catch로 넘어간다. catch가 된 부분 뒤의 실행될 함수들은 영향을 받지 않고 실행된다.비동기 에러 예외 처리function foo () { setTimeout(function () { throw new Error(&#39;에러&#39;); }, 1000)}try { foo();} catch (e) { console.log(&#39;에러를 캐치하지 못한다..&#39;); console.log(e);}try 블록 내에서 setTimeout 함수가 실행되면 1초 후에 콜백 함수가 실행되고 이 콜백 함수는 예외를 발생시킨다. 하지만 비동기 함수의 예외는 catch 블록에서 캐치되지 않는다. foo()함수가 실행될 때 비동기는 콜큐에 넣어지게 되므로 error를 잡지 못한다.promise는 위와 같은 콜백 함수들의 단점들을 해결하고 주도권을 가져온다.promisePromise는 객체이다. Promise 생성자 함수를 통해 인스턴스화한다. promise는 resolve와 reject를 함수의 인자로 전달받고, 비동기 처리가 성공(fulfilled)하였는지 또는 실패(rejected)하였는지 등의 상태 정보를 갖는다. 대기(pending): 이행하거나 거부되지 않은 초기 상태. 이행(fulfilled): 연산이 성공적으로 완료됨. 거부(rejected): 연산이 실패함.pendeing (대기)new Promise(function (resolve, reject) { // 생략..}); 위와 같이 new Promise() 를 호출하면 Pending(대기) 상태가 된다. promise는 함수를 인자로 받으며 resolve와 resject를 함수의 인자로 전달받는다.fulfilled (이행)new Promise(function (resolve, reject) { setTimeout(function () { console.log(&#39;hello&#39;); resolve(); }, 1000);}); 위와 같이 resolve를 실행하면 Fulfilled(이행) 상태가 된다. 비동기 작업이 성공적으로 완료되면 resolve를 호출한다. resolve는 한번만 호출된다.그리고 이행 상태가 되면 Promise 객체의 후속 처리 메소드then, catch를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다.then(), catch()then(),catch는 Promise를 반환한다. then()작업이 성공적으로 완료되면 resolve를 호출하고, then을 실행한다.then은 연속적으로 실행할 수 있다. catch()에러가 발생했을 때 reject를 호출하고, catch는 에러를 잡아준다.function foo () { return new Promise(function (resolve, reject) { setTimeout(function () { console.log(&#39;hello&#39;); resolve(); }, 1000); }); }foo().then(function(){ console.log(&#39;world&#39;);});// foo().then().then().then() 연속적으로 then을 사용할 수 있다. (chaining)Rejected(실패)reject() 실행하면 Rejected(실패) 상태가 된다.실패 결과의 값을 catch()로 받을 수 있다.function foo () { return new Promise(function (resolve, reject) { setTimeout(function () { console.log(&#39;hello&#39;); reject(new Error(&quot;에러!&quot;)); }, 1000); }); }foo().then(function(){ console.log(&#39;world&#39;);}).catch(function(err){ console.log(err);}); 출처 : mdnpromise는 promise객체를 생성하고 then을 실행할 때 마다 실행된 새로운 promise객체를 반환한다.예를들어,function foo() { return new Promise(function(resolve, reject){ setTimeout(function(){ reject(new Error(&#39;에러!&#39;)); }, 1000); });}foo().catch(function(err){ console.log(&#39;1 err &#39;, err); // 1 err 에러!}).catch(function(err){ console.log(&#39;2 err &#39;, err)});위와 같은 결과가 나오는 이유는 무엇일까?2 err는 1 err의 새로운 인스턴스 객체 값 받아온다.1 err는 실행이 되었고 예외 처리가 없기 때문에 2 err가 실행되지 않는다.Promise.allPromise.all 은 순회 가능한 객체(배열)를 인자로 받는다.순회 가능한 객체(배열)에 주어진 모든 promise를 이행한 후 then()을 호출 한다.여러개의 비동기 작업들을 모두 이행한후 then함수의 다음 작업을 실행한다.let a = new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&#39;hello&#39;); resolve(&#39;1&#39;); }, 1000);});let b = new Promise(function(resolve, reject){ setTimeout(function(){ console.log(&#39;world&#39;); resolve(&#39;2&#39;); }, 1000);});Promise.all([a, b]).then(function(val){ console.log(val)});// hello// world// [1, 2]Promise.race순회 가능한 객체(배열)를 인자로 받는다.가장 먼저 완료된 것의 결과값으로 그대로 실행하거나 에러처리를 한다.let a = new Promise(function(resolve, reject){ setTimeout(function(){ resolve(&#39;1&#39;) }, 1000);});let b = new Promise(function(resolve, reject){ setTimeout(function(){ resolve(&#39;2&#39;); }, 2000);});Promise.race([a, b]).then(function(val){ console.log(val)}).catch(function(err) { console.log(err)});// 1 " }, { "title": "design-patterns", "url": "/posts/design-patterns/", "categories": "Javascript", "tags": "design-patterns, 디자인 패턴", "date": "2020-01-20 00:00:00 +0900", "snippet": "디자인 패턴이란?프로그램을 개발하는 과정에서 발생하는 다양한 문제점들을 해결하기 위해 많은 개발자들이 빈번하게 발생하는 문제들을 상황에 따라 적용해서 쓸 수 있는 패턴 형태로 만든 증명된 기술들이다. 어떠한 상황에서 정확한 해결책을 제시해 주는 것은 아니지만 일종의 방향성(솔루션)을 제시해준다.1. Modules 모듈 패턴모듈(module)은 일부의 독립된 코드로 분리해서 만들어 놓은 것을 말한다.모듈은 프로젝트의 코드를 깨끗한 구조로 정돈하는 데 도움을 준다.자바스크립트에서는 모듈을 구현하는 가장 쉬운 방법은 객체 리터럴을 사용하는 방법이다.아래의 경우 가장 일반적인 모듈 형태이다.obj변수에 중괄호와 함께 내부 변수 및 내부 함수(method)를 모두 갖고 있어야 한다.var obj = { key: &#39;value&#39;, method: function () { console.log(&#39;hello world&#39;); }}객체 리터럴은 사용하기 간편하고 유용하지만 위와 같이 작성했을 경우 보안에 취약하다.자바스크립트는 일반적으로 브라우저에 사용자에게 직접 노출되기 때문에 위와 같이 글로벌 공간에 변수를 선언하는 것은 되도록 피해야 한다.const PlusMinus =(function () { let num = 0; return { plus: function () { num++; }, minus: function () { num--; }, getNum: function () { return num; } } })()위와 같이 클로저나 익명 함수(즉시 실행 함수)를 사용하여 객체를 리턴하고 num변수를 함수 안에 선언하여 보호한다. 하지만 위 코드는 재사용이 번거롭다.(function () { function plusMinus () { let num = 0; return { plus: function () { num++; }, minus: function () { num--; }, getNum: function () { return num; } } } let num1 = plusMinus(); let num2 = plusMinus(); })()위 코드는 plusMinus라는 함수를 익명 함수(즉시 실행 함수)로 감싸주어 변수를 보호할 수 있고, 재사용성을 높일 수 있다. 장점: 코드를 정리할 때 사용한다. 단점: 코드의 양이 많아지고 파일 크기도 늘어난다.Singletons 싱글톤 패턴싱글톤 패턴은 상황에 따라서 만드는 것을 제한을 두는 것으로 특정 클래스의 객체를 한 개만 유지하는 패턴이다.자바스크립트에서는 이미 객체 리터럴을 이용한 객체 생성 방법이 싱글톤 패턴과 대표적인 예이다.var obj = { key: &#39;value&#39;, method: function () { console.log(&#39;hello world&#39;); }}위 코드는 단 하나밖에 없는 객체이다. 하지만 변수들이 모두 전역 변수에 노출되어 보호할 수 없다.var singleton = (function() { var a; var b = &#39;hello&#39;; function foo () { return { c: b, d: function() { alert(b); } }; } return { e: function() { if (!a) { a = foo (); } return a; } }})();var first = singleton.e();var second = singleton.e();console.log(first === second); // true;위와 같이 변수를 보호하고 객체를 하나만 유지하는 것을 싱글톤 패턴이라 한다.Mixin 패턴어떠한 기능을 공유하여 사용하는 것을 말한다.중복되는 코드가 있다면 중복되는 것을 함수로 만들어 주면서 코드의 재 사용을 높인다. mixin은 제약이 없고 유연하다.재사용성을 높이는 방법에는 두가지가있다.1. 함수 만들기var person1 = { name: function () {}, job: function () {}, eat: function () {},}var person2 = { name: function () {}, job: function () {}, eat: function () {},}var person3 = { name: function () {}, job: function () {}, eat: function () {},}위와 같이 breath라는 속성이 중복된다면 어느 한쪽을 수정하려고 할 때 모두 수정해야 하기 때문에 번거롭다.아래와 같이 공통되는 속성을 함수로 만들어 주면 재사용이 쉽고 제약이 없다.var person1 = { name: function () {}, job: function () {},}var person2 = { name: function () {}, job: function () {},}var person3 = { name: function () {}, job: function () {},}eatMixin(person1);eatMixin(person2);eatMixin(percon3);function eathMixin (person) { person.eat = function () {};}2. prototypefunction Computer (specifications) { this.specifications = specifications;}function Oven (bake) { this.bake = bake;}mixin(coputer.prototype);mixin(oven.prototype);function mixin (target) { target.energy = function () { console.log(&#39;I need energy&#39;); }}위와같이 여러 생성자 함수에 프로퍼티와 메소드들을 복사 해서 재사용 할 수 있다.단, prototype은 사용할 때 prototype chain 등 주의 깊게 생각해서 사용해야 한다.Pub-Sub 패턴pub-sub 은 Publish/Subscribe를 줄여서 부르는 말이다. 발행/구독의 개념이다.예를 들어, 유튜브 채널 구독신청을 하면 새로운 영상이 업데이트될 때마다, 구독자는 새로 게시된 영상의 알림을 받을 수 있다.pub/sub 패턴은 발행자(게시자)와 구독자의 분리이다.발행자와 구독자는 느슨하게 연결(Loose coupling) 되어 있으며 서로의 존재를 알 필요가 없이 비동기 메시지 방식의 도움을 받아 통신하며 각각 독립적으로 작동한다.이러한 방식 때문에 발행자와 구독자의 결합도가 낮아 확장성이 좋다.예) click, mouseover, keypress 와 같은 브라우저 이벤트" }, { "title": "hash table / javascript 구현", "url": "/posts/hash-table/", "categories": "Data Structure", "tags": "data structure, hash table", "date": "2020-01-19 00:00:00 +0900", "snippet": "hash table어떠한 데이터를 받아 저장하려고 할 때, 저장할 데이터의 키를 받아 해시 코드로 변환해서 데이터 구조에 저장한다. 해시 코드를 만드는 것을 hashing이라고 하는데 hashing 이란 암호화하는 것이다. 해시 함수는 암호를 일정한 길이로 반환해준다. 대표적으로 ex) MD5, SHA .. 등 이 있다. 해시 함수는 연산을 여러 번 작용하더라도 결과가 달라지지 않아야 한다. 보통 자바스크립트에서는 객체를 대체해서 사용한다.주의할 점은, key 값이 다르더라도 hash function에 의해 변환된 index가 같은 충돌이 발생할 수 있다. 이러한 경우를 해시 충돌 이라 한다. 장점 : 빠르다. 탐색, 삽입, 삭제, 중복 데이터를 찾아내기 쉽다. 단점 : 저장할 공간은 많은데 들어올 메모리가 적을 때 효율적이지 않고, 저장할 때 순서가 없다. 또 O(1)의 일정 시간이 길면 모두 시간이 오래 걸린다.big - O insertion : O(1) deletion : O(1) search : O(1)insertion &amp;amp; deletion &amp;amp; search / O(1)위의 그림과 같이 key값을 해시 함수를 돌려 일정한 길이로 암호화해준다. 해시 함수는 데이터 구조에 저장할 index 값을 돌려준다.index 위치를 알고 바로 저장할 데이터를 index 위치에 바로 저장할 수 있기 때문에 O(1)이다. 삭제와 검색 모두 마찬가지로 index로 직접적으로 삭제와 검색을 할 수 있기 때문에 O(1)이다.javascrpt로 Hash Table 구현아래는 Hash Table을 구현한 자바스크립트 소스이다.새로운 key와 value를 묶은 노드를 데이터 구조에 추가하고 value를 검색하고 삭제하는 기능까지 구현한 소스이다.var HashTable = function () { this._limit = 8; this._storage = LimitedArray(this._limit); this._arr = []};HashTable.prototype.insert = function (k, v) { var index = getIndexBelowMaxForKey(k, this._limit); var obj = {}; var val = this._storage.get(index); if (!val) { obj[k] = v; this._storage.set(index, obj); } else { obj = val; obj[k] = v; this._storage.set(index, obj); }};HashTable.prototype.retrieve = function (k) { var index = getIndexBelowMaxForKey(k, this._limit); return this._storage.get(index)[k];};HashTable.prototype.remove = function (k) { var index = getIndexBelowMaxForKey(k, this._limit); this._storage.each(function (el, i) { if (index === i) { delete el[k] } });};사용하지 않는 변수를 지우고 참 -&amp;gt; 거짓 순으로 (예: if (val) {} else {}로 구현하는 게 더 읽기 좋다는 것과 동적으로 sotrage를 확장/축소하는 것도 구현해 보라는 피드백을 받았다. 지금 코드를 다시 보니 사용하지 않았던 변수를 지우지 않고 불필요했던 로직을 지우지 않았던 것이 보였다. 아래 소스는 피드백을 받은 것을 바탕으로 다시 코드를 구현한 소스이다. 아직 확장 / 축소 하는것은 구현 중이다.var HashTable = function () { this._limit = 8; this._storage = LimitedArray(this._limit);};HashTable.prototype.insert = function (k, v) { var index = getIndexBelowMaxForKey(k, this._limit); let value = this._storage.get(index); let obj = {}; if (value) { obj = value; obj[k] = v; this._storage.set(index, obj); } else { obj[k] = v; this._storage.set(index, obj); }};HashTable.prototype.retrieve = function (k) { var index = getIndexBelowMaxForKey(k, this._limit); return this._storage.get(index)[k];};HashTable.prototype.remove = function (k) { var index = getIndexBelowMaxForKey(k, this._limit); this._storage.each(function (el, i) { if (index === i) { delete el[k]; } });};" }, { "title": "Tree vs Binary Search Tree / javascript 구현", "url": "/posts/Tree-vs-BinarySearchTree/", "categories": "Data Structure", "tags": "data structure, Tree vs Binary Search Tree", "date": "2020-01-18 00:00:00 +0900", "snippet": "Tree나무를 뒤집어 놓은 것처럼 하나의 시작 노드(root)로부터 시작되어 자식 노들(child node)들이 가지를 치듯 뻗어 나가는 구조이다.아래 그림과 같이 HTML이 좋은 예이다. root(뿌리)부터 시작해서 아래로 자식 노드들이 뻗어나가는 구조이다.가장 위는 root이고 제일 아래를 leaf라고 한다. leaf는 자식이 없는 노드이다.root도 leaf도 아닌 노드들을 내부 노드라고 부른다.노드와 노드 사이를 이어주는 것을 branch나 edge라고 부른다.path는 root에서 child node까지 가는 경로를 말하며, height은부모 노드에서 자식 노드 사이의 edge 개수를 말한다. 파일 관련 자료를 다룬다면 tree 구조가 적합하다.Big o insertion: O(1) Deletion: O(n) Search: O(n)insertion: O(1) / 추가노드를 추가하려고 할 때, 원하는 위치의 노드에 자식으로 추가해야 할 수 있기 때문에 O(1)이다.Deletion, Search: O(n) / 삭제, 찾기삭제할 노드를 찾으려면, 노드를 찾기 위해서 자식 노드들을 차례대로 탐색하면서 내려가야 한다. 최악의 경우 leaf에 존재할 수 있기 때문에 모든 노드를 찾아야하므로 노드를 제거하면 O (n)이된다.javascript로 Tree 구현아래는 tree를 구현한 자바스크립트 소스이다.노드를 자식으로 추가해주고 노드가 포함되어 있는지 확인해주는 기능까지 구현한 소스이다.var Tree = function (value) { var newTree = Object.create(treeMethods); newTree.value = value; newTree.children = null; // fix me newTree.children = []; return newTree;};var treeMethods = {};treeMethods.addChild = function (value) { var node = Tree(value); this.children.push(node);};treeMethods.contains = function (target) { var result = false; function recusion(node) { if (node.value === target) { result = true; return } if (node.children.length &amp;gt; 0) { for (var i = 0; i &amp;lt; node.children.length; i++) { recusion(node.children[i]); } } } recusion(this); return result;};필요 없는 조건들이 있다는 피드백을 받아 다시 구현한 소스이다.필요없는 조건들이 있는지 다시한번 생각해봐야겠다.var Tree = function (value) { var newTree = Object.create(treeMethods); newTree.value = value; newTree.children = []; return newTree;};var treeMethods = {};treeMethods.addChild = function (value) { let node = new Tree(value); this.children.push(node);};treeMethods.contains = function (target) { let result = false; function recusion(element) { if (element.value === target) { result = true; return; } for (let i = 0; i &amp;lt; element.children.length; i++) { recusion(element.children[i]); } } recusion(this); return result;};Binary Search Tree트리와 같은 구조로 자식이 2개 이하로만 존재하고 일정한 규칙으로 뻗어나가며 순서가 있는 데이터 구조로 정리되어 있다.(예: 왼쪽은 작은 숫자 오른쪽은 큰 숫자) 이진 검색 트리라고도 한다.순서가 있는 데이터들을 찾고 넣을 일이 많을 때 binary search tree를 사용한다.최악의 경우 노드가 한쪽으로만 뻗어 나갈 수 있다.worst case로 Big-O는 insertion: O(n), Deletion: O(n), Search: O(n)이다. 한쪽으로만 노드가 뻗어나가는 최악의 상황을 대처하기 위해 개량된 트리가 있다.AVL Tree , red Black Tree 는 한쪽으로만 뻗어 나가지 않게 스스로 균형을 조절한다.Big o insertion: O(log n) Deletion: O(log n) Search: O(log n)Big - O : insertion, deletion, search / O(log n) 추가왼쪽은 작은 숫자, 오른쪽은 큰 숫자로 일정한 규칙으로 정렬되어 뻗어 나간다고 하면, 어떤 노드를 추가하거나 삭제, 검색한다고 하면, 위 그림처럼 왼쪽과 오른쪽 중 기준이 되는 한쪽을 잘라 검색하고 원하는 위치나 찾아야 할 노드가 없다면 또 그것의 반을 잘라 검색해 나가기 때문에 추가, 삭제, 검색 모두 O(log n)이다.javascript로 Binary Search Tree 구현아래는 binary search tree를 구현한 자바스크립트 소스이다.노드를 규칙에 맞는 위치에 추가하고, 노드가 포함되어 있는지 확인하고 트리의 모든 값에 대해 콜백을 실행하는 기능까지 구현한 소스이다.var BinarySearchTree = function (value) { var bNewtree = Object.create(BtreeMethod); bNewtree.value = value; bNewtree.left = null; bNewtree.right = null; return bNewtree;};var BtreeMethod = {};BtreeMethod.insert = function (value) { var node = BinarySearchTree(value); function recusion(element) { if (element.value &amp;gt; node.value) { if (element.left === null) { element.left = node; } else { recusion(element.left); } } if (element.value &amp;lt; node.value) { if (element.right === null) { element.right = node; } else { recusion(element.right); } } } recusion(this);}BtreeMethod.contains = function (target) { var result = false; function recusion(element) { if (element.value &amp;gt; target) { if (element.left.value === target) { result = true } else { recusion(element.left.value); } } if (element.value &amp;lt; target) { if (element.right.value === target) { result = true } else { recusion(element.right.value); } } } recusion(this) return result;}BtreeMethod.depthFirstLog = function (func) { function recusion(element) { if (element.value) { func(element.value); if (element.left) { recusion(element.left) } if (element.right) { recusion(element.right) } } } recusion(this);} 코드 스타일! value 기존 value와 같은 상황도 고려하면 좋을 것 같다 참 -&amp;gt; 거짓 순으로 로직을 작성하는 것이 더 자연스러운 흐름이라고 하셨다. 예를 들어, if (val) {} else {} . 또, if (element.left === null) 부분도 if (!element.left)로 작성할 수 있다. 필요 없는 조건이 아닌지 다시 한번 생각해 보자.피드백을 받은 부분을 고려해서 다시 작성해 보았다.앞으로 코드를 작성할 때, 피드백 받은 부분 들을 유념해서 작성해야겠다.var BinarySearchTree = function (value) { const bNewtree = Object.create(BtreeMethod); bNewtree.value = value; bNewtree.left = null; bNewtree.right = null; return bNewtree;};var BtreeMethod = {};BtreeMethod.insert = function (value) { let node = new BinarySearchTree(value); function recusion(element) { if (element.value &amp;gt;= node.value) { if (!element.left) { element.left = node; } else { recusion(element.left); } } else { if (!element.right) { element.right = node } else { recusion(element.right) } } } recusion(this);}BtreeMethod.contains = function (target) { let result = false; function recusion(element) { if (element.value &amp;gt; target) { if (element.left.value === target) { result = true; return; } else { recusion(element.left.value); } } if (element.value &amp;lt; target) { if (element.right.value === target) { result = true; return; } else { recusion(element.right.value) } } } recusion(this); return result;}BtreeMethod.depthFirstLog = function (func) { function recusion(element) { if (element.value) { func(element.value); if (element.left) { recusion(element.left); } if (element.right) { recusion(element.right); } } } recusion(this)}" }, { "title": "Linked List / javascript 구현", "url": "/posts/Linked-List/", "categories": "Data Structure", "tags": "data structure, Linked List", "date": "2020-01-17 00:00:00 +0900", "snippet": "Linked List / 연결리스트여러 노드들이 위 그림과 같이 한 방향을 가리키는 연결 구조이다.가장 처음 시작하는 노드를 head라고 하며, 가장 마지막 노드를 tail이라고 한다. 노드 들은 본인의 이전 노드와 다음 노드를 기억한다.예를 들어, 어떠한 작업을 했을 때, 이전 단계로 작업을 되돌리기 위해 단축키 컨트롤 z로 이전 작업으로 이동할 수 있다. 컨트롤 z로 계속 이전 작업 단계로 이동하다 보면 가장 초기 작업 단계를 head라고 표현할 수 있다. 또 단축키 컨트롤 y로 다시 작업 후의 단계로 이동할 수 있고, 컨트롤 y로 계속 다음 작업 단계로 이동하다 보면 마지막에 작업했었던 상태로 돌아갈 수 있다. 마지막 작업 상태를 tail이라고 표현할 수 있다. 이렇게 서로 이전 과 다음 단계처럼 연결되어 있는 구조를 연결 리스트 linkde list라고 한다.big-O insertion: O(1) deletion: O(1) search: O(n)insertion / O(1) 자료구조에 삽입위 그림과 같이 삽입하고 싶은 연결 리스트의 위치만 안다면 1이 3을 바라보게 하고 3이 2를 바라보게 한다면 기존 javascript 배열처럼 자리를 찾기 위해 for loop 로 자리를 순위 하지 않아도 쉽게 자료 구주에 삽입할 수 있다. 한 번에 자기 자리를 찾아 들어갈 수 있기 때문에 big-O는 O(1)이다.deletion / O(1) 삭제위 그림과 같이 어떤 노드를 삭제하고 싶다면 이전 노드가 삭제하고 싶은 노드의 다음 노드를 가리키도록 연결하면 된다. insert와 마찬가지로 기존 배열처럼 for loop로 삭제할 요소를 순회하지 않아도 한 번에 노드를 삭제할 수 있다. 때문에 big-O는 O(1)이다.search / O(n) 찾기위 그림과 같이 3이라는 노드를 찾기 위해서 처음 head부터 3이라는 노드가 나올 때까지 다음 노드를 가리키는 방향을 따라 찾아가야 한다. worst case로 3이라는 노드가 마지막에 위치하고 있을 수도 있기 때문에 big-O는 O(n)이다.javscript로 Linkde List 구현아래는 Linked List를 구현한 자바스크립트 소스이다.새로운 노드를 맨 마지막 tail로 넣어주고, 맨 앞의 head 노드를 삭제하고, list에 node가 있는지 확인해주는 기능까지 구현한 소스이다.var LinkedList = function () { var list = {}; list.head = null; list.tail = null; list.addToTail = function (value) { var currNode; var node = new Node(value); if (!this.head) { this.head = node; this.tail = node; } else { currNode = this.head; while (currNode.next) { currNode = currNode.next; } currNode.next = node; this.tail = node; } return node; }; list.removeHead = function () { var removeValue = this.head; this.head = this.head.next; return removeValue.value; }; list.contains = function (target) { var accNode = this.head; while (accNode) { if (accNode.value === target) { return true; } else { accNode = accNode.next; } } return false; }; return list;};var Node = function (value) { var node = {}; node.value = value; node.next = null; return node;};피드백을 받은 후 다시 구현해보았다. addToTail 메소드를 작성할 때, 원래 작성했던 대로라면 O(1)이 아니라 O(n)이다. 원하는 위치로 가기 위해서 탐색해나가면서 원하는 위치에 추가하는 것이다. this.tail.next로 바로 추가하면 되는데 … addToTail 을 O(1)으로 다시 구현하고 head가 null일 경우를 추가해서 다시 구현해 보았다.var LinkedList = function () { var list = {}; list.head = null; list.tail = null; list.addToTail = function (value) { let node = new Node(value); if (!this.head) { this.head = node; this.tail = node; } else { this.tail.next = node; this.tail = node; } }; list.removeHead = function () { let removeNode = this.head; if (TimeRanges.head !== null) { this.head = removeNode.next; return removeNode.value; } }; list.contains = function (target) { let accNode = this.head; while (accNode) { if (accNode.value === target) { return true; } accNode = accNode.next; } return false; }; return list;};var Node = function (value) { var node = {}; node.value = value; node.next = null; return node;};" }, { "title": "Big-O 시간복잡도", "url": "/posts/Big-O-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/", "categories": "Javascript", "tags": "Big-O, 시간복잡도", "date": "2020-01-16 00:00:00 +0900", "snippet": "Big-O 란?big-O는 알고리즘의 효율성을 나타내는 지표이다. big-O를 이용하여 알고리즘의 성능을 판단한다. big-O표기법은 보통 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는데 주로 사용된다.시간 복잡도는 알고리즘의 시간 효율성을 의미한다.시간 복잡도란 시간 개념으로 알고리즘의 수행 시간패턴이 얼마인지를 나타낸다. 시간이 늘어나는 패턴을 추상화로 표기한 것으로 함수의 시간 소요를 일반화하는 것이다.Big-O 표기법Big-O 표기법은 데이터 입력값(n)의 크기에 따라 영향을 받는다.그렇게 때문에 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다. 최악의 상황을 고려해서 표기하며 입력값(n)의 표기는 제한이 없다. O(1) &amp;lt; O(log n) &amp;lt; O(n) &amp;lt; O(n log n) &amp;lt; O(n²) &amp;lt; O(2ⁿ) &amp;lt; O(n!) &amp;lt; O(nⁿ)f(n) = 3n + n² + 5위와같이 수학적 표기로 예를 든다면 영향력이 있는 값은 n² 이다. 상수항은 무시한다. example O(2n) -&amp;gt; O(n) 위와 같이 영향력이 없는 상수항 2를 무시하고 O(n) 으로 표기한다. 영향력이 없는 항은 무시한다. O(N² + 3N + 3) -&amp;gt; O(N²) O(N²) 으로 표기한다. O(1) vs O(n)O(1) castant time일정한 패턴을 말한다. 입력값(n)의 크기와 상관없이 항상 일정한 시간 패턴을 보이는 것을 O(1)이라고 표기한다. 예를 들어, 시간이 오래 걸리든 빨리 걸리든 시간이 일정한 패턴을 보인다면 O(1)이다.O(n)일정하게 증가하는 패턴을 말한다.입력값(n)의 크기에 따라 시간 패턴이 일정하게 늘어나는 것을 O(n)이라고 표기한다. 예를 들어, 데이터 구조 길이가 길수록 시간이 오래 걸린다면 O(n)이다.O(log n) vs O(n²)O(log n) logarithmic증가하는 속도가 줄어들면서 증가하는 패턴을 한다. 이진 트리 탐색 BinarySearchTree로 예를 들 수 있다. 트리와 같은 구조로 자식이 2개 이하로만 존재하고 일정한 규칙으로 뻗어나가기 때문에 순서가 있는 데이터 구조로 정리되어 있다. 그렇게 때문에 첫 시행 후 반이 버려지고 또 탐색하고 반이 버려지는 것 을 반복한다면 시간 패턴은 속도가 점점 줄어들면서 증가하는 패턴을 보인다. 이와 같은 패턴을 O(log n)이라고 한다.O(n²)증가하는 속도가 점점 급격히 증가하는 패턴을 말한다. 버블 정렬을 예로 들 수 있다. 2중 for 문을 사용하면서 정렬이 되어있지 않은 요소들을 하나하나 탐색해야 할 때 같은 패턴을 O(n²)이라고 한다.위의 Big-O의 표기는 대표적으로 많이 사용되는 표기법이다.경우에 따라 표기법은 다양하게 존재한다.n의 표기에는 제한이 없으며, n lon n,n + k, kⁿ등 다양하게 표현할 수 있다." }, { "title": "OOP / 객체 지향 프로그래밍 / prototype", "url": "/posts/OOP-prototype/", "categories": "Javascript", "tags": "OOP, 객체 지향 프로그래밍", "date": "2020-01-14 00:00:00 +0900", "snippet": "Object Oriented Programming / 객체 지향 프로그래밍 ?객체지향은 동작하는 부분을 캡슐화해서 이해할 수 있게 하고, 함수형 프로그래밍은 동작하는 부분을 최소화해서 코드 이해를 돕는다. -마이클 페더스‘레거시 코드 활용 전략’ 저자객체지향의 경우 객체 안에 상태를 저장한다.각 객체는 메시지를 받을 수도 있고, 데이터를 처리할 수도 있으며, 또 다른 객체에게 메시지를 전달할 수도 있다.객체지향 프로그래밍은 보다 유연하고 유지보수하기 쉬우며 확장성 측면에서서도 유리한 프로그래밍을 하도록 의도되었다.생성자 함수와 인스턴스의 생성생성자 함수란?자바스크립트는 생성자 함수와 new 연산자를 통해 인스턴스를 생성할하면 생성자 함수라고 한다. 생성자 함수는 클래스이자 생성자의 역할을 한다.function foo () {} // 생성자함수new foo // 인스턴스var obj = {}; // 생성자함수는 Objectvar obj = new Object(); // 생성자함수는 Objectvar arr = [];var arr = new Array(); // 생성자함수는 Array일반함수와 생성자 함수를 구분해서 작성한다.function Person (name) { this.name = name;}new Person; 첫글자를 대문자로 표기해준다. this를 사용한다.인스턴스의 생성생성자 함수와 prototype 기능을 모두 빌려쓸 수 있는 객체다.function Person (name) { this.name = name}var person1 = new Person(taeback); // 인스턴스var person2 = new Person(taesoon); // 인스턴스person1과 person2는 아래와 같은 객체로 반환된다.var person1 = { name: taeback;}var person2 = { name: taesoon;}프로토타입 체인모든 함수는 프로토타입이라는 다른 객체를 가리키는 내부 링크를 가지고 있다. 즉, 프로토타입을 통해 직접 객체를 연결할 수 있는데 이를 프로토타입 체인이라 한다.prototype함수는 객체이기 때문에 key와 value를 가질수있다. 모든 함수에는 ‘prototype’ 이라는 속성을 가지고 있고 값으로 객체를 가지게 된다.function foo () {};foo.prototype; // -&amp;gt; {constructor: foo}foo.prototype.constructor === foo // 생성자함수를 가리킨다.생성자 함수와 상관없이 모든 함수에는 ‘prototype’, ‘constructor’이라는 속성을 가지고 있다.prototype chainfunction Person (name) { this.name = name}Person.prototype.power = 100;Person.prototype.fun = 200;Person.prototype.love = function (a) { console.log(a + 20);}var person1 = new Person(&#39;taeback&#39;); // 인스턴스var person2 = new Person(&#39;taesoon&#39;); // 인스턴스person1과 person2는 아래와 같이 반환된다.var person1 = { name: &#39;taeback&#39;;}var person2 = { name: &#39;taesoon&#39;;}person1.power; // 100person1.fun; // 200person1.love(10); // 30person2.power; // 100person2.fun; // 200person2.love(20); // 40위 코드와 같이 person1과 person2에는 power, fun, love라는 속성이 없다. 하지만 instace 객체는 생성자 함수의 prototype 속성을 사용할 수 있다. prototype을 사용하면 생성자 함수 속성에 따로 정의하지 않아도 되기 때문에 중복을 줄일 수 있다.상속function Grandmother (name) { name: name;}Grandmother.prototype.love = 100;var mother = new Grandmother(&#39;mom&#39;);var child = Object.create(mother); // mother의 prototype을 갖는 빈객체가 생성된다.child.love; // 100;위와 같은 코드가 있을 경우에 child는 mother의 prototype을 갖는 빈객체이다. child에는 love라는 속성이 없기 때문에 상위 객체인 prototype chain을 타고 올라가 mother에서 love라는 속성을 찾는다. mother에도 love라는 속성이 없다면 mother의 상위 객체인 grandmother에 가서 love라는 속성을 찾게 된다. 속성을 찾게 되면 child는 love라는 속성을 사용할 수 있다.var arr = []; // 생성자함수 ArrayObject.prototype.name = &#39;object&#39;;arr.name; // &#39;object&#39; ‘arr’는 ‘name’이라는 속성이 없다. arr의 생성자 함수 ‘Array.prototype’에 가서 ‘name’이라는 속성을 찾는다 ‘Array.prototype’에 ‘name’이라는 속성이 없기 때문에 상위 객체 ‘Object.prototype’에 ‘name’이라는 속성을 찾는다. ‘Object.prototype’에 ‘name’의 값을 찾아 ‘arr’이가 사용할 수 있게 된다.javascript에서 Object.prototype은 최상위 객체이다.캡슐화 추상화 팩토리캡슐화객체의 key의 값이 함수일 때 메소드이다.캡슐화는 관련있는 멤버 변수와 메소드를 클래스와 같은 하나의 틀 안에 담고 외부에 공개될 필요가 없는 정보는 숨기는 것을 말한다.변수를 스코프 안쪽에 가두어 함수 밖으로 노출시키지 않는 방법이다.이를 통해서 객체의 내부에서만 사용해야 하는 값이 노출됨으로서 생길 수 있는 오류를 줄일 수 있다.var Person = (function () { var power = 0; return { powerUp: function () { power++; }, powerDown: function () { power--; } getPower: function () { return power; } };})();console.log(power); // power 변수에 접근할 수 없다.즉시 실행되는 익명함수로 만들어주면 scope 때문에 power 변수에 접근할 수 없다.외부에서 허용되지 않은 자들이 함부로 접근할 수 없도록 내부 정보를 보호하는 것을 캡슐화라고 한다.추상화객체의 프로퍼티와 메소드를 정의 하고 복잡한 원리나 구동 방식을 사용자로부터 추상화시켜주는 작업이다. 추상화란 객체들의 공통적인 프로퍼티와 메소드를 뽑아내는 작업을 의미한다.예를 들어, 동물이라는 함수가 있다면 여러 메소드들이 존재하겠지만 음식을 섭취하고 배설하는 메소드는 공통적인 메소드이다.var Person = (function () { // Now encapsulated var power = 0; return { powerUp: function () { power = 100; }, powerDown: function () { power = 0; }, upDown: function () { power = 100; setTimeout(function () { power = 0; }, 5000); } };})();Factory생성자 함수가 아니면서 객체를 만들어서 돌려주는 함수를 말한다.var Person = { powerUp: function () { this.power = 100; }, powerDown: function () { this.power = 0; },};function createPerson () { // &amp;lt;- Factory Function return Object.create(Person);}var person1 = createPerson();var person2 = createPerson();var person3 = createPerson();return Object.create(Person);는 값을 갖는 Person을 prototype으로 갖는 객체를 만들어 주는 것이다." }, { "title": "asynchronous / 비동기프로그래밍", "url": "/posts/%EB%B9%84%EB%8F%99%EA%B8%B0%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/", "categories": "Javascript", "tags": "asynchronous, 비동기프로그래밍", "date": "2020-01-11 00:00:00 +0900", "snippet": "자바스크립트에서 비동기가 왜 중요할까?자바스크립트는 single-threaded 이기 때문이다.single threaded / single callstack란? 쓰레드가 하나라는 말이다. 쓰레드 하나에 하나의 callstack이 존재한다. 하나의 callstack은 한 번에 하나의 작업만을 실행한다.실행해야 하는 작업해야 할 일들이 많을 경우 javascript는 순서대로 일을 실행해야 하기 때문에 시간이 걸리는 작업이 있을 경우 이전 작업이 완료될 때까지 다음 작업을 실행할 수 없다. 그렇기 때문에 javascript에서 비동기를 중요하게 다룬다.예를 들어, 우리가 음식점에 가서 음식을 주문한다 가정해보자.손님 1이 음식 주문을 하고 음식이 조리될 때까지의 시간이 30분 정도 걸린다고 했을 때 손님 2는 손님 1이 주문한 음식을 받기 전까지 음식을 주문할 수 없는 것을 동기적이라고 할 수 있다. 손님 1이 주문을 하고 음식을 조리하는 동안 손님 2도 주문을 할 수 있게끔 비동기적으로 처리해준다면 상황이 더 유연해질 것이다.event loop / web APIs / callbacke queV8 Engine자바스크립트 엔진의 대표적인 예는 구글에서 만든 Google V8 엔진이다. 브라우저에서 자바스크립트를 실행하는 엔진이다. heap (저장되는 장소) stack (callstack) (실행문들이 쌓이는 구조)Web API Ajax, setTimeOut, event 등을 의미한다. 브라우저에서 지원한다. Web API는 요청한 작업을 받아 순서대로 Callback Queue에 줄을 세워 넣는다. Call Stack콜 스택(call stack) 이란 컴퓨터 프로그램에서 현재 실행 중인 것들에 관한 정보를 저장하는 스택 자료구조이다. 그냥 줄여서 스택 (the stack) 이라고도 한다. 함수가 실행되면 스택 구조에 쌓인다. 함수가 종료되면 스택에서 빠져나간다.아래와 같이 코드가 실행될 때에 스택 구조에 쌓이게 된다.함수가 종료되지 않으면 스택에서 빠져나가지 않고 그 위에 실행되는 다른 함수가 그 위에 쌓이게 되는 구조이다. 함수가 종료되어야만 스택에서 빠져나갈 수 있다. main() 프로그램이 실행된다. foo(5)를 실행하면 콜스택에 쌓이게 된다. foo(5)는 sum(cd) 함수가 실행된 값을 변수에 담는다. sum(cd) 함수가 실행하면 foo(5) 함수가 종료되지 않았기 때문에 foo(5) 함수 그 위에 sum(c*d) 함수가 콜스택에 쌓이게 된다. sum(c*d) 함수가 결과를 받고 종료되면 스택에서 빠져나온다. foo(5) 함수도 결과를 받으면서 스택에서 빠져나온다. main() 프로그램이 종료된다.참조 - loop위 링크를 타고 들어가 직접 코드를 실행해 보면 Call Stack과 Callback Queue, event loop 가 내부적으로 어떻게 실행되는지 표현해 준다.콜스택 오버 에러!!재귀함수의 예function foo () { foo();}재귀 함수를 사용할 때 탈출 조건을 꼭 만들어 주어야 한다. 그렇지 않으면 무한 루프를 돌다가 결국 콜스텍 오버 에러를 낸다.foo() 함수가 실행되고 종료되지 않은 채 foo() 함수를 실행하기 때문에 콜스택에 foo()가 계속 무한히 쌓이게 되면 RangeError: Maximum call stack size exceeded 에러 메시지가 뜨게 된다.Callback Queue와 event loop callback Queue : web API는 요청한 작업들을 callback Queue에 줄을 세워 넣어주고 스택 구조에 넣어지기 전 대기하고 있는 곳이다. Event Loop : stack과 callback Queue를 지속적으로 보고 있다가 스택이 비어있으면 callback Queue로부터 스택에 넣는다.함수가 실행될 때에 스택 구조에 쌓이게 되고 비동기 함수가 있을 경우 web API에 요청을 보내게 된다. web API는 요청한 작업들을 callback Queue에 줄을 세워 넣어주고, 스택 구조에 쌓인 함수들이 모두 실행되고 나서 스택을 빠져나가게 되면 event loop는 지속적으로 스택과 callback Queue를 지속적으로 지켜보다가 스택이 비워지면 callback Queue에 대기하고 있던 작업들은 스택 구조에 넣어 실행시켜준다.examplesconsole.log(1);setTimeout(function foo () { console.log(2);}, 2000);console.log(3);위와 같은 코드가 있을 경우 콘솔에 1, 3, 2 순서대로 아래와 같이 실행된다.foo 함수는 비동기 함수로 callback Queue에 넣어지고 스택에 있는 함수들을 모두 실행한 다음 스택에 빠져나왔을 때 프로그램은 종료되지만 Event Loop가 스택이 비어있으면 callback Queue로부터 줄이 세워진 함수들을 차례로 스택에 넣어주기 때문에 마지막으로 콘솔에 2가 찍히게 된다. main() 프로그램이 실행된다. console.log(1)을 실행하면 콜스택에 쌓이고 콘솔에 1이 찍히고 콜스택을 빠져나온다. setTimeout(foo, 2000) 비동기 콜백 함수를 callback Queue에 넣는다. console.log(3)를 실행하면 콜 사택에 쌓이고 콘솔에 3가 찍히고 콜스택을 빠져나온다. main() 프로그램이 종료된다. 2초 후 event loop가 callback Queue를 보고 있다가 스택이 비어있으면 callback Queue로부터 스택에 foo() 함수를 넣는다. 콘솔에 2가 찍히고 foo() 함수가 종료되면서 콜스택을 빠져나온다example유명한 클로저 예제이다.for (var i=1; i &amp;lt; 5; i++) { setTimeout(function (i) { console.log(i) }, 3000);}위 코드를 실행하면 3초 후 콘솔에 5가 5번 찍히게 된다.setTimeout 비동기 함수는 콜백 큐에 들어가 있을 때 i가 모두 증가된 후 setTimeout 비동기 함수가 실행되기 때문에 콘솔에 5만 찍히게 된다. i가 순차적으로 증가되게끔 콘솔에 찍고 싶다면 어떻게 해야 할까? for (var i = 1; i &amp;lt; 6; i++) { (function(ct) { setTimeout(function () { console.log(ct); }, 3000); })(i); }위와 같이 함수로 스코프를 만들어주면서 i를 인자로 받아 순차적으로 실행해주면 i를 순차적으로 콘솔에 찍을 수 있다. (let을 사용하지 않았을 경우)Highger Order Funcion / 고차원 함수 함수를 인자로 받거나 함수를 값으로 갖는 함수를 고차원 함수라고 한다. 자바스크립트에서 함수는 first-class objects 일등급 객체이다.일등급 객체란?자료구조에 저장할 수 있고, 함수의 매개변수로 넣어 줄 수 있고, 함수에서 리턴해줄 수 있고, 실행문 중간에 언제든지 생성할 수 있는 것.고차원함수가 존재할 수 있는 이유는 자바스크립트에서 함수는 일등급 객체이기 때문에 비동기를 가능하게 해준다." }, { "title": "underscore", "url": "/posts/underscore/", "categories": "Javascript", "tags": "underscore", "date": "2019-12-16 00:00:00 +0900", "snippet": "_.identity _.identity = function(val) { return val; };_.identity는 인자를 그대로 반환 한다._.first _.first = function(array, n) { return n === undefined ? array[0] : array.slice(0, n); };_.first는 배열의 처음 n개의 element를 담은 배열을 반환한다. 만일 n이 undefined일 경우, 단순히 첫번째 element를 반환한다._.last _.last = function(array, n) { if(n === undefined){ return array[array.length-1]; }else if(array.length &amp;lt;= n){ return array; }else{ return array.slice(array.length-n, array.length); } };_.last는 마지막 n개의 element를 담은 배열을 반환한다. 만일 n이 undefined일 경우, 단순히 마지막 element를 반환한다._.each _.each = function(collection, iterator) { if(Array.isArray(collection)){ for(let i=0; i &amp;lt; collection.length; i++){ iterator(collection[i], i, collection) } }else if(typeof collection === &#39;object&#39;){ for(let key in collection){ iterator(collection[key], key, collection) } } };_.each는 각 요소에 iteratee를 적용한다._.indexOf _.indexOf = function(array, target) { var result = -1; _.each(array, function(item, index) { if (item === target &amp;amp;&amp;amp; result === -1) { result = index; } }); return result; }; for(let i=0; i &amp;lt; array.length; i++){ if(array[i] === target){ return i; } } return -1;_.indexOf는 target으로 전달되는 값이 배열에서 발견되면, 그 index를 반환하고, 만일 배열에서 발견할 수 없다면 -1을 반환한다._.filter _.filter = function(collection, test) { var arr = []; for(let i=0; i &amp;lt; collection.length; i++){ if(test(collection[i])){ arr.push(collection[i]); } } return arr; }; _.filter = function(collection, test) { var result = []; _.each(collection, function(el){ if(test(el)){ result.push(el); } }) return result; };_.filter는 테스트 함수를 통과하는 모든 element를 담은 배열을 반환한다._.reject _.reject = function(collection, test) { var arr = []; for(let i=0; i &amp;lt; collection.length; i++){ if(!test(collection[i])){ arr.push(collection[i]); } } return arr; }; _.reject = function(collection, test) { return _.filter(collection, function(el){ return !test(el); }); };_.reject는 테스트 함수를 통과하지 않는 모든 element를 담은 배열을 반환한다._.uniq _.uniq = function(array) { var result = []; for(let i=0; i &amp;lt; array.length; i++){ if(_.indexOf(result, array[i]) === -1){ result.push(array[i]); } } return result; }; _.uniq = function(array) { var arr = []; _.each(array, function(el){ if(_.indexOf(arr, el) === -1){ arr.push(el); } }); return arr; }; _.uniq = function(array) { var obj = {}; for(let i=0; i &amp;lt; array.length; i++){ obj[array[i]] = array[i]; } return Object.values(obj); };_.uniq는 element가 중복되지 않는 새로운 배열을 만들어 반환한다._.map _.map = function(collection, iterator) { var result = []; for(let i=0; i &amp;lt; collection.length; i++){ result.push(iterator(collection[i])); } return result; }; _.map = function(collection, iterator) { var result = []; _.each(collection, function(el){ result.push(iterator(el)) }); return result; };_.map는 iterator를 각 element에 적용한 결과를 담은 새로운 배열을 반환한다._.pluck _.pluck = function(collection, key) { return _.map(collection, function(item) { return item[key]; }); }; _.pluck = function(collection, key) { var result = []; _.each(collection, function(el){ result.push(el[key]); }) return result; };_.pluck은 collection의 key값이 동일한 값들만을 모아 반환한다._.reduce _.reduce = function(collection, iterator, accumulator) { var index = 0; if(accumulator === undefined){ accumulator = collection[0]; index = 1; } for(let i=index; i &amp;lt; collection.length; i++){ accumulator = iterator(accumulator, collection[i]) } return accumulator; }; _.reduce = function(collection, iterator, accumulator) { var slice = Array.prototype.slice; if(accumulator === undefined){ accumulator = collection[0]; collection = slice.call(collection,1); } _.each(collection, function(el){ accumulator = iterator(accumulator, el); }); return accumulator };_.reduce는 입력받은 collection으로부터 iteratee의 내용이 무엇인지에 따라서 하나의 결과값을 반환한다.accumulator는 초기값으로, 이 accumulator가 주어지느냐, 주어지지않느냐의 두가지 경우로 나뉜다._.contains _.contains = function(collection, target) { for(let key in collection){ if(collection[key] === target){ return true; } } return false; _.contains = function(collection, target) { collection = Object.values(collection); return _.reduce(collection, function(wasFound, item) { if (wasFound) { return true; } return item === target; }, false); }; _.contains = function(collection, target) { return _.reduce(collection, function(a, b){ if(b===target){ b = true; }else{ b = false; } return Boolean(a+b); },false); };_.contains는 배열 또는 객체가 주어진 값을 포함하는지 체크한다. collection에 target이 존재한다면 true, 그렇지 않다면 false를 반환한다._.every _.every = function(collection, iterator) { if(!iterator){ iterator = _.identity; } for(let i=0; i &amp;lt; collection.length; i++){ if(!iterator(collection[i])){ return false; } } return true; }; _.every = function(collection, iterator) { var result = true if(!iterator){ iterator = _.identity; } _.each(collection,function(el){ if(!iterator(el)){ result = false; } }); return result; };_.every는 모든 element가 iterator에 의해 truthy한지 체크한다. collection의 모든 element들이 iterator의 조건이 만족해야만 true를 반환한다. 단 하나의 element라도 조건에 만족하지 못한다면 false를 반환한다._.some _.some = function(collection, iterator) { return !_.every(collection, function(el){ if(typeof iterator !== &#39;function&#39;){ iterator = _.identity; } return !iterator(el); }) };_.some은 element가 하나라도 iterator에 의해 truthy한지 체크한다. collection의 element들 중 하나라도 iterator의 조건에 만족한다면 true를 반환한다._.extend _.extend = function(obj) { for(let i=0; i &amp;lt; arguments.length; i++){ for(let key in arguments[i]){ obj[key] = arguments[i][key]; } } return obj; }; _.extend = function(obj) { _.each(arguments, function(el){ for(let key in el){ obj[key] = el[key]; } }); return obj; };_.extend 주어진 객체를 전달된 인자의 모든 속성으로 확장한다._.defaults _.defaults = function(obj) { for(let i=0; i&amp;lt;arguments.length; i++){ for(let key in arguments[i]){ if(!obj.hasOwnProperty(key)){ obj[key] = arguments[i][key]; } } } return obj; }; _.defaults = function(obj) { _.each(arguments, function(el){ for(let key in el){ if(!obj.hasOwnProperty(key)){ obj[key] = el[key]; } } }); return obj; };_.defaults는 주어진 객체에 전달된 인자의 속성이 없다면 전달된 인자의 속성으로 확장한다._.once_.once = function(func) { var alreadyCalled = false; var result; return function() { if (!alreadyCalled) { result = func.apply(this, arguments); alreadyCalled = true; } return result; }; };_.once는 최대 한번만 호출할 수 있는 함수를 반환한다. 이후의 호출은 이전에 한번 리턴된 값만을 반환해야한다._.delay _.delay = function(func, wait, ...args) { setTimeout(function(){ func(...args); },wait); };_.delay는 주어진 시간 동안 함수를 지연한 다음 제공된 argument로 함수를 호출한다._.flatten _.flatten = function(nestedArray, result) { var arr = []; for(let i=0; i&amp;lt; nestedArray.length; i++){ if(!Array.isArray(nestedArray[i])){ arr.push(nestedArray[i]); }else{ arr = arr.concat(_.flatten(nestedArray[i])); } } return arr; }; _.flatten = function(nestedArray, result) { var result = []; _.each(nestedArray, function(el){ if(!Array.isArray(el)){ result.push(el); }else{ result = result.concat(_.flatten(el)); } }) return result; };_.flatten는 다차원 배열을 가져와서, 1차원 배열로 변환한다. 새로운 배열에는 다차원 배열의 모든 요소가 포함되어야 한다._.shuffle _.shuffle = function(array) { var arr = array.slice(); return arr.sort(function(){ return Math.random()-Math.random(); }); };_.shuffle는 배열 내용의 순서를 랜덤하게 변경한다._.sortBy _.sortBy = function(collection, iterator) { if(typeof iterator === &#39;string&#39;){ return collection.sort(function(a, b){ return a[iterator]- b[iterator]; }); }else{ return collection.sort(function(a, b){ return iterator(a)-iterator(b); }) } }; _.sortBy = function(collection, iterator) { var sort = Array.prototype.sort; if(typeof iterator === &#39;string&#39;){ return sort.call(collection, function(a, b){ return a.length - b.length; }) }else{ return sort.call(collection,function(a, b){ return iterator(a)-iterator(b); }) } };_.sortBy는 Collection 값들을 원하는 기준으로 정렬해준다._.throttle _.throttle = function(func, wait) { var result; return function(){ if(!result){ result = setTimeout(function(){ func.apply(this, arguments); result=null; },wait); } } };_.throttle는 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것Debouncefunction debounce(fn, wait) { var timer; return function() { clearTimeout(timer); timer = setTimeout(function(){ fn.apply(this, arguments); }, wait); }}Debounce는 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것._.invoke _.invoke = function(collection, functionOrKey, args) { var arr = []; if(typeof functionOrKey === &#39;string&#39;){ for(let i=0; i&amp;lt;collection.length; i++){ arr.push(String.prototype[functionOrKey].apply(collection[i],args)); } }else{ for(let i=0; i&amp;lt;collection.length; i++){ arr.push(functionOrKey.apply(collection[i], args)); } } return arr }; _.invoke = function(collection, functionOrKey, args) { var result = []; if(typeof functionOrKey === &#39;string&#39;){ _.each(collection, function(el){ result.push(String.prototype[functionOrKey].apply(el, args)) }); }else{ _.each(collection,function(el){ result.push(functionOrKey.apply(el, args)); }); } return result; };_.invoke는 배열에 functionOrKey을 적용시킨 뒤, 해당 배열을 리턴시킵니다._.zip _.zip = function() { var arr = []; for(let i=0; i &amp;lt; arguments.length; i++){ arr.push(arguments[i].length); } var maxlength = Math.max.apply(null, arr); var result = []; for(let i=0; i &amp;lt; maxlength; i++){ let newArr = []; for(let j=0; j &amp;lt; arguments.length; j++){ if(arguments[j][i] === undefined){ newArr.push(undefined); }else{ newArr.push(arguments[j][i]) } } result.push(newArr); } return result; };_.zip은 배열의 각 인덱스를 요소들을 새로운 배열에 병합시켜 반환한다.예) _.zip([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;], [1,2,3]) returns [[&#39;a&#39;,1], [&#39;b&#39;,2], [&#39;c&#39;,3], [&#39;d&#39;,undefined]]_.intersection _.intersection = function() { var arr = []; for(let i=0; i &amp;lt; arguments[0].length; i++){ for(let j=1; j &amp;lt; arguments.length; j++){ if(arguments[0][i]===arguments[j][i]){ arr.push(arguments[0][i]); } } } return arr; }; _.intersection = function() { var arr = []; for(let i=0; i&amp;lt;arguments[0].length; i++){ for(let j=1; j&amp;lt;arguments.length; j++){ if(_.contains(arguments[j], arguments[0][i])){ arr.push(arguments[0][i]); } } } return arr; };_.intersection는 배열들의 교집합을 찾아 반환한다._.difference _.difference = function(array) { for(let i=0; i&amp;lt;arguments[0].length; i++){ for(let j=1; j &amp;lt; arguments.length; j++){ if(_.contains(arguments[j], arguments[0][i])){ arguments[0][i]=false; } } } return _.filter(arguments[0],function(el){ return el !== false; }); };_.difference배열들의 차집합을 찾아 반환한다._.memoize _.memoize = function(func) { var results = {}; return function() { var args = Array.prototype.slice.call(arguments); var key = JSON.stringify(args); if (!(key in results)) { results[key] = func.apply(this, args); } return results[key]; }; };" }, { "title": "Arrow Function 화살표 함수", "url": "/posts/%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98/", "categories": "Javascript", "tags": "Arrow Function, 화살표 함수", "date": "2019-11-28 00:00:00 +0900", "snippet": " 화살표 함수에는 없는 것: 함수 이름, this, arguments 생성자로서 사용할 수 없다.화살표 함수는 항상 익명이다.const myFun = function () {}const myFun = () =&amp;gt; {} const fn = (a) =&amp;gt; { console.log(a);};fn();const fn = a =&amp;gt; { console.log(a);};this가 없다.const name = &#39;ni&#39;;function school (code) { return { name: &#39;ken &#39; + code, logName: () =&amp;gt; { console.log(this.name); console.log(arguments); } };}const obj = school(378);obj.logName(1,2,3);arguments가 없다.const myFun = () =&amp;gt; { console.log(arguments); // error}myFun(1, 2, 3, 4);화살표 함수에서는 arguments가 없다.function outter () { const myFun = () =&amp;gt; { console.log(arguments); } myFun();}outter(1, 2, 3, 4); 위와 같이 outter 함수를 감싸주면 화살표 함수는 outter의 scope를 참조한다.const myFun = (...args) =&amp;gt; { console.log(args); // [1, 2, 3]}myFun(1, 2, 3); 파라미터 부분에 ...args를 사용하면 배열로 받는다." }, { "title": "let, var, const 차이", "url": "/posts/let-var-const/", "categories": "Javascript", "tags": "let, var, const", "date": "2019-11-27 00:00:00 +0900", "snippet": "let 과 var 의 차이점 let: block scope 안에서 유효한 스코프를 가지고 있으며, 지역변수를 선언한다. var: function scope 안에서 유효한 스코프를 가지고 있으며, 전역변수를 선언할 수 있다. let은 전역 객체를 통해 접근할 수 없지만 var는 접근이 가능하다.let a = 1;var b = 2;console.log(window.a); // undefinedconsole.log(window.b); // 2 let은 재선언 할 수 없지만, var는 재선언 할 수 있다. const는 let과 같은 유효범위를 가지고 선언 후, 값을 변경할 수 없다. letBlock Scope란 {}중괄호를 이용하여 구분된 영역을 말한다.{ let a=1; }console.log(a); // errorBlock Scope 에서 유효한 스코프를 가지고있으며, 지역 변수를 선언한다.1. Block Scopelet c = 1;if (true) { let d = 2;}console.log(c + d); // ?Block Scope 에서 유효한 스코프를 가지고 있기 때문에 d를 참조할 수 없다.examplefor (let i = 0; i &amp;lt; 10; i++) { console.log(i);}console.log(i); // errorexamplefor (let i = 1; i &amp;lt; 11; i++) { setTimeout(function () { console.log(i); }, i * 1000);}2. let 은 재선언을 할 수 없지만 재할당은 가능하다.재선언 불가능let a = 1;if (true) { let a = 2; console.log(a);}console.log(a); // error재할당 가능let a = 1;if (true) { a = 2; console.log(a);}console.log(a); // 23. let 은 hoisting은 되지만 error를 발생한다.let은 초기 값을 할당하지 않으면 undefined가 초기 값으로 할당된다.let a;console.log(a) // undefinedhoisting은 되지만 error를 발생한다.function doSomething() { console.log(bar); console.log(foo); var bar = 1; let foo = 2;}doSomething();4. let 을 이용하여 선언한 변수는 글로벌 객체에 입력되지 않는다.var x = &#39;global x&#39;;let y = &#39;global y&#39;;console.log(window.x); // &#39;global x&#39;console.log(window.y); // undefinedvar1. function scopefunction scope 안에서 유효한 스코프를 가지고 있으며, 전역변수를 선언할 수 있다.function scopefunction foo () { for (var i = 0; i &amp;lt; 10; i++) { console.log(i); } console.log(i); // 10}foo();2. var 는 재선언이 가능하다.var a = 1;if (true) { var a = 2; console.log(a); }console.log(a); // 23. var 를 이용하여 선언한 변수는 글로벌 객체에 입력된다.var x = &#39;global x&#39;;let y = &#39;global y&#39;;console.log(window.x); // &#39;global x&#39;console.log(window.y); // undefined4. var 의 hoistingvar는 초기 값을 할당하지 않으면 undefined가 초기 값으로 할당된다.var a;console.log(a); // undefinedhoistingfunction doSomething() { console.log(bar); // undefined var bar = 1;}doSomething(); hoisting이 되면서 콘솔에 undefined가 출력된다.constconst를 이용하여 선언한 변수는 let을 이용하여 선언한 변수와 거의 동일하다. 다만 재할당을 할 수 없다.1. 반드시 초기 값을 할당해야 한다.ex 14)const a; // error2. 재선언, 재할당 모두 할 수 없다.재선언 할 수 없다.const a = 5;const a = 2; // error선언 이후 다른 값을 할당할 수 없다.const foo = 2;foo = 3; // error3. 객체일 때 속성 값을 추가 할 수 있다.const obj = {};obj.say = &#39;hello&#39;; " }, { "title": "Prototype", "url": "/posts/Prototype/", "categories": "Javascript", "tags": "Prototype", "date": "2019-11-19 00:00:00 +0900", "snippet": "객체지향생성자함수와 new 키워드 생성자(constructor)는 객체를 만드는 역할을 하는 함수(class)이다. 함수 앞에 new를 붙이면 리턴 값은 객체(instance)가 된다. 생성자 함수이름 첫글자를 대문자로 표기해 준다.ex)function Array () { // 생략 } // 생성자 함수new Array() // instance 객체가 반환된다.function Object () { // 생략 } // 생성자 함수new Object() // instance 객체가 반환된다.function String () { // 생략 } // 생성자 함수new String() // instance 객체가 반환된다.ex)var arr = []; === var arr = new Array();모든 자바스크립트 객체는 생성자 함수를 이용해서 만들어 지는것과 같다.Prototypeex)function foo() {} // 생성자함수foo.prototype // `prototype`이라는 속성을 가지고 있는 객체를 가지게 된다. 함수는 객체이기 때문에 key와 value를 가질수있다. 모든 함수에는 ‘prototype’ 이라는 속성을 가지고 있고 값으로 객체를 가지게 된다. 생성자 함수는 첫 글자를 대문자로 표기해 준다. ex) function Foo() {} // 생성자함수Foo.prototype // 모든 함수에는 &#39;prototype&#39; 이라는 속성을 가지고 있다.Foo.prototype.constacrtor // 생성자 함수를 가리킨다. foo.prototype 객체는 constacrtor 속성을 가지고있고 foo.prototype.constacrtor는 생성자 함수를 가리키게 된다. instanceex)function Object () { // 생략 } // 생성자 함수new Object() // instance 객체가 반환된다.new Object() 는 생성자 함수와 prototype 기능을 모두 빌려쓸 수 있는 객체가 반환된다.EX5 or EX6EX5function Car(brand, name, color) { // 생략}Car.prototype.refuel = function() { // 생략}Car.prototype.drive = function() { // 생략}EX6class Car { constructor(brand, name, color) { // 생략 } refuel() { // 생략 } drive() { // 생략 }}" }, { "title": "CSS layout", "url": "/posts/CSS-layout/", "categories": "Frontend", "tags": "css layout", "date": "2019-11-19 00:00:00 +0900", "snippet": "block vs inlineblock element 화면 전체를 사용하는 태그&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;inline element 화면의 일부를 차지하는 태그&amp;lt;span&amp;gt;반갑습니다.&amp;lt;/span&amp;gt;block vs inline&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;안녕하세요. &amp;lt;span&amp;gt;반갑습니다.&amp;lt;/span&amp;gt;displaydisplay 속성을 사용해서 block element 를 inline element 로 바꿀수 있고, inline element를 block element 로 바꿀수 있다.html&amp;lt;h1&amp;gt;Hello world&amp;lt;/h1&amp;gt;안녕하세요. &amp;lt;span&amp;gt;반갑습니다.&amp;lt;/span&amp;gt;cssh1,span { border:1px solid red;}h1 { display: inline;}span { display:block;}박스 모델(box model)사각형의 형태(box)로 그 태그의 부피감을 결정한다박스모델 관련 속성들 margin : 태그와 태그 사이의 여백. padding : 태그와 내부 컨텐츠 사이의 여백 border: width style color; 순서로 값 지정inline element는 width, height 값이 무시 된다.box-sizing 박스의 크기를 화면에 표시하는 방식을 변경하는 속성. width와 height는 엘리먼트의 컨텐츠의 크기를 지정한다. content를 기준으로 하기 때문에 테두리가 있는 경우에는 테두리의 두께로 인해서 원하는 크기를 찾기가 어렵다.box-sizing:border-box; 로 지정하면 테두리를 포함한 크기를 지정할 수 있기 때문에 예측하기가 더 쉽다.html&amp;lt;div id=&quot;small&quot;&amp;gt;Hello&amp;lt;/div&amp;gt;&amp;lt;div id=&quot;large&quot;&amp;gt;Hello&amp;lt;/div&amp;gt;cssdiv { margin:10px; width:150px;}#small { border:10px solid black;}#large{ border:30px solid black;}css * { box-sizing:border-box; }* { box-sizing:border-box; } div { margin:10px; width:150px;}#small { border:10px solid black;}#large{ border:30px solid black;}position엘리먼트의 위치를 지정하는 4가지 방법 static relative absolute fixedstatic VS relativeposition: static기본값으로 position 값을 지정하지 않을경우 static이 기본값으로 들어간다.position: relativeposition 속성의 값을 relative로 할 경우 부모 태그를 기준으로 ‘position’ 을 잡는다.html &amp;lt;div id=&#39;container&#39;&amp;gt; &amp;lt;div id=&#39;parent&#39;&amp;gt; 부모 &amp;lt;div id=&#39;me&#39;&amp;gt; me &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;css* { box-sizing: border-box;}#container { border: 2px solid black;}#parent { border: 2px solid black; width: 50%; height: 100%; position: relative;}#me { border: 2px solid black; position: relative; width: 50%; height: 100%;}absolute부모태크를 무시하고 body태그 기준으로 위치를 잡는다.부모태그중 positon의 값이 static 아닌경우 부모태그를 기준으로 위치를 잡는다.html &amp;lt;div id=&#39;container&#39;&amp;gt; &amp;lt;div id=&#39;parent&#39;&amp;gt; 부모 &amp;lt;div id=&#39;me&#39;&amp;gt; me &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;css* { box-sizing: border-box;}#container { border: 2px solid black;}#parent { border: 2px solid black;}#me { background-color: black; color: white; border: 2px solid black; position: absolute; left:0; top:0;}부모태그에 position 값이 없을때부모태그에 position 값이 있을때fixed부모태그를 무시하고 스크롤을 내려도 지정된 위치에 있는다.html &amp;lt;div id=&#39;container&#39;&amp;gt; &amp;lt;div id=&#39;parent&#39;&amp;gt; 부모 &amp;lt;div id=&#39;me&#39;&amp;gt; me &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;css* { box-sizing: border-box;}#container { border: 2px solid black;}#parent { border: 2px solid black; position: relative;}#me { background-color: black; color: white; border: 2px solid black; position: fixed; left:0; top:0;}flexflex를 사용하기 위해서는 컨테이너 태그에 display:flex 속성을 부여한다.flex-direction을 이용해서 정렬방향을 바꿀 수 있다.flex-directiondms 기본적으로 row 라는 기본값을 갖게 된다.display: flex flex-directiondms: rowflex-directiondms 기본적으로 row 라는 기본값을 갖게 되고 수평방향으로 정렬된다.html &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row; } .item { background-color: tomato; color:white; border:1px solid white; }flex-direction:row-reverse;row 반대로 정렬된다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row-reverse; } .item { background-color: tomato; color:white; border:1px solid white; }flex-direction:column;수직방향으로 정렬된다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:column; } .item { background-color: tomato; color:white; border:1px solid white; }flex-direction:column-reversecolumn 반대로 정렬된다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:column-reverse; } .item { background-color: tomato; color:white; border:1px solid white; }flex-basisflex 방향에 해당되는 엘리먼트의 크기를 지정한다.html &amp;lt;div class=&quot;container&quot;&amp;gt; &amp;lt;div class=&quot;item first&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row; } .item { background-color: tomato; color:white; border:1px solid white; } .first { flex-basis: 200px; }flex-grow &amp;amp; shrinkflex-growflex-grow의 기본값은 0이다.flex-grow에 값을 주면 element 들이 여백 전체를 n/1로 나눠 갖는다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row; } .item { background-color: tomato; color:white; border:1px solid white; flex-grow:1; }n/1에서 우선순위가 .first가 높아진다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row; } .item { background-color: tomato; color:white; border:1px solid white; flex-grow:1; } .first { flex-grow:2; }.item에 flex-grow:0;을 주게 되면 .first가 여백을 독식하게 된다. .first의 flex-grow값을 어떠한 것으로 바꿔도 여백을 독식한다.css .container { background-color: powderblue; height:200px; display:flex; flex-direction:row; } .item { background-color: tomato; color:white; border:1px solid white; flex-grow:0; } .first { flex-grow:2; }flex-shrink설정된 숫자값에 따라 flex-container 요소 내부에서 flex-item 요소의 크기가 축소된다.flex-shrink: 0;일 때 는 element의 크기가 축소 되지 않는다. 참조 https://codepen.io/enxaneta/pen/adLPwv" }, { "title": "This", "url": "/posts/This/", "categories": "Javascript", "tags": "This", "date": "2019-11-17 00:00:00 +0900", "snippet": " this는 함수 내에서 함수를 호출한다. 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다.var a = &#39;hello world&#39;;function foo () { console.log(this.name); // this는 객체이다.}var obj = { &#39;a&#39;: &#39;obj&#39;, &#39;b&#39;: foo};foo(); // &#39;hello world&#39;obj.foo(); // &#39;obj&#39;객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다. foo(); === window.foo();window.log() (this는 window를 가리킨다.)obj.logName() (this는 obj를 가리킨다.)모든 객체는 전역 객체의 프로퍼티다.examplevar a = &#39;Hello?&#39;;function foo () { console.log(&#39;world&#39;);}console.log(a); // &#39;Hello?&#39;console.log(window.a) // &#39;Hello?&#39;foo(); // &#39;world&#39;window.foo(); // &#39;world&#39;a와 window.a는 같고,foo();와 window.foo();는 같다.모든 전역변수와 함수는 window 객체의 프로퍼티다.객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다.var obj = { &#39;foo&#39;: function () { console.log(&#39;Hello?&#39;); }}obj.foo(); // &#39;Hello?&#39;window.o.foo(); //&#39;Hello?&#39;console.log(obj.foo === window.obj.foo); // true자바스크립트에서 모든 객체는 기본적으로 전역객체의 프로퍼티이다.var a = &#39;외부&#39;;function foo () { var a = &#39;내부&#39;; bar();}function bar () { console.log(this.a); }foo(); // &#39;외부&#39;bar();는 window.bar() 같기 때문에 this는 전역객체 window.a를 가리킨다.use strict 모드오류를 보안해주기위해 엄격한 코드실행을 해주는 환경엄격모드를 전체 스크립트에 적용하기 위해, 정확한 구문 “use strict”;(또는 ‘use strict’;) 을 다른 구문 작성 전에 삽입한다.example&#39;use strict&#39;;var a = &#39;hello&#39;;function foo () { console.log(this.a); // &#39;this&#39; === undefined}foo();‘use strict’ 모드가 적용 되면 &#39;this&#39; === undefined 로 설정된다.window를 가리키고 싶다면 ?&#39;use strict&#39;;var a = &#39;hello&#39;;function foo () { console.log(window.a); }foo();Method 호출: 부모 object객체의 소속인 메소드의 this는 그 객체를 가리킨다examplevar a = &#39;hello&#39;;var obj = { a: &#39;world&#39;, foo: function foo () { console.log(this.a); }}obj.foo(); // &#39;world&#39;window.foo() ‘this’는 ‘window’를 가리킨다obj.foo() ‘this’는 ‘hello’를 가리킨다examplefunction foo () { console.log(this.a);}var a = &#39;hello&#39;;var obj1 = { a: &#39;world&#39;, foo: foo};var obj2 = { a: &#39;javascript&#39;, foo: foo};obj1.foo(); // &#39;world&#39;obj2.foo(); // &#39;javascript&#39;obj1.foo(); this는 ‘world’를 가리킨다.obj2.foo(); this는 ‘javascript’를 가리킨다.examplevar a = &#39;hello&#39;;var obj1 = { a: &#39;world&#39;, foo: function bar () { console.log(this.a); }};var obj2 = { age: &#39;javascript&#39;, foo: obj1.foo};var foo = obj1.foo;obj1.foo(); // &#39;world&#39;obj2.foo(); // &#39;javascript&#39;foo(); // &#39;hello&#39; hello.foo();this는 hello이 된다.apple.foo(); this는 apple이 된다.foo(); this는 window가 된다.call, apply, bind 호출 this를 명시적으로 넘겨줄 때 사용한다. call ,apply 를 호출하면 this는 괄호 안에 있는 것을 가리킨다. 괄호 안에 undefined,null 넣으면 this는 window를 가리킨다.call, applyexamplevar a = &#39;hello&#39;;function foo () { console.log(this.a);}var obj1 = { a: &#39;world&#39;,};var obj2 = { a: &#39;javascript&#39;};foo(); // &#39;hello&#39;foo.call(obj1); // &#39;world&#39;foo.apply(obj2); // &#39;javascript&#39;call or apply을 호출했을 때 this를 명시적으로 넘겨준다.call , apply 의 괄호 첫번째 인자에는 this를 넣어준다.foo.call(obj1);‘this’는 ‘obj1’을 가리킨다.foo.apply(obj2); ‘this’는 ‘obj2’을 가리킨다.apply 는 인자를 배열로 넘겨주고, call은 인자를 쉼표로 넘겨준다.example) callvar str = &#39;hello&#39;;function foo (a, b, c, d, e) { console.log(this.str); console.log(arguments);}var obj = { str: &#39;world&#39;};foo.call(obj, 1, 2, 3, 4, 5); 인자의 수가 정해져 있지 않다. 쉼표로 인자를 받는다.example) applyvar str = &#39;hello&#39;;function foo (a, b, c, d, e) { console.log(this.str); console.log(arguments);}var obj = { str: &#39;world&#39;};foo.apply(obj, [1, 2, 3, 4, 5]); 인자를 2개만 받는다. 첫번째는 this값을 넣어주고, 두번째는 인자는 배열로 들어간다.bindthis값을 설정을 해놓은 함수를 실행하지 않고 함수 자체를 반환해 준다.example) bindvar str = &#39;hello&#39;;function foo (a, b, c, d, e) { console.log(this.str); console.log(arguments);}var obj = { str: &#39;world&#39;};var bar = foo.bind(obj, 1, 2, 3, 4, 5);bar(); // world // 1, 2, 3, 4, 5foo라는 함수인에 this 값을 obj로 설정해놓은 함수를 var bar라는 변수에 담았다. bar() 실행하면 world를 콘솔에 찍고 arguments ‘1, 2, 3, 4, 5’ 유사배열을 콘솔에 찍는다.생성자와 new생성자함수, new키워드, this 생성자(constructor)는 객체를 만드는 역할을 하는 함수(class)이다. 생성자함수는 첫글자를 대문자로 표기한다. 함수 앞에 new를 붙이면 리턴 값은 객체(instance)가 된다. 생성자 함수이름 첫글자를 대문자로 표기해 준다.examplefunction Foo () { console.log(this); // {}} // 생성자 함수 classnew foo(); // 객체 instance new 키워드를 사용하여 함수를 호출하면 함수안의 this의 값은 빈 객체가 할당되어서 함수가 실행된다.examplefunction Foo () { this.a = &#39;hello world&#39;;}var c = new Foo();아래와 같이 this를 return 해주는것과 같다.function Foo () { // this = {}; this.a = &#39;hello world&#39;; /* { a: &#39;hello world&#39;; } return this; */}var c = new Foo();EX5 or EX6EX5function Car(brand, name, color) { // 생략}EX6class Car { constructor(brand, name, color) { // 생략 }" }, { "title": "재귀함수 Recursion", "url": "/posts/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98/", "categories": "Javascript", "tags": "Recursion, 재귀함수", "date": "2019-11-15 00:00:00 +0900", "snippet": "Recursion 자기 자신을 호출하는 함수function foo () { foo();}// 무한 반복으로 콜스텍 오버 에러를 낸다. // 반드시 탈출 조건을 만들어 주어야 한다. 재귀 함수를 사용할 때 탈출 조건을 꼭 만들어 주어야 한다.그렇지 않으면 무한 루프를 돌다가 결국 콜스텍 오버 에러를 낸다. 트리구조를 표현, 탐색하기에 재귀함수가 유용하다 장점: 알고리즘이 재귀로 표현했을 때 가독성이 좋다 . 단점: 값이 리턴되기 전까지 호출마다 call stack을 새로 생성하므로, 메모리를 많이 사용한다.Factorial자기 자신의 수에 -1 작은 수를 곱하는 것을 반복해서 1이 될 때까지 곱하는 것.5! = 5 * 4 * 3 * 2 * 1 = 120 === ( 5 * 4! )4! = 4 * 3 * 2 * 1 = 24 === ( 4 * 3!)3! = 3 * 2 * 1 = 6 === ( 3 * 2!)2! = 2 * 1 = 2 === ( 2 * 1!)1! = 1 =1 5 * 4! 4 * 3! 3 * 2! 2 * 1! n! = n * (n-1)!재귀 함수 표현function factorial (n) { if(n === 1){ return 1; } // 탈출조건이 된다 return n * factorial(n-1);}반복문 표현function factorial (n) { let result = 1; for(let i = n; i &amp;gt; 0; i--){ result = result * n; } return result;}Fibonacci 수열앞의 두수의 합이 다음번 수열의 값.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946...n === (n - 1) + (n - 2)fib(n) === fib(n -1) + fib(n - 2)n &amp;gt; 1fib(0) === 0fib(1) === 1재귀 함수 표현function fibonacci (n) { // n === (n - 1) + (n - 2) if(n === 0){ return 0; } if(n === 1){ return 1; } return fibonacci(n - 1) + fibonacci(n - 2); }재귀 함수 예제ex1) 모든 DOM 요소 tagName console.log 찍기function logAll (el) { // TO DO..}logAll(document.body);문제 풀이function logAll (el) { console.log(el.tagName); if(el.children.length &amp;gt; 0) { for(var i = 0; i &amp;lt; el.children.length; i++) { logAll(el.children[i]); } }}logAll(document.body);ex2) getElementsByClassName 재귀 함수function getElementsByClassName (el) { // TODO..}문제풀이function getElementsByClassName (className) { let arr = []; let body = document.body; function recursion(el) { if(el.classList.contains(className)){ arr.push(el); } if(el.children.length &amp;gt; 0){ for(let i =0; i &amp;lt; el.children.length; i++){ recursion(el.children[i]); } } } recursion(body); return arr; }getElementsByClassName(className);" }, { "title": "Closure 클로저", "url": "/posts/Closure/", "categories": "Javascript", "tags": "closure, 클로저", "date": "2019-11-15 00:00:00 +0900", "snippet": "Closure 외부 함수 안에 있는 내부 함수. 내부 함수가 외부 함수에 접근할 수 있는 것을 클로저라 한다. 클로저 함수 안에서는 지역변수(innerVar) 외부 함수의 변수(outerVar) 전역변수(glovalVar)의 접근이 전부 가능하다. 함수가 본인이 생성된 주변 환경을 지속적으로 기억하는것을 의미한다. 함수가 실행되는 위치가 어디인지 관계가 없다.ex1)function add () { var str1 = &#39;hello&#39;; var str2 = &#39;world&#39;; function strAdd () { console.log(str1 + &#39; &#39; +str2); } return strAdd;}var a = add();a(); // &quot;hello world&quot;함수가 생성된 주변 환경을 지속적으로 기억하기 때문에 str1과 str2 변수에 접근할수 있게 되면서 콘솔에 ‘hello world’를 찍게 된다.ex4) ( 커링 )function makeAdder (x) { return function add (y) { return x + y; }}var addFive = makeAdder(5);var addTen = makeAdder(10);addTen(2); // 7addFive(1); // 11풀이var addFive 에 makeAdder(5); 을 할당한것은 function add (y) { return 5 + y; }이 되고 var addTen 에 makeAdder(10);을 할당한것은 function add (y) { return 5 + y; }된다.addTen(2); 을 실행하면 새로운 makeAdder Scope가 생기고 콘솔에 7이 찍히고 addFive(1);을 실행하면 또 새로운 makeAdder Scope가 생기고 콘솔에 11이 찍히게 된다.클로저 모듈 패턴function makeCounter() { let privateCounter = 0; return { increment: function() { privateCounter++; }, decrement: function() { privateCounter--; }, getValue: function() { return privateCounter; } }}// let obj = {} return obj와 같다.let counter1 = makeCounter();counter1.increment();counter1.increment();counter1.getValue(); // 2let counter2 = makeCounter();counter2.increment();counter2.decrement();counter2.increment();counter2.getValue(); //1 객체의 key의 값이 함수일 때 메소드이다. 변수를 스코프 안쪽에 가두어 함수 밖으로 노출시키지 않는 방법. counter1, counter2 두 카운터에 각기 다른 privateCounter를 다루면서 PrivateCounter를 밖으로 노출시키지 않는다.이를 통해서 객체의 내부에서만 사용해야 하는 값이 노출됨으로서 생길 수 있는 오류를 줄일 수 있다.for loop closureclosure examplefor (var i = 1; i &amp;lt; 6; i++) { setTimeout(function () { console.log(i); }, i * 1000);}시간 로그1초 12초 23초 34초 45초 5클로저function test () { for (var i = 1; i &amp;lt; 6; i++) { (function(ct) { setTimeout(function () { console.log(ct); }, ct * 1000); })(i); }}test();블록 스코프 let 사용for (let i = 1; i &amp;lt; 6; i++) { setTimeout(function () { console.log(i); }, i * 1000);}" }, { "title": "Scope", "url": "/posts/Scope/", "categories": "Javascript", "tags": "scope", "date": "2019-11-14 00:00:00 +0900", "snippet": "Scope란? 변수가 접근가능한 범위이다. 내부와 외부를 판별하는 기준은 함수이다. var 키워드는 함수 단위함수가 하나의 범위. let 키워드는 ‘{}’ 중괄호가 하나의 범위. 내부에서 외부는 접근 가능하지만, 외부에서 내부는 접근 불가능 하다.var a = &#39;out&#39;; // 함수 밖에서 변수를 선언하면 전역변수function foo () { var b = &#39;in&#39;; //함수 내에서 변수를 선언하면 지역변수 console.log(b); // &#39;in&#39; console.log(a); // &#39;out&#39; } foo();console.log(b); // error 외부에서 내부 접근이 불가능 하다. 함수가 범위의 기준이 된다. 내부에서 외부는 접근 가능하지만, 외부에서 내부는 접근 불가능 하다.var a = &#39;global&#39;; // 전역변수function foo () { var a = &#39;local&#39;; // 지역변수 alert(&#39;함수안 &#39; , a); // &#39;local&#39;}foo();alert(&#39;함수밖 &#39; + a); // &#39;global&#39; 함수 안에서 같은 이름의 지역변수와 전역변수가 동시에 정의되어 있다면 지역변수를 우선순위를 가진다var a = &#39;global&#39;; // 전역변수function foo () { a = &#39;local&#39;; // 전역변수 a의 &#39;global&#39; 을 &#39;local&#39;로 재할당 alert(&#39;함수안 &#39; + a); // &#39;local&#39;}foo();alert(&#39;함수밖 &#39; , a); // &#39;local&#39; 선언 키워드 없이 함수 안에서 전역변수와 같은 변수에 값을 할당하면 전역 변수의 값을 재할당 하는 것이다.for loop 와 varfunction foo () {var a = 5;for (var i=0; i &amp;lt; a; i++) { i = i + 1;} console.log(i); // 6 -&amp;gt; i는 foo함수의 scope}foo();위와 같은 경우 i++을 하고 i = i + 1 하면서 콘솔에 6이 찍힌다. i는 foo함수의 scope를 가진다.let, const Socpe let과 const는 블록 단위로 스코프가 정해진다.function foo () { let a = 5; for (let i=0; i &amp;lt; a; i++) { i = i + 1; } console.log(i); // erro }foo();let과 const키워드는 {} 중괄호 scope 범위를 가진다.i는 for 문 {}중괄호 scope를 가지기 때문에 console.log(i)를 실행했을 경우 중괄호 내부 변수에 접근할 수 없다.Hoistinghoistingconsole.log(a); // undefindvar a = 1;console.log(a); // 1 첫 번째 console.log(a); 이 undefind가 뜨는 이유는 hoisting 때문이다. 실제로 실행될 때에는 아래와 같이 변수를 선언하는 부분이 끌어올려지는 것과 같기 때문에 var a;에 값이 할당되어 있지 않으므로 undefinde 가 된다.var a;console.log(a);a=1;console.log(a);본인이 속한 Scope 내에서 Hoistingvar a = &#39;hello&#39;;function foo () { alert(a); // undefind var a = &#39;world&#39;;}foo();alert(me);는 undefind가 된다.아래와같이 Scope 내에서 Hoisting 되기 때문이다.var a = &#39;hello&#39;;function foo () { var a; alert(a); a = &#39;world&#39;;}foo();함수 표현식 Hoisiting변수를 만들고 함수를 할당하는 방식을 함수 표현식이라고 한다.fn(); // ERRORvar fn = funcion () { console.log(&#39;hello world&#39;);};fn(); 함수 표현식 또한 변수에 함수를 할당하면 아래와 같이 변수 var fn;이 hoisting 되고 var fn;는 undefind이기 때문에 var fn;를 호출하면 undefind가 호출되면서 ERROR 가 뜨게된다.var fn;fn(); // ERRORvar fn = funcion () { console.log(&#39;hello world&#39;);};fn();함수 선언식 Hoisiting아래와 같이 함수 선언식으로 함수를 정의할 경우 함수가 모두 호출된다.fn();function fn () { console.log(&#39;hello world&#39;);}fn();아래와 같이 함수 자체가 hoistiong 된다.function fn () { console.log(&#39;hello world&#39;);}fn();fn();Primitive vs ReferencePrimitive 원시형var a = 1;var b = 1;var c = &#39;hello&#39;;var d = &#39;hello&#39;;console.log(a === b); // trueconsole.log(c === d); // true a와 b는 같다. c와 d는 같다.Reference 참조형var arr1 = [ 1, 2, 3 ];var arr2 = [ 1, 2, 3 ];var obj1 = {a: 1, b: 2};var obj2 = {a: 1, b: 2};console.log(arr1 === arr2); // falseconsole.log(obj1 === obj2); // falsearr1과 arr2 모두 선언한 후 배열을 만들어 생성하였다.위와 같은 경우 arr1과 arr2가 같아 보일 수 있지만 실제로 arr1과 arr2는 다른 배열이다. 서로의 위치에서 만들어진 값으로 위치 값이 다르기 때문에 false이다.var arr1 = [ 1, 2, 3 ];var arr2 = arr1;var obj1 = {a: 1, b: 2};var obj2 = obj1;console.log(arr1 === arr2); // trueconsole.log(obj1 === obj2); // truearr1을 arr1에 할당한 것으로 위치 값이 같이 때문에 true 이다." }, { "title": "Document Object Model", "url": "/posts/DOM/", "categories": "Frontend", "tags": "DOM", "date": "2019-11-12 00:00:00 +0900", "snippet": "DOM(Document Object Model)HTML 은 구성을 짜는 설계도 같은 역할을 하고, CSS 로 디자인을 했다면, DOM을 이용해서 화면을 만들어 준다.documenthtml 문서의 구조와 관계를 객체로 표현한 모델.html 문서도 javascript 객체도 부모와 자식이 있는 트리구조 이다.document라는 전역 변수로 접근이 가능하다.아래 그림과 같이 document에 html이 담겨있다.$0 키워드를 이용해서 콘솔에서 선택한 엘리먼트에 접근할 수 있다console.dir로 접근하면 객체 모양으로 element가 가지고 있는 다양한 속성들을 볼 수 있다DOM 엘리먼트를 선택하는 방법querySelectorclass 선택: .document.querySelector(&#39;.show-element&#39;);Id 선택: # 제공한 선택자 또는 선택자 뭉치와 일치하는 문서 내 첫 번째 Element를 반환한다. 일치하는 요소가 없으면 null을 반환한다. 클래스를 사용하는 classList 중 가장 첫번째 요소를 가지고 온다.querySelectorAlldocument.querySelectorAll(&#39;.customize-dialog&#39;); nodeList 유사배열로 반환된다. 일치하는 것이 없는 경우에는 비어 있는 NodeList 빈배열을 반환한다.getElementsByClassNamedocument.getElementsByClassName(&#39;storylink&#39;); HTMLCollection 유사배열로 반환된다. 일치하는 것이 없는 경우에는 비어 있는 HTMLCollection 빈배열을 반환한다.getElementByIddocument.querySelector(&#39;#one-google&#39;); ID는 대소문자를 구분하는 문자열로, 문서 내에서 유일해야 한다. 하나의 값은 하나의 요소만 사용할 수 있다. 일치하는 요소가 없으면 null을 반환한다.getElementsByTagNamedocument.getElementsByTagName(&#39;span&#39;); HTMLCollection 유사배열로 반환된다. 일치하는 것이 없는 경우에는 비어 있는 HTMLCollection 빈배열을 반환한다.# 부모, 형제, 자식 요소들을 선택하는 방법 ***parentElementelemnt.parentElement; 현재 element 의 부모 element 를 반환한다. 요소가 없다면 null.nextElementSiblingelement.nextElementSibling; 현재 element 의 다음 형제 element 를 반환한다. 요소가 없다면 null.previousElementSibling` element.previousElementSibling;` 현재 element 의 이전 형제 element 를 반환한다. 요소가 없다면 null.childrenelement.children; 현재 element의 자식 elements를 HTMLCollection 유사배열로 반환한다.DOM 엘리먼트를 수정하는 작업1. add, remove, toggle classaddelement.classList.add(&#39;hello-world&#39;); class를 만들고 추가할 수 있다.removeelement.classList.remove(&#39;hello-world&#39;); class를 삭제할 수 있다.toggleelement.classList.toggle(&#39;hello-world&#39;); class가 없다면 추가하고 class가 있다면 삭제할 수 있다.2. Create a DOM elementcreateElementdocument.createElement(&#39;a&#39;); ‘a’태그를 가진 element를 생성한다.3. Add attributessetAttributeelement.setAttribute(&#39;href&#39;, &#39;https://www.naver.com&#39;); 속성을 추가할 수 있다.4. Append an elementappendChildelement.appendChild(element2); element2를 element의 마지막 자식으로 넣어준다.prependelement.prepend(menu); element의 첫번째 자식으로 넣어준다.4. Removing an elementremoveelement.remove() element를 삭제할 수 있다.DOM 엘리먼트에 대한 이벤트 등록 방법Eventshttps://developer.mozilla.org/ko/docs/Web/EventsAddEventListenerelement.addEventListener(&#39;mouseover&#39;, function(){ console.log(&#39;hello world&#39;);}); 인자를 최대 3개까지 넣을 수 있다. 첫 번째 인자로는 이벤트 이름을 적고, 두 번째 인자로는 함수를 넣어준다.Event.target vs Event.currentTargettargettbody.addEventListener(&#39;click&#39;, function(ev){ console.log(ev.target);}); target 속성은 해당 이벤트가 발생한 근원지에 위치한 element 요소를 말한다.currentTargettbody.addEventListener(&#39;click&#39;, function(ev){ console.log(ev.currentTarget);}); currentTarget 속성은 실제로 등록된 dom element 정보를 담고있다." } ]
